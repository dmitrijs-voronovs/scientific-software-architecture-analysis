id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:4442,Energy Efficiency,energy,energy,4442,"c energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is avail",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:4627,Energy Efficiency,energy,energy,4627,"elation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the de",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:5584,Energy Efficiency,energy,energy,5584," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:5611,Energy Efficiency,energy,energy,5611," The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:5716,Energy Efficiency,energy,energy,5716,"MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] f",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:5757,Energy Efficiency,energy,energy,5757,"MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] f",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:5849,Energy Efficiency,energy,energy,5849,"abase db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATIO",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6190,Energy Efficiency,energy,energy,6190,"e, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; T",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6560,Energy Efficiency,energy,energy,6560,"gy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6587,Energy Efficiency,energy,energy,6587,"gy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6714,Energy Efficiency,energy,energy,6714,"onal energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity i",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6810,Energy Efficiency,energy,energy,6810,"IONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respective",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6922,Energy Efficiency,energy,energy,6922,"rsion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the th",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6949,Energy Efficiency,energy,energy,6949,"rsion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the th",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7069,Energy Efficiency,energy,energy,7069,").; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7096,Energy Efficiency,energy,energy,7096,").; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7214,Energy Efficiency,energy,energy,7214,",; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7241,Energy Efficiency,energy,energy,7241,",; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7357,Energy Efficiency,energy,energy,7357,"appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of t",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7384,Energy Efficiency,energy,energy,7384,"appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of t",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7542,Energy Efficiency,energy,energy,7542,"e total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this q",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7583,Energy Efficiency,energy,energy,7583,"e total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this q",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7652,Energy Efficiency,energy,energy,7652," theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7693,Energy Efficiency,energy,energy,7693," theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:7916,Energy Efficiency,energy,energy,7916," MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8073,Energy Efficiency,energy,energy,8073,"y [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8265,Energy Efficiency,energy,energy,8265,"; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function na",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8355,Energy Efficiency,energy,energy,8355,"nergy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyri",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8620,Energy Efficiency,energy,energy,8620,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8661,Energy Efficiency,energy,energy,8661,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8750,Energy Efficiency,energy,energy,8750,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8971,Energy Efficiency,energy,energy,8971,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8998,Energy Efficiency,energy,energy,8998,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:193,Modifiability,variab,variable,193,"﻿. PSI Variables by Alpha — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of th",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:235,Modifiability,variab,variable,235,"﻿. PSI Variables by Alpha — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». PSI Variables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [H]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Components of the coupled-cluster perturbative triples correction [H]. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of th",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:1811,Modifiability,config,configuration,1811,down into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] f,MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:2045,Modifiability,config,configuration,2045,of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; T,MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:2285,Modifiability,config,configuration,2285,CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and cor,MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:2647,Modifiability,config,configuration,2647,RGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY,MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:2816,Modifiability,config,configuration,2816,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL E,MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:3094,Modifiability,config,configuration,3094,vel of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is,MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:3292,Modifiability,config,configuration,3292,"the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORREC",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:3690,Modifiability,config,configuration,3690,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stag",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:4016,Modifiability,config,configuration,4016,"RUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name D",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:4251,Modifiability,variab,variable,4251,"]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQU",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:4394,Modifiability,variab,variable,4394,"ring starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method nam",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:4698,Modifiability,variab,variable,4698,"elation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the de",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:6622,Modifiability,config,configuration,6622,"gy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8427,Modifiability,variab,variables,8427,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8519,Modifiability,variab,variables,8519,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:8853,Modifiability,variab,variable,8853,"tion theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT SAPT0 ENERGY¶. SAPT SAPT2 ENERGY¶. SAPT SAPT2+ ENERGY¶. SAPT SAPT2+(3) ENERGY¶. SAPT SAPT2+3 ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SCF TOTAL ENERGY¶; The total electronic energy [H] of the SCF stage of the calculation.; The CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding TOTAL ENERGY variables; less this quantity. Constructed from Eq. (2). (2). TWO-ELECTRON ENERGY¶; The two-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (2). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. Previous topic; Keywords by Alpha; Next topic; Keywords by Module; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html:4568,Performance,optimiz,optimizer,4568,"of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELAT",MatchSource.WIKI,psi4manual/4.0b2/glossary_psivariables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables.html
https://psicode.org/psi4manual/4.0b2/index.html:2765,Deployability,update,updated,2765,"is Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; Hartree–Fock Theory; Density Functional Theory; Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Ab Initio Polarization Propagator; Symmetry-Adapted Perturbation Theory; Coupled Cluster Methods; PSIMRCC Implementation of Mk-MRCC Theory; Interface to MRCC by M. Kállay; Configuration Interaction; Geometry Optimization. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Function Intercalls; Embarrassing Parallelism. Interfaces: Enhancing PSI4 Capabilities. Customization: Adding Simple Extensions; User-Defined Basis Sets; Defining a Method Alias; Creating a Database. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Best Practices for Python Functions; Documentation. Programming: Using the Core Libraries. Emerging Theoretical Methods: Plugins DFADC to RQCHF; plugin_cepa; plugin_ccsort; plugin_dfadc; plugin_test_matrix; plugin_ccsd_serial; plugin_libfock; plugin_aointegrals; plugin_mp2; plugin_sointegrals; plugin_testparse; plugin_rqchf; plugin_omega; plugin_mointegrals; plugin_backtrans. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. PsiMod: Linking C++ and Python; Appendices; Bibliography; Test Suite and Sample Inputs; Basis Sets by Element; DFT Functionals; Keywords by Alpha; PSI Variables by Alpha; Keywords by Module; PSI Variables by Module. Indices. Index; Module Index; Search Page. Next topic; Introduction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/index.html
https://psicode.org/psi4manual/4.0b2/index.html:2241,Integrability,wrap,wrappers,2241,"is Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; Hartree–Fock Theory; Density Functional Theory; Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Ab Initio Polarization Propagator; Symmetry-Adapted Perturbation Theory; Coupled Cluster Methods; PSIMRCC Implementation of Mk-MRCC Theory; Interface to MRCC by M. Kállay; Configuration Interaction; Geometry Optimization. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Function Intercalls; Embarrassing Parallelism. Interfaces: Enhancing PSI4 Capabilities. Customization: Adding Simple Extensions; User-Defined Basis Sets; Defining a Method Alias; Creating a Database. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Best Practices for Python Functions; Documentation. Programming: Using the Core Libraries. Emerging Theoretical Methods: Plugins DFADC to RQCHF; plugin_cepa; plugin_ccsort; plugin_dfadc; plugin_test_matrix; plugin_ccsd_serial; plugin_libfock; plugin_aointegrals; plugin_mp2; plugin_sointegrals; plugin_testparse; plugin_rqchf; plugin_omega; plugin_mointegrals; plugin_backtrans. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. PsiMod: Linking C++ and Python; Appendices; Bibliography; Test Suite and Sample Inputs; Basis Sets by Element; DFT Functionals; Keywords by Alpha; PSI Variables by Alpha; Keywords by Module; PSI Variables by Module. Indices. Index; Module Index; Search Page. Next topic; Introduction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/index.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:2021,Deployability,update,updated,2021,"s |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:425,Energy Efficiency,energy,energy,425,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:552,Energy Efficiency,energy,energy,552,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:588,Energy Efficiency,energy,energy,588,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:738,Energy Efficiency,energy,energy,738,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:914,Energy Efficiency,energy,energy,914,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:1037,Energy Efficiency,energy,energy,1037," Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Create",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:1067,Energy Efficiency,energy,energy,1067," Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Create",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:336,Performance,optimiz,optimize,336,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls-1.html:630,Security,validat,validated,630,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls-1.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:2021,Deployability,update,updated,2021,"s |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:425,Energy Efficiency,energy,energy,425,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:552,Energy Efficiency,energy,energy,552,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:588,Energy Efficiency,energy,energy,588,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:738,Energy Efficiency,energy,energy,738,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:914,Energy Efficiency,energy,energy,914,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:1037,Energy Efficiency,energy,energy,1037," Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Create",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:1067,Energy Efficiency,energy,energy,1067," Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Create",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:336,Performance,optimiz,optimize,336,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/intercalls.html:630,Security,validat,validated,630,"﻿. Function Intercalls — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Function Intercalls¶; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions. Caller; Callee.  ; cp; db; opt; cbs; energy. Counterpoise Correct;  ; —; Y; Y; Y. Database; —;  ; Y; Y; Y. Optimize; —; —;  ; Y; Y. Complete Basis Set; —; —; —;  ; Y. Energy; —; —; —; —;  . The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap_all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. Previous topic; <no title>; Next topic; Embarrassing Parallelism; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, ",MatchSource.WIKI,psi4manual/4.0b2/intercalls.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/intercalls.html
https://psicode.org/psi4manual/4.0b2/interfacing-1.html:846,Deployability,update,updated,846,"﻿. Interfaces: Enhancing PSI4 Capabilities — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Interfaces: Enhancing PSI4 Capabilities¶; PSI4’s capabilites have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to MRCC by M. Kállay PSI4 can drive the MRCC program of M. Kállay and J. Gauss; MPI4Py; MADNESS; Grimme’s dft-d3; MATLAB for new dft functionals. Previous topic; Embarrassing Parallelism; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/interfacing-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/interfacing-1.html
https://psicode.org/psi4manual/4.0b2/interfacing.html:846,Deployability,update,updated,846,"﻿. Interfaces: Enhancing PSI4 Capabilities — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Interfaces: Enhancing PSI4 Capabilities¶; PSI4’s capabilites have been expanded by interfacing with other; software packages. These programs aren’t necessary; for PSI4 to operate and may require additional licences, special; platform capabilities, etc. Interface to MRCC by M. Kállay PSI4 can drive the MRCC program of M. Kállay and J. Gauss; MPI4Py; MADNESS; Grimme’s dft-d3; MATLAB for new dft functionals. Previous topic; Embarrassing Parallelism; Next topic; Customization: Adding Simple Extensions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/interfacing.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/interfacing.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:1534,Availability,avail,available,1534,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:1596,Availability,avail,available,1596,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:4939,Availability,avail,available,4939,"lista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural O",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:6259,Availability,avail,available,6259,". 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest A",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:6351,Availability,avail,available,6351,"ons; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the ran",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:7384,Availability,avail,available,7384,"r certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; ",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:7528,Availability,avail,available,7528,"he file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either a",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:8885,Availability,reliab,reliability,8885,"F; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Obtaining and Installing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or f",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:6402,Deployability,install,installation,6402,"r Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:6462,Deployability,install,installation,6462,"r Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:9994,Deployability,update,updated,9994,"UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Obtaining and Installing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:326,Energy Efficiency,efficient,efficiently,326,"﻿. Introduction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:5007,Energy Efficiency,adapt,adapted,5007," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:8474,Energy Efficiency,energy,energy,8474,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:8543,Energy Efficiency,energy,energy,8543,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:477,Integrability,rout,routine,477,"﻿. Introduction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:9478,Integrability,rout,routines,9478,"UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Obtaining and Installing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:5007,Modifiability,adapt,adapted,5007," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:1369,Performance,optimiz,optimization,1369,"machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:7083,Performance,perform,perform,7083,"stalling PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/U",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:8406,Performance,optimiz,optimization,8406,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:8497,Performance,perform,performed,8497,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:6419,Testability,test,testing,6419,"r Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:6793,Testability,test,tested,6793,"ethods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. ",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction-1.html:460,Usability,simpl,simple,460,"﻿. Introduction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney",MatchSource.WIKI,psi4manual/4.0b2/introduction-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html
https://psicode.org/psi4manual/4.0b2/introduction.html:1534,Availability,avail,available,1534,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:1596,Availability,avail,available,1596,"ate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending on the particular modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specif",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:4939,Availability,avail,available,4939,"lista, E. Prochnow, J. Gauss, and H. F. Schaefer,; J. Chem. Phys. 132, 074107 (2010). Mk-MRCCSDT(-n). “Triple Excitations in State-Specific Multireference Coupled; Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural O",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:6259,Availability,avail,available,6259,". 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest A",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:6351,Availability,avail,available,6351,"ons; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the ran",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:7384,Availability,avail,available,7384,"r certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; ",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:7528,Availability,avail,available,7528,"he file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either a",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:8885,Availability,reliab,reliability,8885,"F; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Obtaining and Installing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or f",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:6402,Deployability,install,installation,6402,"r Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:6462,Deployability,install,installation,6462,"r Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:9994,Deployability,update,updated,9994,"UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Obtaining and Installing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:326,Energy Efficiency,efficient,efficiently,326,"﻿. Introduction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:5007,Energy Efficiency,adapt,adapted,5007," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:8474,Energy Efficiency,energy,energy,8474,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:8543,Energy Efficiency,energy,energy,8543,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:477,Integrability,rout,routine,477,"﻿. Introduction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:9478,Integrability,rout,routines,9478,"UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS routines only. [4](1, 2) DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. Table Of Contents. Introduction; Overview; Citing PSI4; Obtaining and Installing PSI4; Supported Architectures; Capabilities; Technical Support. Previous topic; <no title>; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:5007,Modifiability,adapt,adapted,5007," Cluster Theory: Application of Mk-MRCCSDT and Mk-MRCCSDT-n Methods to; Model Systems,” F. A. Evangelista, A. C. Simmonett, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009). SAPT (General); All capabilities of the SAPT module are based on Symmetry Adapted; Perturbation Theory. A good review article for this method is as; follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994). The particular implementation and algorithms for various orders of SAPT; available in PSI4 are provided below.; SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherri",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:1369,Performance,optimiz,optimization,1369,"machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:7083,Performance,perform,perform,7083,"stalling PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/U",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:8406,Performance,optimiz,optimization,8406,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:8497,Performance,perform,performed,8497,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:6419,Testability,test,testing,6419,"r Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:6793,Testability,test,tested,6793,"ethods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). Obtaining and Installing PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. ",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/introduction.html:460,Usability,simpl,simple,460,"﻿. Introduction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney",MatchSource.WIKI,psi4manual/4.0b2/introduction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction.html
https://psicode.org/psi4manual/4.0b2/methods-1.html:207,Availability,avail,available,207,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods-1.html
https://psicode.org/psi4manual/4.0b2/methods-1.html:381,Availability,avail,available,381,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods-1.html
https://psicode.org/psi4manual/4.0b2/methods-1.html:317,Deployability,configurat,configuration,317,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods-1.html
https://psicode.org/psi4manual/4.0b2/methods-1.html:2129,Deployability,update,updated,2129,"tructure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods-1.html
https://psicode.org/psi4manual/4.0b2/methods-1.html:317,Modifiability,config,configuration,317,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods-1.html
https://psicode.org/psi4manual/4.0b2/methods.html:207,Availability,avail,available,207,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods.html
https://psicode.org/psi4manual/4.0b2/methods.html:381,Availability,avail,available,381,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods.html
https://psicode.org/psi4manual/4.0b2/methods.html:317,Deployability,configurat,configuration,317,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods.html
https://psicode.org/psi4manual/4.0b2/methods.html:2129,Deployability,update,updated,2129,"tructure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods.html
https://psicode.org/psi4manual/4.0b2/methods.html:317,Modifiability,config,configuration,317,"﻿. Theoretical Methods: SCF to FCI — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Theoretical Methods: SCF to FCI¶; Several electronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/4.0b2/methods.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:740,Availability,error,error,740,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1707,Availability,avail,available,1707,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:2162,Availability,avail,available,2162,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:2851,Deployability,update,updated,2851,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:900,Energy Efficiency,energy,energy,900,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1046,Energy Efficiency,energy,energy,1046,"4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1090,Energy Efficiency,energy,energy,1090,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1191,Energy Efficiency,energy,energy,1191,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1215,Energy Efficiency,energy,energy,1215,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1263,Energy Efficiency,energy,energy,1263,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:349,Integrability,interface,interface,349,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1730,Integrability,interface,interface,1730,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:2249,Integrability,interface,interface,2249,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1124,Performance,perform,perform,1124,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1293,Performance,perform,perform,1293,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1310,Performance,optimiz,optimization,1310,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:2264,Performance,optimiz,optimize,2264,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:2417,Performance,optimiz,optimize,2417,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:942,Usability,simpl,simply,942,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1223,Usability,simpl,simply,1223,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b2/mrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:740,Availability,error,error,740,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1707,Availability,avail,available,1707,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:2162,Availability,avail,available,2162,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:2851,Deployability,update,updated,2851,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:900,Energy Efficiency,energy,energy,900,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1046,Energy Efficiency,energy,energy,1046,"4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1090,Energy Efficiency,energy,energy,1090,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1191,Energy Efficiency,energy,energy,1191,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1215,Energy Efficiency,energy,energy,1215,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1263,Energy Efficiency,energy,energy,1263,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:349,Integrability,interface,interface,349,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1730,Integrability,interface,interface,1730,"the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:2249,Integrability,interface,interface,2249,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1124,Performance,perform,perform,1124,"Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1293,Performance,perform,perform,1293,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1310,Performance,optimiz,optimization,1310,"SI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:2264,Performance,optimiz,optimize,2264,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:2417,Performance,optimiz,optimize,2417,"or water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:942,Usability,simpl,simply,942,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/mrcc.html:1223,Usability,simpl,simply,1223,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4manual/4.0b2/mrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc.html
https://psicode.org/psi4manual/4.0b2/notes_c-1.html:831,Availability,toler,tolerance,831,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c-1.html
https://psicode.org/psi4manual/4.0b2/notes_c-1.html:1465,Deployability,update,updated,1465,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c-1.html
https://psicode.org/psi4manual/4.0b2/notes_c-1.html:389,Energy Efficiency,energy,energy,389,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c-1.html
https://psicode.org/psi4manual/4.0b2/notes_c-1.html:1053,Energy Efficiency,energy,energy,1053,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c-1.html
https://psicode.org/psi4manual/4.0b2/notes_c.html:831,Availability,toler,tolerance,831,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c.html
https://psicode.org/psi4manual/4.0b2/notes_c.html:1465,Deployability,update,updated,1465,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c.html
https://psicode.org/psi4manual/4.0b2/notes_c.html:389,Energy Efficiency,energy,energy,389,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c.html
https://psicode.org/psi4manual/4.0b2/notes_c.html:1053,Energy Efficiency,energy,energy,1053,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Notes on Options¶. Note; The options referred to in the Theoretical Methods: SCF to FCI section below; and indexed in Keywords by Module are placed in set blocks as; described in Job Control, not as arguments to a Python function; (like energy()). Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number of an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Previous topic; Theoretical Methods: SCF to FCI; Next topic; Hartree–Fock Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_c.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_c.html
https://psicode.org/psi4manual/4.0b2/notes_py-1.html:1870,Deployability,update,updated,1870,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py-1.html
https://psicode.org/psi4manual/4.0b2/notes_py-1.html:334,Energy Efficiency,energy,energy,334,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py-1.html
https://psicode.org/psi4manual/4.0b2/notes_py-1.html:870,Energy Efficiency,energy,energy,870,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py-1.html
https://psicode.org/psi4manual/4.0b2/notes_py-1.html:1100,Energy Efficiency,energy,energy,1100,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py-1.html
https://psicode.org/psi4manual/4.0b2/notes_py-1.html:1235,Integrability,wrap,wrapped,1235,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py-1.html
https://psicode.org/psi4manual/4.0b2/notes_py-1.html:1511,Integrability,wrap,wrapped,1511,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py-1.html
https://psicode.org/psi4manual/4.0b2/notes_py-1.html:813,Performance,optimiz,optimize,813,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py-1.html
https://psicode.org/psi4manual/4.0b2/notes_py.html:1870,Deployability,update,updated,1870,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py.html
https://psicode.org/psi4manual/4.0b2/notes_py.html:334,Energy Efficiency,energy,energy,334,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py.html
https://psicode.org/psi4manual/4.0b2/notes_py.html:870,Energy Efficiency,energy,energy,870,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py.html
https://psicode.org/psi4manual/4.0b2/notes_py.html:1100,Energy Efficiency,energy,energy,1100,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py.html
https://psicode.org/psi4manual/4.0b2/notes_py.html:1235,Integrability,wrap,wrapped,1235,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py.html
https://psicode.org/psi4manual/4.0b2/notes_py.html:1511,Integrability,wrap,wrapped,1511,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py.html
https://psicode.org/psi4manual/4.0b2/notes_py.html:813,Performance,optimiz,optimize,813,"﻿. Notes on Options — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The few exceptions are documented for the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; nearest preceeding molecule declared in a molecule name {...} block. Note; that the value of this keyword (name in the example) is a Python object and; so is not wrapped in quotes like a string. Previous topic; Psithon Functions: Invoking a Calculation; Next topic; Energy; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/notes_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/notes_py.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:422,Availability,avail,available,422,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1892,Availability,avail,available,1892,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1448,Deployability,continuous,continuous,1448,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1633,Deployability,continuous,continuous,1633,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:2657,Deployability,update,updated,2657,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:317,Energy Efficiency,energy,energy,317,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:509,Energy Efficiency,energy,energy,509,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1068,Energy Efficiency,energy,energy,1068,"next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Ana",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1108,Energy Efficiency,energy,energy,1108,"ing a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1238,Energy Efficiency,energy,energy,1238,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1852,Energy Efficiency,energy,energy,1852,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:364,Modifiability,variab,variables,364,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:165,Performance,optimiz,optimize,165,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:235,Performance,perform,perform,235,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:254,Performance,optimiz,optimization,254,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:327,Performance,optimiz,optimized,327,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1163,Performance,perform,performed,1163,"ing a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1260,Performance,perform,performs,1260,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1516,Performance,optimiz,optimization,1516,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1592,Performance,optimiz,optimization,1592,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1925,Performance,optimiz,optimization,1925,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1947,Performance,perform,performed,1947,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:2083,Performance,optimiz,optimization,2083,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:2101,Performance,optimiz,optimize,2101,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:2150,Performance,optimiz,optimization,2150,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:2220,Performance,optimiz,optimization,2220,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:2238,Performance,optimiz,optimize,2238,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:2302,Performance,optimiz,optimization,2302,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt-1.html:1211,Security,access,accesses,1211,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b2/opt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html
https://psicode.org/psi4manual/4.0b2/opt.html:422,Availability,avail,available,422,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1892,Availability,avail,available,1892,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1448,Deployability,continuous,continuous,1448,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1633,Deployability,continuous,continuous,1633,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:2657,Deployability,update,updated,2657,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:317,Energy Efficiency,energy,energy,317,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:509,Energy Efficiency,energy,energy,509,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1068,Energy Efficiency,energy,energy,1068,"next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Ana",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1108,Energy Efficiency,energy,energy,1108,"ing a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1238,Energy Efficiency,energy,energy,1238,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1852,Energy Efficiency,energy,energy,1852,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:364,Modifiability,variab,variables,364,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:165,Performance,optimiz,optimize,165,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:235,Performance,perform,perform,235,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:254,Performance,optimiz,optimization,254,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:327,Performance,optimiz,optimized,327,"﻿. Optimize — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The targ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1163,Performance,perform,performed,1163,"ing a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1260,Performance,perform,performs,1260,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1516,Performance,optimiz,optimization,1516,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1592,Performance,optimiz,optimization,1592,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1925,Performance,optimiz,optimization,1925,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1947,Performance,perform,performed,1947,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:2083,Performance,optimiz,optimization,2083,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:2101,Performance,optimiz,optimize,2101,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:2150,Performance,optimiz,optimization,2150,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:2220,Performance,optimiz,optimization,2220,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:2238,Performance,optimiz,optimize,2238,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:2302,Performance,optimiz,optimization,2302,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/opt.html:1211,Security,access,accesses,1211,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4manual/4.0b2/opt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:579,Availability,redundant,redundant,579,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:717,Availability,redundant,redundant,717,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:1028,Availability,redundant,redundant,1028,"ation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of t",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4633,Availability,avail,available,4633,"nternal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4807,Availability,avail,available,4807,"1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:5052,Availability,avail,available,5052," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:7678,Availability,avail,available,7678,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:644,Deployability,update,update,644,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:5033,Deployability,update,update,5033," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:10798,Deployability,update,updated,10798,"d this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Configuration Interaction; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4145,Energy Efficiency,energy,energy,4145,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4207,Energy Efficiency,energy,energy,4207,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:6954,Energy Efficiency,monitor,monitors,6954,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:7079,Energy Efficiency,energy,energy,7079,"lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Ma",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:8566,Energy Efficiency,monitor,monitored,8566,"dance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; -------------",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:8970,Energy Efficiency,monitor,monitored,8970,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:329,Performance,optimiz,optimizations,329,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:2710,Performance,optimiz,optimization,2710," named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Opt",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:2891,Performance,optimiz,optimization,2891," of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:2962,Performance,optimiz,optimization,2962,"; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:3421,Performance,optimiz,optimization,3421,"points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; int",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4019,Performance,optimiz,optimize,4019,"of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4113,Performance,optimiz,optimize,4113,"the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4182,Performance,optimiz,optimize,4182,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4305,Performance,optimiz,optimize,4305,"efault: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a star",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4475,Performance,optimiz,optimize,4475,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4570,Performance,optimiz,optimize,4570,"N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:5180,Performance,optimiz,optimization,5180,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fra",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:5329,Performance,optimiz,optimize,5329,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragme",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:5587,Performance,optimiz,optimize,5587,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:5916,Performance,optimiz,optimize,5916,"Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:6014,Performance,optimiz,optimize,6014,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:6364,Performance,optimiz,optimizations,6364," the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:6725,Performance,optimiz,optimize,6725,"2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:7019,Performance,optimiz,optimization,7019,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:7656,Performance,optimiz,optimization,7656,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:8950,Performance,optimiz,optimization,8950,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:10150,Performance,optimiz,optimizations,10150,"d this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Configuration Interaction; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:10180,Performance,optimiz,optimize,10180,"d this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Configuration Interaction; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:579,Safety,redund,redundant,579,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:717,Safety,redund,redundant,717,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:1028,Safety,redund,redundant,1028,"ation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of t",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:8851,Safety,avoid,avoid,8851,"MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:888,Testability,test,tested,888,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:1290,Testability,test,testing,1290," optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defin",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking-1.html:4934,Usability,simpl,simple,4934,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coord",MatchSource.WIKI,psi4manual/4.0b2/optking-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html
https://psicode.org/psi4manual/4.0b2/optking.html:579,Availability,redundant,redundant,579,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:717,Availability,redundant,redundant,717,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:1028,Availability,redundant,redundant,1028,"ation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of t",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4633,Availability,avail,available,4633,"nternal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4807,Availability,avail,available,4807,"1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:5052,Availability,avail,available,5052," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:7678,Availability,avail,available,7678,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:644,Deployability,update,update,644,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:5033,Deployability,update,update,5033," Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:10798,Deployability,update,updated,10798,"d this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Configuration Interaction; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4145,Energy Efficiency,energy,energy,4145,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4207,Energy Efficiency,energy,energy,4207,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:6954,Energy Efficiency,monitor,monitors,6954,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:7079,Energy Efficiency,energy,energy,7079,"lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Ma",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:8566,Energy Efficiency,monitor,monitored,8566,"dance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; -------------",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:8970,Energy Efficiency,monitor,monitored,8970,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:329,Performance,optimiz,optimizations,329,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:2710,Performance,optimiz,optimization,2710," named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Opt",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:2891,Performance,optimiz,optimization,2891," of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:2962,Performance,optimiz,optimization,2962,"; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:3421,Performance,optimiz,optimization,3421,"points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; int",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4019,Performance,optimiz,optimize,4019,"of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4113,Performance,optimiz,optimize,4113,"the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4182,Performance,optimiz,optimize,4182,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4305,Performance,optimiz,optimize,4305,"efault: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a star",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4475,Performance,optimiz,optimize,4475,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4570,Performance,optimiz,optimize,4570,"N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:5180,Performance,optimiz,optimization,5180,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fra",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:5329,Performance,optimiz,optimize,5329,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragme",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:5587,Performance,optimiz,optimize,5587,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:5916,Performance,optimiz,optimize,5916,"Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:6014,Performance,optimiz,optimize,6014,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:6364,Performance,optimiz,optimizations,6364," the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:6725,Performance,optimiz,optimize,6725,"2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:7019,Performance,optimiz,optimization,7019,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:7656,Performance,optimiz,optimization,7656,"d by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_C",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:8950,Performance,optimiz,optimization,8950,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:10150,Performance,optimiz,optimizations,10150,"d this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Configuration Interaction; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:10180,Performance,optimiz,optimize,10180,"d this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Configuration Interaction; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:579,Safety,redund,redundant,579,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:717,Safety,redund,redundant,717,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:1028,Safety,redund,redundant,1028,"ation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of t",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:8851,Safety,avoid,avoid,8851,"MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:888,Testability,test,tested,888,"﻿. Geometry Optimization — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Geometry Optimization¶; Code author: Rollin A. King; Section author: Rollin A. King and Lori A. Burns; Module: Keywords, PSI Variables, OPTKING; PSI4 carries out molecular optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:1290,Testability,test,testing,1290," optimizations using a module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives — both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, a RFO step, and the BFGS Hessian update.; The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49].; The general approach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defin",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/optking.html:4934,Usability,simpl,simple,4934,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coord",MatchSource.WIKI,psi4manual/4.0b2/optking.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3181,Availability,avail,available,3181,"gure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directo",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6750,Availability,avail,available,6750," or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Cont",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:8242,Deployability,update,updated,8242,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5334,Energy Efficiency,energy,energy,5334,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5375,Energy Efficiency,energy,energy,5375,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6694,Energy Efficiency,energy,energy,6694," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:1144,Integrability,wrap,wrapped,1144,"s: Adding New Functionality to PSI4¶. Modular Approach to Development¶; The redesign of PSI4 into a single-executable changed the way that; code development is done. The standalone nature of modules in previous; versions of Psi made their development very easy, as new functionality; could be implemented almost as a standalone executable, which could easily; be ported into the Psi code when completed. The new design specifies that; these modules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5763,Integrability,depend,depends,5763,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:1842,Modifiability,plugin,plugin,1842," be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2021,Modifiability,plugin,plugins,2021,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2093,Modifiability,plugin,plugins,2093,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2155,Modifiability,plugin,plugins,2155,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2178,Modifiability,config,configure,2178,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2218,Modifiability,plugin,plugins,2218,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2284,Modifiability,plugin,plugins,2284,"to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active de",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2382,Modifiability,plugin,plugin,2382," it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.c",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2543,Modifiability,plugin,plugin,2543,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backt",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2628,Modifiability,plugin,plugin,2628,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-parti",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2970,Modifiability,plugin,plugin,2970,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3015,Modifiability,plugin,plugin,3015,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3060,Modifiability,plugin,plugin,3060,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3105,Modifiability,plugin,plugin,3105,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3158,Modifiability,plugin,plugin,3158,"gure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directo",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3238,Modifiability,plugin,plugin,3238," create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you a",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3332,Modifiability,plugin,plugin,3332,"ompilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After a",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3864,Modifiability,plugin,plugin,3864,"e; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./mypl",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4169,Modifiability,plugin,plugin,4169,"ailable to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4296,Modifiability,plugin,plugin,4296,"tive development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hoo",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4359,Modifiability,plugin,plugin,4359,"n_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4400,Modifiability,plugin,plugin,4400,"n_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4560,Modifiability,config,configure,4560,"rans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4587,Modifiability,plugin,plugins,4587,"rans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4636,Modifiability,plugin,plugin,4636,"ation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless a",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4714,Modifiability,plugin,plugin,4714,"n_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4808,Modifiability,plugin,plugin,4808,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4884,Modifiability,plugin,plugin,4884,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4920,Modifiability,plugin,plugin,4920,"plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plu",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5038,Modifiability,plugin,plugin,5038,"ary to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5073,Modifiability,plugin,plugin,5073,"etry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5224,Modifiability,plugin,plugin,5224,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5281,Modifiability,plugin,plugin,5281,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5507,Modifiability,plugin,plugin,5507,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5544,Modifiability,plugin,plugin,5544,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5670,Modifiability,plugin,plugin,5670,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5756,Modifiability,plugin,plugin,5756,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5793,Modifiability,plugin,plugin,5793,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5871,Modifiability,plugin,plugin,5871,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5907,Modifiability,plugin,plugin,5907,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6113,Modifiability,plugin,plugin,6113,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6331,Modifiability,plugin,plugin,6331,"function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building document",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6389,Modifiability,plugin,plugin,6389," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6438,Modifiability,plugin,plugin,6438," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6507,Modifiability,plugin,plugin,6507,"ctory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading port",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6637,Modifiability,plugin,plugin,6637," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:7415,Modifiability,plugin,plugin,7415,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:7436,Modifiability,plugin,plugin,7436,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:7698,Modifiability,plugin,plugin,7698,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2036,Performance,load,loaded,2036,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:2207,Performance,load,loading,2207,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:4799,Performance,load,load,4799,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6651,Performance,load,loaded,6651," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:7543,Performance,load,loading,7543,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:7686,Performance,load,loading,7686,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5357,Security,access,accessed,5357,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3215,Testability,test,tests,3215,"gure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directo",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3377,Testability,test,tests,3377,"n the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3525,Testability,test,tests,3525,"-new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originall",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3567,Testability,test,test,3567,"e name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). inp",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3647,Testability,test,tests,3647,"tory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modi",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3693,Testability,test,tests,3693,"eed to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to r",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3827,Testability,test,tests,3827,"e include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s o",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:3945,Testability,test,tests,3945,"si4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary prepara",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5942,Testability,test,tests,5942,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:6796,Testability,test,testfunction,6796,"dditional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to De",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:1549,Usability,learn,learn,1549,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In ",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5116,Usability,simpl,simple,5116,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins-1.html:5144,Usability,simpl,simpler,5144,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b2/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3181,Availability,avail,available,3181,"gure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directo",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6750,Availability,avail,available,6750," or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Cont",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:8242,Deployability,update,updated,8242,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5334,Energy Efficiency,energy,energy,5334,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5375,Energy Efficiency,energy,energy,5375,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6694,Energy Efficiency,energy,energy,6694," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:1144,Integrability,wrap,wrapped,1144,"s: Adding New Functionality to PSI4¶. Modular Approach to Development¶; The redesign of PSI4 into a single-executable changed the way that; code development is done. The standalone nature of modules in previous; versions of Psi made their development very easy, as new functionality; could be implemented almost as a standalone executable, which could easily; be ported into the Psi code when completed. The new design specifies that; these modules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5763,Integrability,depend,depends,5763,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:1842,Modifiability,plugin,plugin,1842," be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2021,Modifiability,plugin,plugins,2021,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2093,Modifiability,plugin,plugins,2093,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2155,Modifiability,plugin,plugins,2155,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2178,Modifiability,config,configure,2178,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2218,Modifiability,plugin,plugins,2218,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2284,Modifiability,plugin,plugins,2284,"to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active de",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2382,Modifiability,plugin,plugin,2382," it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.c",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2543,Modifiability,plugin,plugin,2543,"ed to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backt",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2628,Modifiability,plugin,plugin,2628,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-parti",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2970,Modifiability,plugin,plugin,2970,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3015,Modifiability,plugin,plugin,3015,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3060,Modifiability,plugin,plugin,3060,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3105,Modifiability,plugin,plugin,3105,". The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the L",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3158,Modifiability,plugin,plugin,3158,"gure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directo",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3238,Modifiability,plugin,plugin,3238," create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you a",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3332,Modifiability,plugin,plugin,3332,"ompilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After a",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3864,Modifiability,plugin,plugin,3864,"e; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./mypl",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4169,Modifiability,plugin,plugin,4169,"ailable to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4296,Modifiability,plugin,plugin,4296,"tive development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hoo",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4359,Modifiability,plugin,plugin,4359,"n_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4400,Modifiability,plugin,plugin,4400,"n_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4560,Modifiability,config,configure,4560,"rans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4587,Modifiability,plugin,plugins,4587,"rans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4636,Modifiability,plugin,plugin,4636,"ation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless a",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4714,Modifiability,plugin,plugin,4714,"n_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4808,Modifiability,plugin,plugin,4808,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4884,Modifiability,plugin,plugin,4884,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4920,Modifiability,plugin,plugin,4920,"plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plu",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5038,Modifiability,plugin,plugin,5038,"ary to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5073,Modifiability,plugin,plugin,5073,"etry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modu",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5224,Modifiability,plugin,plugin,5224,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5281,Modifiability,plugin,plugin,5281,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5507,Modifiability,plugin,plugin,5507,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5544,Modifiability,plugin,plugin,5544,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5670,Modifiability,plugin,plugin,5670,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5756,Modifiability,plugin,plugin,5756,"andard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin a",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5793,Modifiability,plugin,plugin,5793,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5871,Modifiability,plugin,plugin,5871,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5907,Modifiability,plugin,plugin,5907,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6113,Modifiability,plugin,plugin,6113,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6331,Modifiability,plugin,plugin,6331,"function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building document",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6389,Modifiability,plugin,plugin,6389," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6438,Modifiability,plugin,plugin,6438," functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, creat",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6507,Modifiability,plugin,plugin,6507,"ctory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading port",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6637,Modifiability,plugin,plugin,6637," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:7415,Modifiability,plugin,plugin,7415,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:7436,Modifiability,plugin,plugin,7436,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:7698,Modifiability,plugin,plugin,7698,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2036,Performance,load,loaded,2036,"ality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:2207,Performance,load,loading,2207,"a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sampl",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:4799,Performance,load,load,4799,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6651,Performance,load,loaded,6651," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:7543,Performance,load,loading,7543,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:7686,Performance,load,loading,7686,"dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5357,Security,access,accessed,5357,"user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3215,Testability,test,tests,3215,"gure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directo",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3377,Testability,test,tests,3377,"n the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3525,Testability,test,tests,3525,"-new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originall",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3567,Testability,test,test,3567,"e name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). inp",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3647,Testability,test,tests,3647,"tory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modi",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3693,Testability,test,tests,3693,"eed to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to r",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3827,Testability,test,tests,3827,"e include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s o",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:3945,Testability,test,tests,3945,"si4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary prepara",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5942,Testability,test,tests,5942,"final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file.",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:6796,Testability,test,testfunction,6796,"dditional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to De",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:1549,Usability,learn,learn,1549,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In ",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5116,Usability,simpl,simple,5116,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/plugins.html:5144,Usability,simpl,simpler,5144,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4manual/4.0b2/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins.html
https://psicode.org/psi4manual/4.0b2/programming-1.html:477,Deployability,update,updated,477,"﻿. Programming: Using the Core Libraries — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Programming: Using the Core Libraries¶. Previous topic; Documentation; Next topic; Emerging Theoretical Methods: Plugins DFADC to RQCHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/programming-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/programming-1.html
https://psicode.org/psi4manual/4.0b2/programming.html:477,Deployability,update,updated,477,"﻿. Programming: Using the Core Libraries — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Programming: Using the Core Libraries¶. Previous topic; Documentation; Next topic; Emerging Theoretical Methods: Plugins DFADC to RQCHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/programming.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/programming.html
https://psicode.org/psi4manual/4.0b2/prop-1.html:1700,Deployability,update,updated,1700,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop-1.html
https://psicode.org/psi4manual/4.0b2/prop-1.html:304,Energy Efficiency,energy,energy,304,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop-1.html
https://psicode.org/psi4manual/4.0b2/prop-1.html:567,Energy Efficiency,energy,energy,567,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop-1.html
https://psicode.org/psi4manual/4.0b2/prop-1.html:621,Modifiability,variab,variables,621,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop-1.html
https://psicode.org/psi4manual/4.0b2/prop.html:1700,Deployability,update,updated,1700,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop.html
https://psicode.org/psi4manual/4.0b2/prop.html:304,Energy Efficiency,energy,energy,304,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop.html
https://psicode.org/psi4manual/4.0b2/prop.html:567,Energy Efficiency,energy,energy,567,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop.html
https://psicode.org/psi4manual/4.0b2/prop.html:621,Modifiability,variab,variables,621,"﻿. Property — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Property¶. property(name[, properties, molecule])[source]¶; Function to compute various properties. Aliases :prop(). Returns:(float) Total electronic energy in Hartrees. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities.; Check that energy is actually being returned.; Check if some PSI variables ought to be set. name; calls method. scf; Self-consistent field method(s). cc2; 2nd-order approximate CCSD. ccsd; coupled cluster singles and doubles (CCSD). eom-cc2; 2nd-order approximate EOM-CCSD. eom-ccsd; equation-of-motion coupled cluster singles and doubles (EOM-CCSD). Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – [] || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). Previous topic; Energy; Next topic; Counterpoise Correct; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/prop.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:98651,Deployability,update,updated,98651,"Molecule)arg1) -> None :; docstring; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; docstring; ; set_global_option( (str)arg1, (float)arg2) -> bool :; docstring; ; set_global_option( (str)arg1, (int)arg2) -> bool :; docstring; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; docstring; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; docstring; ; set_local_option(...); set_local_option( (str)arg1, (str)arg2, (str)arg3) -> bool :; docstring; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; docstring; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; docstring; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; docstring; ; set_memory(...); set_memory( (int)arg1) -> None :; docstring; ; set_nthread(...); set_nthread( (int)arg1) -> None :; docstring; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; docstring; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; docstring; ; stability(...); stability() -> int :; docstring; ; transqt(...); transqt() -> float :; docstring; ; transqt2(...); transqt2() -> float :; docstring; ; version(...); version() -> str :; docstring. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:28678,Energy Efficiency,energy,energy,28678,"hods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ---",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:28693,Energy Efficiency,energy,energy,28693," | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inher",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:37792,Energy Efficiency,power,power,37792,"-> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (floa",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:37806,Energy Efficiency,power,power,37806,"ocstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | set(...); | set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) ->",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:46815,Energy Efficiency,charge,charge,46815,"ython.instance); | docstring; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | docstring; | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | docstring; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | docstring; | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | docstring; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2) -> Molecule :; | docstring; | ; | find_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | docstring; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:46830,Energy Efficiency,charge,charge,46830,"t.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | docstring; | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | docstring; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | docstring; | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | docstring; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2) -> Molecule :; | docstring; | ; | find_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | docstring; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | docstring; | ; | form_symmetry_information(...); | form_symme",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:68111,Energy Efficiency,energy,energy,68111,"hods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ---",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:68126,Energy Efficiency,energy,energy,68126," | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inher",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:70824,Energy Efficiency,allocate,allocate,70824,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_gga(...); | is_gga( (SuperFunctional)arg1) -",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:70841,Energy Efficiency,allocate,allocate,70841,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_gga(...); | is_gga( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (SuperFunctional)arg1) -> bool :; | do",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:83267,Energy Efficiency,energy,energy,83267,"Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:83282,Energy Efficiency,energy,energy,83282,"docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:1478,Modifiability,inherit,inherited,1478,"rguments; BasisSet; BasisSetParser; Gaussian94BasisSetParser; CdSalcList; Checkpoint; DFChargeFitter; Dimension; Dispersion; Environment; ExternalPotential; FittingMetric; Functional; GridProp; IO; IOManager; IntVector; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimit",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:1658,Modifiability,inherit,inherited,1658,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:3275,Modifiability,inherit,inherited,3275,"reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:3455,Modifiability,inherit,inherited,3455,"t :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:4211,Modifiability,inherit,inherited,4211," here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attri",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:4391,Modifiability,inherit,inherited,4391,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:5289,Modifiability,inherit,inherited,5289,"rom Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:5469,Modifiability,inherit,inherited,5469,"om Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:6778,Modifiability,inherit,inherited,6778,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...)",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:6958,Modifiability,inherit,inherited,6958,"> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | -----------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:8106,Modifiability,inherit,inherited,8106,"utes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:8286,Modifiability,inherit,inherited,8286,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | --------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:9039,Modifiability,inherit,inherited,9039," 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:9268,Modifiability,inherit,inherited,9268,"--------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:9403,Modifiability,inherit,inherited,9403,"__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:12082,Modifiability,inherit,inherited,12082,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)ar",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:12470,Modifiability,inherit,inherited,12470," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstrin",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:13763,Modifiability,inherit,inherited,13763,"ype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:13943,Modifiability,inherit,inherited,13943,"; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; | ; | compute_hessian(...); | compute_hessian( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; | ; | description(...); | description( (Dispersion)arg1) -> str :; | docstring; | ; | name(...); | name( (Dispersion)arg1) -> str ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:16079,Modifiability,inherit,inherited,16079,"ring; | ; | print_energy(...); | print_energy( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_gradient(...); | print_gradient( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_hessian(...); | print_hessian( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_out(...); | print_out( (Dispersion)arg1) -> None :; | docstring; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:16259,Modifiability,inherit,inherited,16259," | ; | print_out(...); | print_out( (Dispersion)arg1) -> None :; | docstring; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:17052,Modifiability,inherit,inherited,17052,"his class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:17232,Modifiability,inherit,inherited,17232,"---------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:18588,Modifiability,inherit,inherited,18588,"st.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; |",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:18768,Modifiability,inherit,inherited,18768,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:20528,Modifiability,inherit,inherited,20528,"orm_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:20708,Modifiability,inherit,inherited,20708,"; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)arg1) -> bool :; | docstring; | ; | is_lrc(...); | is_lrc( (Functional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (Functional)arg1) -> bool :; | docstring; | ; | lsda_cutoff(...); | lsda_cutoff( (Functional)arg1) -> float :; | docstring; | ;",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:23504,Modifiability,inherit,inherited,23504," | ; | set_gga(...); | set_gga( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_lsda_cutoff(...); | set_lsda_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_meta(...); | set_meta( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_meta_cutoff(...); | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:23684,Modifiability,inherit,inherited,23684,"; | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes i",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:24438,Modifiability,inherit,inherited,24438," __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)a",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:24618,Modifiability,inherit,inherited,24618,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_beta_mo(...); | add_beta_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | build_grid_overages(...); | build_grid_overages( (GridProp)arg1, (float)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:26719,Modifiability,inherit,inherited,26719," docstring; | ; | compute(...); | compute( (GridProp)arg1) -> None :; | docstring; | ; | get_l(...); | get_l( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | get_n(...); | get_n( (GridProp)arg1, (int)arg2) -> int :; | docstring; | ; | get_o(...); | get_o( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:26899,Modifiability,inherit,inherited,26899,"op)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:27629,Modifiability,inherit,inherited,27629,"----------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:29541,Modifiability,inherit,inherited,29541,"..); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:29721,Modifiability,inherit,inherited,29721," :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(.",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:31498,Modifiability,inherit,inherited,31498,"k( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:31678,Modifiability,inherit,inherited,31678,"g3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (int)arg2) -> str :; | docstring; | ; | mark_file_for_retention(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:33568,Modifiability,inherit,inherited,33568,"tion(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | psiclean(...); | psiclean( (IOManager)arg1) -> None :; | docstring; | ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | ni",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:33748,Modifiability,inherit,inherited,33748," ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:34912,Modifiability,inherit,inherited,34912,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:35092,Modifiability,inherit,inherited,35092,"Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Matrix)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | accumulate_product(...); | accumulate_product( (Matrix)arg1, (Matrix)arg2, (Matri",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:40220,Modifiability,inherit,inherited,40220,")arg2) -> None :; | docstring; | ; | subtract(...); | subtract( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | sum_of_squares(...); | sum_of_squares( (Matrix)arg1) -> float :; | docstring; | ; | symmetry(...); | symmetry( (Matrix)arg1) -> int :; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | -------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:40400,Modifiability,inherit,inherited,40400,"; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:41477,Modifiability,inherit,inherited,41477,"----------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:41657,Modifiability,inherit,inherited,41657,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_kinetic(...); | ao_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_nabla(...); | ao_nabla( (MintsHelper)arg1) -",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:44554,Modifiability,inherit,inherited,44554,"ring; | ; | play(...); | play( (MintsHelper)arg1) -> None :; | docstring; | ; | so_angular_momentum(...); | so_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_dipole(...); | so_dipole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inhe",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:44734,Modifiability,inherit,inherited,44734,"tring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:45404,Modifiability,inherit,inherited,45404,"--------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:45584,Modifiability,inherit,inherited,45584,"---------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:52564,Modifiability,inherit,inherited,52564,"1, (PointGroup)arg2) -> None :; | docstring; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | docstring; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | docstring; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | -----",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:52744,Modifiability,inherit,inherited,52744,"(Molecule)arg1, (Vector3)arg2) -> None :; | docstring; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:53500,Modifiability,inherit,inherited,53500,"butes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:53680,Modifiability,inherit,inherited,53680,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:54341,Modifiability,inherit,inherited,54341,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:54521,Modifiability,inherit,inherited,54521,"------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inh",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:55453,Modifiability,inherit,inherited,55453,"-------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __in",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:55633,Modifiability,inherit,inherited,55633,"_new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Wavefunction)arg4) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimens",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:57486,Modifiability,inherit,inherited,57486,"nnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and othe",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:57666,Modifiability,inherit,inherited,57666,"...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:58643,Modifiability,inherit,inherited,58643,"---------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | -----------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:58823,Modifiability,inherit,inherited,58823,"thon.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:59658,Modifiability,inherit,inherited,59658,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:59838,Modifiability,inherit,inherited,59838,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:60661,Modifiability,inherit,inherited,60661,"------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (P",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:60841,Modifiability,inherit,inherited,60841,"---------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes define",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:61912,Modifiability,inherit,inherited,61912,"-----------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiRe",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:62092,Modifiability,inherit,inherited,62092,"seudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__()",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:62909,Modifiability,inherit,inherited,62909,"-----------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:63138,Modifiability,inherit,inherited,63138,"tes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:63273,Modifiability,inherit,inherited,63273,"bject with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:65952,Modifiability,inherit,inherited,65952,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ex",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:66340,Modifiability,inherit,inherited,66340," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...);",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:67062,Modifiability,inherit,inherited,67062,"---------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:68974,Modifiability,inherit,inherited,68974,"..); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -----",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:69154,Modifiability,inherit,inherited,69154," :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:69989,Modifiability,inherit,inherited,69989,"basisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> N",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:70169,Modifiability,inherit,inherited,70169,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunct",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:74528,Modifiability,inherit,inherited,74528,"ctional)arg1, (float)arg2) -> None :; | docstring; | ; | test_functional(...); | test_functional( (SuperFunctional)arg1, (Vector)arg2, (Vector)arg3, (Vector)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | value(...); | value( (SuperFunctional)arg1, (str)arg2) -> Vector :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:74708,Modifiability,inherit,inherited,74708,"r :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | c2_x( (SymmetryOperation)arg1) -> None :; | docstring; | ; | c2_y(...); | c2_y( (SymmetryOperation)arg1) -> None :; | docstring; | ; | i(...); | i( (SymmetryOperation)arg1) -> None :; | docstring; | ; | operate(...); | operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; |",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:76776,Modifiability,inherit,inherited,76776,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:76956,Modifiability,inherit,inherited,76956,"tryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(.",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:78659,Modifiability,inherit,inherited,78659," __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | docstring; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1,",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:78839,Modifiability,inherit,inherited,78839,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | docstring; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (float)arg4) -> None; | ; | __init__( (object)arg1, (Vector3)arg2) -> None; | ; | __isub__(...); | __isub__( (object)",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:80698,Modifiability,inherit,inherited,80698,"init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (float)arg4) -> None; | ; | __init__( (object)arg1, (Vector3)arg2) -> None; | ; | __isub__(...); | __isub__( (object)arg1, (Vector3)arg2) -> object; | ; | __neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | docstring; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | docstring; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | docstring; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); |",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:80878,Modifiability,inherit,inherited,80878,"__neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | docstring; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | docstring; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | docstring; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data a",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:81653,Modifiability,inherit,inherited,81653,"----------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <u",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:81833,Modifiability,inherit,inherited,81833,"f__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | do",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:84370,Modifiability,inherit,inherited,84370,"avefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | ",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:84550,Modifiability,inherit,inherited,84550,"| docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; |",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:85563,Modifiability,extend,extend,85563,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vecto",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:85578,Modifiability,extend,extend,85578,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:85878,Modifiability,inherit,inherited,85878,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:86058,Modifiability,inherit,inherited,86058,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -> None :; docstring; ; DGEEV(...); DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:95308,Modifiability,plugin,plugin,95308,"ed(...); has_global_option_changed( (str)arg1) -> bool :; docstring; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; docstring; ; has_option_changed(...); has_option_changed( (str)arg1) -> bool :; docstring; ; libfock(...); libfock() -> int :; docstring; ; mcscf(...); mcscf() -> float :; docstring; ; me(...); me() -> int :; docstring; ; mints(...); mints() -> int :; docstring; ; mp2(...); mp2() -> float :; docstring; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; docstring; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; docstring; ; nproc(...); nproc() -> int :; docstring; ; nthread(...); nthread() -> int :; docstring; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> int :; docstring; ; opt_clean(...); opt_clean() -> None :; docstring; ; optking(...); optking() -> int :; docstring; ; outfile_name(...); outfile_name() -> str :; docstring; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; docstring; ; print_global_options(...); print_global_options() -> None :; docstring; ; print_options(...); print_options() -> None :; docstring; ; print_out(...); print_out( (str)arg1) -> None :; docstring; ; print_variables(...); print_variables() -> None :; docstring; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; docstring; ; psimrcc(...); psimrcc() -> float :; docstring; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; docstring; ; reopen_outfile(...); reopen_outfile() -> None :; docstring; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; docstring; ; revoke_local_opt",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:95321,Modifiability,plugin,plugin,95321,"; docstring; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; docstring; ; has_option_changed(...); has_option_changed( (str)arg1) -> bool :; docstring; ; libfock(...); libfock() -> int :; docstring; ; mcscf(...); mcscf() -> float :; docstring; ; me(...); me() -> int :; docstring; ; mints(...); mints() -> int :; docstring; ; mp2(...); mp2() -> float :; docstring; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; docstring; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; docstring; ; nproc(...); nproc() -> int :; docstring; ; nthread(...); nthread() -> int :; docstring; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> int :; docstring; ; opt_clean(...); opt_clean() -> None :; docstring; ; optking(...); optking() -> int :; docstring; ; outfile_name(...); outfile_name() -> str :; docstring; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; docstring; ; print_global_options(...); print_global_options() -> None :; docstring; ; print_options(...); print_options() -> None :; docstring; ; print_out(...); print_out( (str)arg1) -> None :; docstring; ; print_variables(...); print_variables() -> None :; docstring; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; docstring; ; psimrcc(...); psimrcc() -> float :; docstring; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; docstring; ; reopen_outfile(...); reopen_outfile() -> None :; docstring; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; docstring; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:37372,Performance,load,load,37372,"Matrix)arg3]) -> Matrix; | ; | cholesky_factorize(...); | cholesky_factorize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> i",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:37385,Performance,load,load,37385,"rize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bo",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:10059,Security,hash,hash,10059,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:63929,Security,hash,hash,63929,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:17967,Usability,clear,clear,17967,"defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new o",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod-1.html:17981,Usability,clear,clear,17981,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolu",MatchSource.WIKI,psi4manual/4.0b2/psimod-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html
https://psicode.org/psi4manual/4.0b2/psimod.html:98651,Deployability,update,updated,98651,"Molecule)arg1) -> None :; docstring; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; docstring; ; set_global_option( (str)arg1, (float)arg2) -> bool :; docstring; ; set_global_option( (str)arg1, (int)arg2) -> bool :; docstring; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; docstring; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; docstring; ; set_local_option(...); set_local_option( (str)arg1, (str)arg2, (str)arg3) -> bool :; docstring; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; docstring; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; docstring; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; docstring; ; set_memory(...); set_memory( (int)arg1) -> None :; docstring; ; set_nthread(...); set_nthread( (int)arg1) -> None :; docstring; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; docstring; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; docstring; ; stability(...); stability() -> int :; docstring; ; transqt(...); transqt() -> float :; docstring; ; transqt2(...); transqt2() -> float :; docstring; ; version(...); version() -> str :; docstring. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:28678,Energy Efficiency,energy,energy,28678,"hods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ---",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:28693,Energy Efficiency,energy,energy,28693," | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inher",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:37792,Energy Efficiency,power,power,37792,"-> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (floa",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:37806,Energy Efficiency,power,power,37806,"ocstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bool)arg3, (bool)arg4, (bool)arg5) -> None :; | docstring; | ; | scale(...); | scale( (Matrix)arg1, (float)arg2) -> None :; | docstring; | ; | scale_column(...); | scale_column( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | scale_row(...); | scale_row( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | set(...); | set( (Matrix)arg1, (int)arg2, (int)arg3, (float)arg4) ->",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:46815,Energy Efficiency,charge,charge,46815,"ython.instance); | docstring; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | docstring; | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | docstring; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | docstring; | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | docstring; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2) -> Molecule :; | docstring; | ; | find_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | docstring; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:46830,Energy Efficiency,charge,charge,46830,"t.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :; | docstring; | ; | atom_at_position(...); | atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :; | docstring; | ; | center_of_mass(...); | center_of_mass( (Molecule)arg1) -> Vector3 :; | docstring; | ; | charge(...); | charge( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | clone(...); | clone( (Molecule)arg1) -> Molecule :; | docstring; | ; | deactivate_all_fragments(...); | deactivate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | extract_subsets(...); | extract_subsets( (Molecule)arg1, (list)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (list)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2, (int)arg3) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (list)arg2) -> Molecule :; | docstring; | ; | extract_subsets( (Molecule)arg1, (int)arg2) -> Molecule :; | docstring; | ; | find_point_group(...); | find_point_group( (Molecule)arg1, (float)arg2) -> PointGroup :; | docstring; | ; | fix_orientation(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | docstring; | ; | form_symmetry_information(...); | form_symme",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:68111,Energy Efficiency,energy,energy,68111,"hods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ---",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:68126,Energy Efficiency,energy,energy,68126," | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inher",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:70824,Energy Efficiency,allocate,allocate,70824,"nit__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_gga(...); | is_gga( (SuperFunctional)arg1) -",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:70841,Energy Efficiency,allocate,allocate,70841,"ated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | c_omega(...); | c_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (SuperFunctional)arg1) -> str :; | docstring; | ; | deriv(...); | deriv( (SuperFunctional)arg1) -> int :; | docstring; | ; | description(...); | description( (SuperFunctional)arg1) -> str :; | docstring; | ; | dispersion(...); | dispersion( (SuperFunctional)arg1) -> Dispersion :; | docstring; | ; | is_c_hybrid(...); | is_c_hybrid( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_c_lrc(...); | is_c_lrc( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_gga(...); | is_gga( (SuperFunctional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (SuperFunctional)arg1) -> bool :; | do",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:83267,Energy Efficiency,energy,energy,83267,"Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:83282,Energy Efficiency,energy,energy,83282,"docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:1478,Modifiability,inherit,inherited,1478,"rguments; BasisSet; BasisSetParser; Gaussian94BasisSetParser; CdSalcList; Checkpoint; DFChargeFitter; Dimension; Dispersion; Environment; ExternalPotential; FittingMetric; Functional; GridProp; IO; IOManager; IntVector; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimit",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:1658,Modifiability,inherit,inherited,1658,"atrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:3275,Modifiability,inherit,inherited,3275,"reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:3455,Modifiability,inherit,inherited,3455,"t :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:4211,Modifiability,inherit,inherited,4211," here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attri",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:4391,Modifiability,inherit,inherited,4391,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:5289,Modifiability,inherit,inherited,5289,"rom Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:5469,Modifiability,inherit,inherited,5469,"om Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:6778,Modifiability,inherit,inherited,6778,"ata and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...)",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:6958,Modifiability,inherit,inherited,6958,"> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; | ; | enuc; | docstring; | ; | eref; | docstring; | ; | escf; | docstring; | ; | etot; | docstring; | ; | label; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | -----------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:8106,Modifiability,inherit,inherited,8106,"utes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFChargeFitter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:8286,Modifiability,inherit,inherited,8286,"der:; | DFChargeFitter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | d(...); | d( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | fit(...); | fit( (DFChargeFitter)arg1) -> Vector :; | docstring; | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | --------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:9039,Modifiability,inherit,inherited,9039," 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:9268,Modifiability,inherit,inherited,9268,"--------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:9403,Modifiability,inherit,inherited,9403,"__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = PsiMod.DiagonalizeOrder.Ascending; | ; | Descending = PsiMod.DiagonalizeOrder.Descending; | ; | names = {'Ascending': PsiMod.DiagonalizeOrder.Ascending, 'Descending':...; | ; | values = {1: PsiMod.DiagonalizeOrder.Ascending, 3: PsiMod.DiagonalizeO...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:12082,Modifiability,inherit,inherited,12082,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)ar",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:12470,Modifiability,inherit,inherited,12470," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstrin",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:13763,Modifiability,inherit,inherited,13763,"ype of T; ; class Dimension(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dimension; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Dimension)arg1, (int)arg2) -> int :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:13943,Modifiability,inherit,inherited,13943,"; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __init__( (object)arg1, (int)arg2, (str)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Dimension)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | init(...); | init( (Dimension)arg1, (str)arg2, (int)arg3) -> None :; | docstring; | ; | n(...); | n( (Dimension)arg1) -> int :; | docstring; | ; | name(...); | name( (Dimension)arg1) -> str :; | docstring; | ; | set_name(...); | set_name( (Dimension)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy( (Dispersion)arg1, (Molecule)arg2) -> float :; | docstring; | ; | compute_gradient(...); | compute_gradient( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; | ; | compute_hessian(...); | compute_hessian( (Dispersion)arg1, (Molecule)arg2) -> Matrix :; | docstring; | ; | description(...); | description( (Dispersion)arg1) -> str :; | docstring; | ; | name(...); | name( (Dispersion)arg1) -> str ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:16079,Modifiability,inherit,inherited,16079,"ring; | ; | print_energy(...); | print_energy( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_gradient(...); | print_gradient( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_hessian(...); | print_hessian( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_out(...); | print_out( (Dispersion)arg1) -> None :; | docstring; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:16259,Modifiability,inherit,inherited,16259," | ; | print_out(...); | print_out( (Dispersion)arg1) -> None :; | docstring; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:17052,Modifiability,inherit,inherited,17052,"his class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:17232,Modifiability,inherit,inherited,17232,"---------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:18588,Modifiability,inherit,inherited,18588,"st.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; |",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:18768,Modifiability,inherit,inherited,18768,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:20528,Modifiability,inherit,inherited,20528,"orm_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:20708,Modifiability,inherit,inherited,20708,"; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)arg1) -> bool :; | docstring; | ; | is_lrc(...); | is_lrc( (Functional)arg1) -> bool :; | docstring; | ; | is_meta(...); | is_meta( (Functional)arg1) -> bool :; | docstring; | ; | lsda_cutoff(...); | lsda_cutoff( (Functional)arg1) -> float :; | docstring; | ;",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:23504,Modifiability,inherit,inherited,23504," | ; | set_gga(...); | set_gga( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_lsda_cutoff(...); | set_lsda_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_meta(...); | set_meta( (Functional)arg1, (bool)arg2) -> None :; | docstring; | ; | set_meta_cutoff(...); | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:23684,Modifiability,inherit,inherited,23684,"; | set_meta_cutoff( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes i",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:24438,Modifiability,inherit,inherited,24438," __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)a",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:24618,Modifiability,inherit,inherited,24618,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_beta_mo(...); | add_beta_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | build_grid_overages(...); | build_grid_overages( (GridProp)arg1, (float)arg2) -> No",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:26719,Modifiability,inherit,inherited,26719," docstring; | ; | compute(...); | compute( (GridProp)arg1) -> None :; | docstring; | ; | get_l(...); | get_l( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | get_n(...); | get_n( (GridProp)arg1, (int)arg2) -> int :; | docstring; | ; | get_o(...); | get_o( (GridProp)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:26899,Modifiability,inherit,inherited,26899,"op)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:27629,Modifiability,inherit,inherited,27629,"----------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:29541,Modifiability,inherit,inherited,29541,"..); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:29721,Modifiability,inherit,inherited,29721," :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(.",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:31498,Modifiability,inherit,inherited,31498,"k( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:31678,Modifiability,inherit,inherited,31678,"g3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (int)arg2) -> str :; | docstring; | ; | mark_file_for_retention(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:33568,Modifiability,inherit,inherited,33568,"tion(...); | mark_file_for_retention( (IOManager)arg1, (str)arg2, (bool)arg3) -> None :; | docstring; | ; | print_out(...); | print_out( (IOManager)arg1) -> None :; | docstring; | ; | psiclean(...); | psiclean( (IOManager)arg1) -> None :; | docstring; | ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | ni",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:33748,Modifiability,inherit,inherited,33748," ; | set_default_path(...); | set_default_path( (IOManager)arg1, (str)arg2) -> None :; | docstring; | ; | set_specific_path(...); | set_specific_path( (IOManager)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | set_specific_retention(...); | set_specific_retention( (IOManager)arg1, (int)arg2, (bool)arg3) -> None :; | docstring; | ; | write_scratch_file(...); | write_scratch_file( (IOManager)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> IOManager :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | -------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:34912,Modifiability,inherit,inherited,34912,"d from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:35092,Modifiability,inherit,inherited,35092,"Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Matrix(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Matrix; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Matrix)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2, (int)arg3) -> None; | ; | __init__( (object)arg1, (str)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Matrix)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | accumulate_product(...); | accumulate_product( (Matrix)arg1, (Matrix)arg2, (Matri",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:40220,Modifiability,inherit,inherited,40220,")arg2) -> None :; | docstring; | ; | subtract(...); | subtract( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | sum_of_squares(...); | sum_of_squares( (Matrix)arg1) -> float :; | docstring; | ; | symmetry(...); | symmetry( (Matrix)arg1) -> int :; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | -------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:40400,Modifiability,inherit,inherited,40400,"; | docstring; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | zero_lower(...); | zero_lower( (Matrix)arg1) -> None :; | docstring; | ; | zero_upper(...); | zero_upper( (Matrix)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:41477,Modifiability,inherit,inherited,41477,"----------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:41657,Modifiability,inherit,inherited,41657,"actory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (BasisSet)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | ao_erf_eri(...); | ao_erf_eri( (MintsHelper)arg1, (float)arg2) -> Matrix :; | docstring; | ; | ao_eri(...); | ao_eri( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_kinetic(...); | ao_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | ao_nabla(...); | ao_nabla( (MintsHelper)arg1) -",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:44554,Modifiability,inherit,inherited,44554,"ring; | ; | play(...); | play( (MintsHelper)arg1) -> None :; | docstring; | ; | so_angular_momentum(...); | so_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_dipole(...); | so_dipole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inhe",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:44734,Modifiability,inherit,inherited,44734,"tring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:45404,Modifiability,inherit,inherited,45404,"--------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:45584,Modifiability,inherit,inherited,45584,"---------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | __getattr__ = new_get_attr(self, name); | Function to redefine get_attr method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine set_attr method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | docstring; | ; | add_atom(...); | add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:52564,Modifiability,inherit,inherited,52564,"1, (PointGroup)arg2) -> None :; | docstring; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | docstring; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | docstring; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | -----",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:52744,Modifiability,inherit,inherited,52744,"(Molecule)arg1, (Vector3)arg2) -> None :; | docstring; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | update_geometry( (Molecule)arg1) -> None :; | docstring; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:53500,Modifiability,inherit,inherited,53500,"butes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:53680,Modifiability,inherit,inherited,53680,"t__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Pytho",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:54341,Modifiability,inherit,inherited,54341,"function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:54521,Modifiability,inherit,inherited,54521,"------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inh",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:55453,Modifiability,inherit,inherited,55453,"-------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __in",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:55633,Modifiability,inherit,inherited,55633,"_new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OrbitalSpace(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OrbitalSpace; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C(...); | C( (OrbitalSpace)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (Vector)arg5, (BasisSet)arg6, (object)arg7) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Matrix)arg4, (BasisSet)arg5, (object)arg6) -> None; | ; | __init__( (object)arg1, (str)arg2, (str)arg3, (Wavefunction)arg4) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimens",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:57486,Modifiability,inherit,inherited,57486,"nnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and othe",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:57666,Modifiability,inherit,inherited,57666,"...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:58643,Modifiability,inherit,inherited,58643,"---------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | -----------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:58823,Modifiability,inherit,inherited,58823,"thon.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:59658,Modifiability,inherit,inherited,59658,"be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:59838,Modifiability,inherit,inherited,59838,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PointGroup(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PointGroup; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (str)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | symbol(...); | symbol( (PointGroup)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:60661,Modifiability,inherit,inherited,60661,"------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (P",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:60841,Modifiability,inherit,inherited,60841,"---------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes define",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:61912,Modifiability,inherit,inherited,61912,"-----------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiRe",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:62092,Modifiability,inherit,inherited,62092,"seudoTrial(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PseudoTrial; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | getA(...); | getA( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getI(...); | getI( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__()",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:62909,Modifiability,inherit,inherited,62909,"-----------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:63138,Modifiability,inherit,inherited,63138,"tes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <=",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:63273,Modifiability,inherit,inherited,63273,"bject with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = PsiMod.PsiReturnType.Balk; | ; | EndLoop = PsiMod.PsiReturnType.EndLoop; | ; | Failure = PsiMod.PsiReturnType.Failure; | ; | Success = PsiMod.PsiReturnType.Success; | ; | names = {'Balk': PsiMod.PsiReturnType.Balk, 'EndLoop': PsiMod.PsiRetur...; | ; | values = {0: PsiMod.PsiReturnType.Success, 1: PsiMod.PsiReturnType.Fai...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshif",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:65952,Modifiability,inherit,inherited,65952,"; | x.__rlshift__(y) <==> y<<x; | ; | __rmod__(...); | x.__rmod__(y) <==> y%x; | ; | __rmul__(...); | x.__rmul__(y) <==> y*x; | ; | __ror__(...); | x.__ror__(y) <==> y|x; | ; | __rpow__(...); | y.__rpow__(x[, z]) <==> pow(x, y[, z]); | ; | __rrshift__(...); | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an ex",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:66340,Modifiability,inherit,inherited,66340," | x.__rrshift__(y) <==> y>>x; | ; | __rshift__(...); | x.__rshift__(y) <==> x>>y; | ; | __rsub__(...); | x.__rsub__(y) <==> y-x; | ; | __rtruediv__(...); | x.__rtruediv__(y) <==> y/x; | ; | __rxor__(...); | x.__rxor__(y) <==> y^x; | ; | __sub__(...); | x.__sub__(y) <==> x-y; | ; | __truediv__(...); | x.__truediv__(y) <==> x/y; | ; | __trunc__(...); | Truncating an Integral returns itself.; | ; | __xor__(...); | x.__xor__(y) <==> x^y; | ; | bit_length(...); | int.bit_length() -> int; | ; | Number of bits necessary to represent self in binary.; | >>> bin(37); | '0b100101'; | >>> (37).bit_length(); | 6; | ; | conjugate(...); | Returns self, the complex conjugate of any int.; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...);",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:67062,Modifiability,inherit,inherited,67062,"---------------; | Data descriptors inherited from __builtin__.int:; | ; | denominator; | the denominator of a rational number in lowest terms; | ; | imag; | the imaginary part of a complex number; | ; | numerator; | the numerator of a rational number in lowest terms; | ; | real; | the real part of a complex number; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:68974,Modifiability,inherit,inherited,68974,"..); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -----",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:69154,Modifiability,inherit,inherited,69154," :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:69989,Modifiability,inherit,inherited,69989,"basisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> N",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:70169,Modifiability,inherit,inherited,70169,"---------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SuperFunctional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SuperFunctional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_c_functional(...); | add_c_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | add_x_functional(...); | add_x_functional( (SuperFunctional)arg1, (Functional)arg2) -> None :; | docstring; | ; | allocate(...); | allocate( (SuperFunctional)arg1) -> None :; | docstring; | ; | ansatz(...); | ansatz( (SuperFunctional)arg1) -> int :; | docstring; | ; | c_alpha(...); | c_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | c_functional(...); | c_functional( (SuperFunct",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:74528,Modifiability,inherit,inherited,74528,"ctional)arg1, (float)arg2) -> None :; | docstring; | ; | test_functional(...); | test_functional( (SuperFunctional)arg1, (Vector)arg2, (Vector)arg3, (Vector)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | value(...); | value( (SuperFunctional)arg1, (str)arg2) -> Vector :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:74708,Modifiability,inherit,inherited,74708,"r :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | c2_x( (SymmetryOperation)arg1) -> None :; | docstring; | ; | c2_y(...); | c2_y( (SymmetryOperation)arg1) -> None :; | docstring; | ; | i(...); | i( (SymmetryOperation)arg1) -> None :; | docstring; | ; | operate(...); | operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; |",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:76776,Modifiability,inherit,inherited,76776,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:76956,Modifiability,inherit,inherited,76956,"tryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(.",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:78659,Modifiability,inherit,inherited,78659," __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | __setitem__( (Vector)arg1, (tuple)arg2, (float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | docstring; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1,",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:78839,Modifiability,inherit,inherited,78839,"float)arg3) -> None :; | docstring; | ; | dim(...); | dim( (Vector)arg1, (int)arg2) -> int :; | docstring; | ; | get(...); | get( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | __getitem__(...); | __getitem__( (Vector3)arg1, (int)arg2) -> float :; | docstring; | ; | __iadd__(...); | __iadd__( (object)arg1, (Vector3)arg2) -> object; | ; | __imul__(...); | __imul__( (object)arg1, (float)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (float)arg4) -> None; | ; | __init__( (object)arg1, (Vector3)arg2) -> None; | ; | __isub__(...); | __isub__( (object)",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:80698,Modifiability,inherit,inherited,80698,"init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (float)arg4) -> None; | ; | __init__( (object)arg1, (Vector3)arg2) -> None; | ; | __isub__(...); | __isub__( (object)arg1, (Vector3)arg2) -> object; | ; | __neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | docstring; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | docstring; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | docstring; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); |",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:80878,Modifiability,inherit,inherited,80878,"__neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | docstring; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | docstring; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | docstring; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data a",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:81653,Modifiability,inherit,inherited,81653,"----------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <u",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:81833,Modifiability,inherit,inherited,81833,"f__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | do",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:84370,Modifiability,inherit,inherited,84370,"avefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | ",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:84550,Modifiability,inherit,inherited,84550,"| docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; |",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:85563,Modifiability,extend,extend,85563,"her attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class matrix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vecto",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:85578,Modifiability,extend,extend,85578,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:85878,Modifiability,inherit,inherited,85878,"trix_vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | matrix_vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (matrix_vector)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (i",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:86058,Modifiability,inherit,inherited,86058,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -> None :; docstring; ; DGEEV(...); DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:95308,Modifiability,plugin,plugin,95308,"ed(...); has_global_option_changed( (str)arg1) -> bool :; docstring; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; docstring; ; has_option_changed(...); has_option_changed( (str)arg1) -> bool :; docstring; ; libfock(...); libfock() -> int :; docstring; ; mcscf(...); mcscf() -> float :; docstring; ; me(...); me() -> int :; docstring; ; mints(...); mints() -> int :; docstring; ; mp2(...); mp2() -> float :; docstring; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; docstring; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; docstring; ; nproc(...); nproc() -> int :; docstring; ; nthread(...); nthread() -> int :; docstring; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> int :; docstring; ; opt_clean(...); opt_clean() -> None :; docstring; ; optking(...); optking() -> int :; docstring; ; outfile_name(...); outfile_name() -> str :; docstring; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; docstring; ; print_global_options(...); print_global_options() -> None :; docstring; ; print_options(...); print_options() -> None :; docstring; ; print_out(...); print_out( (str)arg1) -> None :; docstring; ; print_variables(...); print_variables() -> None :; docstring; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; docstring; ; psimrcc(...); psimrcc() -> float :; docstring; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; docstring; ; reopen_outfile(...); reopen_outfile() -> None :; docstring; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; docstring; ; revoke_local_opt",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:95321,Modifiability,plugin,plugin,95321,"; docstring; ; has_local_option_changed(...); has_local_option_changed( (str)arg1, (str)arg2) -> bool :; docstring; ; has_option_changed(...); has_option_changed( (str)arg1) -> bool :; docstring; ; libfock(...); libfock() -> int :; docstring; ; mcscf(...); mcscf() -> float :; docstring; ; me(...); me() -> int :; docstring; ; mints(...); mints() -> int :; docstring; ; mp2(...); mp2() -> float :; docstring; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; docstring; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; docstring; ; nproc(...); nproc() -> int :; docstring; ; nthread(...); nthread() -> int :; docstring; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> int :; docstring; ; opt_clean(...); opt_clean() -> None :; docstring; ; optking(...); optking() -> int :; docstring; ; outfile_name(...); outfile_name() -> str :; docstring; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; docstring; ; print_global_options(...); print_global_options() -> None :; docstring; ; print_options(...); print_options() -> None :; docstring; ; print_out(...); print_out( (str)arg1) -> None :; docstring; ; print_variables(...); print_variables() -> None :; docstring; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; docstring; ; psimrcc(...); psimrcc() -> float :; docstring; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; docstring; ; reopen_outfile(...); reopen_outfile() -> None :; docstring; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; docstring; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:37372,Performance,load,load,37372,"Matrix)arg3]) -> Matrix; | ; | cholesky_factorize(...); | cholesky_factorize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> i",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:37385,Performance,load,load,37385,"rize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bo",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:10059,Security,hash,hash,10059,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:63929,Security,hash,hash,63929,"hon.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnewargs__(...); | ; | __hash__(...); | x.__hash__() <==> hash(x); | ; | __hex__(...); | x.__hex__() <==> hex(x); | ; | __index__(...); | x[y:z] <==> x[y.__index__():z.__index__()]; | ; | __int__(...); | x.__int__() <==> int(x); | ; | __invert__(...); | x.__invert__() <==> ~x; | ; | __long__(...); | x.__long__() <==> long(x); | ; | __lshift__(...); | x.__lshift__(y) <==> x<<y; | ; | __mod__(...); | x.__mod__(y) <==> x%y; | ; | __mul__(...); | x.__mul__(y) <==> x*y; | ; | __neg__(...); | x.__neg__() <==> -x; | ; | __nonzero__(...); | x.__nonzero__() <==> x != 0; | ; | __oct__(...); | x.__oct__() <==> oct(x); | ; | __or__(...); | x.__or__(y) <==> x|y; | ; | __pos__(...); | x.__pos__() <==> +x; | ; | __pow__(...); | x.__pow__(y[, z]) <==> pow(x, y[, z]); | ; | __radd__(...); | x.__radd__(y) <==> y+x; | ; | __rand__(...); | x.__rand__(y) <==> y&x; | ; | __rdiv__(...); | x.__rdiv__(y) <==> y/x; | ; | __rdivmod__(...); | x.__rdivmod__(y) <==> divmod(y, x); | ; | __rfloordiv__(...); | x.__rfloordiv__(y) <==> y//x; | ; | __rlshift__(...); | x.__rlshift__",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:17967,Usability,clear,clear,17967,"defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new o",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimod.html:17981,Usability,clear,clear,17981,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolu",MatchSource.WIKI,psi4manual/4.0b2/psimod.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:4813,Availability,avail,available,4813,"energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in; the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly occupied in each reference determinant and are not correlated in the MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly occupied in each reference determinant and are correlated in the MRCC procedure.; Active orbitals (ACTIVE) are partially occupied in each reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in all ref",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2056,Deployability,configurat,configuration,2056,"RCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MC",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2676,Deployability,configurat,configuration,2676,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2769,Deployability,configurat,configuration,2769,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:7315,Deployability,update,updated,7315,"that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly occupied in each reference determinant and are not correlated in the MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly occupied in each reference determinant and are correlated in the MRCC procedure.; Active orbitals (ACTIVE) are partially occupied in each reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in all reference determinants and are excluded from the correlated wave function. The model space is selected by considering all possible occupations of the electrons among the orbitals in the active space that result in determinants with the correct symmetry (WFN_SYM) and the correct value specified by the keyword CORR_MULTP. Note that this does not consider the multiplicity of the wavefunction. Thus, in order to obtain the wavefunction with a set of reference determinants for an open-shell system you should request a CORR_MULTP of 1 within the PSIMRCC module, and select the root of the effective Hamiltonian that corresponds to the state of interest. In addition, the WFN_SYM keyword needs to be specified otherwise the wavefunction belonging to the all-symmetric irrep will be selected. In addition, it should be noted that for an open-shell singlet based on two determinants the eigenvector is [], which corresponds to a wavefunction of the following form:. See Appendix PSIMRCC for a complete list of PSIMRCC options. Table Of Contents. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Previous topic; Coupled Cluster Methods; Next topic; Interface to MRCC by M. Kállay; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:739,Energy Efficiency,power,powerful,739,"﻿. PSIMRCC Implementation of Mk-MRCC Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». PSIMRCC Implementation of Mk-MRCC Theory¶; Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly accurate energies and properties of electronic states that require a multiconfigurational zeroth-order wavefunction. The PSIMRCC module contained in PSI4 implements the state-specific multireference coupled-cluster approach of Mukherjee and co-workers (Mk-MRCC). This method is implemented and shown to be a powerful tool in [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the wavefunction, . where are the reference determinants, are reference-specific excitation operators, and are expansion coefficients obtained through diagonalization of the Mk-MRCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), e",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:1301,Energy Efficiency,energy,energy,1301,": Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly accurate energies and properties of electronic states that require a multiconfigurational zeroth-order wavefunction. The PSIMRCC module contained in PSI4 implements the state-specific multireference coupled-cluster approach of Mukherjee and co-workers (Mk-MRCC). This method is implemented and shown to be a powerful tool in [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the wavefunction, . where are the reference determinants, are reference-specific excitation operators, and are expansion coefficients obtained through diagonalization of the Mk-MRCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an appr",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2608,Energy Efficiency,energy,energy,2608,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for hig",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:3842,Energy Efficiency,energy,energy,3842,"f PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:4038,Energy Efficiency,energy,energy,4038,", one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals f",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:4616,Energy Efficiency,energy,energy,4616,"al, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in; the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires t",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:1250,Integrability,contract,contracted,1250," Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly accurate energies and properties of electronic states that require a multiconfigurational zeroth-order wavefunction. The PSIMRCC module contained in PSI4 implements the state-specific multireference coupled-cluster approach of Mukherjee and co-workers (Mk-MRCC). This method is implemented and shown to be a powerful tool in [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the wavefunction, . where are the reference determinants, are reference-specific excitation operators, and are expansion coefficients obtained through diagonalization of the Mk-MRCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the cod",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2056,Modifiability,config,configuration,2056,"RCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MC",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2676,Modifiability,config,configuration,2676,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2769,Modifiability,config,configuration,2769,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2400,Performance,perform,perform,2400,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2416,Performance,optimiz,optimization,2416,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2569,Performance,optimiz,optimized,2569,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for hig",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:3296,Performance,perform,performing,3296,"ll be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ",MatchSource.WIKI,psi4manual/4.0b2/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:4813,Availability,avail,available,4813,"energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in; the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly occupied in each reference determinant and are not correlated in the MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly occupied in each reference determinant and are correlated in the MRCC procedure.; Active orbitals (ACTIVE) are partially occupied in each reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in all ref",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2056,Deployability,configurat,configuration,2056,"RCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MC",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2676,Deployability,configurat,configuration,2676,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2769,Deployability,configurat,configuration,2769,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:7315,Deployability,update,updated,7315,"that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly occupied in each reference determinant and are not correlated in the MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly occupied in each reference determinant and are correlated in the MRCC procedure.; Active orbitals (ACTIVE) are partially occupied in each reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in all reference determinants and are excluded from the correlated wave function. The model space is selected by considering all possible occupations of the electrons among the orbitals in the active space that result in determinants with the correct symmetry (WFN_SYM) and the correct value specified by the keyword CORR_MULTP. Note that this does not consider the multiplicity of the wavefunction. Thus, in order to obtain the wavefunction with a set of reference determinants for an open-shell system you should request a CORR_MULTP of 1 within the PSIMRCC module, and select the root of the effective Hamiltonian that corresponds to the state of interest. In addition, the WFN_SYM keyword needs to be specified otherwise the wavefunction belonging to the all-symmetric irrep will be selected. In addition, it should be noted that for an open-shell singlet based on two determinants the eigenvector is [], which corresponds to a wavefunction of the following form:. See Appendix PSIMRCC for a complete list of PSIMRCC options. Table Of Contents. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Previous topic; Coupled Cluster Methods; Next topic; Interface to MRCC by M. Kállay; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:739,Energy Efficiency,power,powerful,739,"﻿. PSIMRCC Implementation of Mk-MRCC Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». PSIMRCC Implementation of Mk-MRCC Theory¶; Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly accurate energies and properties of electronic states that require a multiconfigurational zeroth-order wavefunction. The PSIMRCC module contained in PSI4 implements the state-specific multireference coupled-cluster approach of Mukherjee and co-workers (Mk-MRCC). This method is implemented and shown to be a powerful tool in [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the wavefunction, . where are the reference determinants, are reference-specific excitation operators, and are expansion coefficients obtained through diagonalization of the Mk-MRCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), e",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:1301,Energy Efficiency,energy,energy,1301,": Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly accurate energies and properties of electronic states that require a multiconfigurational zeroth-order wavefunction. The PSIMRCC module contained in PSI4 implements the state-specific multireference coupled-cluster approach of Mukherjee and co-workers (Mk-MRCC). This method is implemented and shown to be a powerful tool in [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the wavefunction, . where are the reference determinants, are reference-specific excitation operators, and are expansion coefficients obtained through diagonalization of the Mk-MRCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an appr",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2608,Energy Efficiency,energy,energy,2608,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for hig",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:3842,Energy Efficiency,energy,energy,3842,"f PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:4038,Energy Efficiency,energy,energy,4038,", one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals f",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:4616,Energy Efficiency,energy,energy,4616,"al, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in; the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants are specified in PSIMRCC; via occupational numbers. PSIMRCC requires t",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:1250,Integrability,contract,contracted,1250," Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly accurate energies and properties of electronic states that require a multiconfigurational zeroth-order wavefunction. The PSIMRCC module contained in PSI4 implements the state-specific multireference coupled-cluster approach of Mukherjee and co-workers (Mk-MRCC). This method is implemented and shown to be a powerful tool in [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the wavefunction, . where are the reference determinants, are reference-specific excitation operators, and are expansion coefficients obtained through diagonalization of the Mk-MRCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the cod",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2056,Modifiability,config,configuration,2056,"RCC effective Hamiltonian matrix that allows the various reference determinants to interact. As an example of how this works the Mk-MRCCSD excitation operators for each reference is contracted two-body terms. where. and. The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian, . where. PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MC",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2676,Modifiability,config,configuration,2676,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2769,Modifiability,config,configuration,2769,"h all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2400,Performance,perform,perform,2400,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2416,Performance,optimiz,optimization,2416,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:2569,Performance,optimiz,optimized,2569,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for hig",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psimrcc.html:3296,Performance,perform,performing,3296,"ll be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ",MatchSource.WIKI,psi4manual/4.0b2/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc.html
https://psicode.org/psi4manual/4.0b2/psithonfunc-1.html:1223,Deployability,update,updated,1223,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Function Intercalls; Embarrassing Parallelism. Previous topic; Geometry Optimization; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithonfunc-1.html
https://psicode.org/psi4manual/4.0b2/psithonfunc-1.html:566,Energy Efficiency,efficient,efficient,566,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Function Intercalls; Embarrassing Parallelism. Previous topic; Geometry Optimization; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithonfunc-1.html
https://psicode.org/psi4manual/4.0b2/psithonfunc-1.html:234,Performance,perform,performed,234,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Function Intercalls; Embarrassing Parallelism. Previous topic; Geometry Optimization; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithonfunc-1.html
https://psicode.org/psi4manual/4.0b2/psithonfunc.html:1223,Deployability,update,updated,1223,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Function Intercalls; Embarrassing Parallelism. Previous topic; Geometry Optimization; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithonfunc.html
https://psicode.org/psi4manual/4.0b2/psithonfunc.html:566,Energy Efficiency,efficient,efficient,566,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Function Intercalls; Embarrassing Parallelism. Previous topic; Geometry Optimization; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithonfunc.html
https://psicode.org/psi4manual/4.0b2/psithonfunc.html:234,Performance,perform,performed,234,"﻿. Psithon Functions: Invoking a Calculation — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes. Function Intercalls; Embarrassing Parallelism. Previous topic; Geometry Optimization; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithonfunc.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1320,Availability,avail,available,1320,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1724,Availability,avail,available,1724," the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:12733,Availability,reliab,reliable,12733,"For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:18876,Availability,avail,available,18876,"ymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalm",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:18987,Availability,avail,available,18987,"run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of t",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19135,Availability,avail,available,19135,"ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Pytho",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19512,Availability,avail,available,19512,"se variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20377,Availability,avail,available,20377,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:23847,Deployability,integrat,integrated,23847,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:25037,Deployability,update,updated,25037," first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing PSI4’s Environment; Next topic; Basis Sets; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:2112,Energy Efficiency,meter,meters,2112," if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:2499,Energy Efficiency,joule,joule,2499,"8]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 #",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:2639,Energy Efficiency,joule,joule,2639,"he physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; P",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:4964,Energy Efficiency,energy,energy,4964,"olecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of th",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:5036,Energy Efficiency,energy,energy,5036," 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and mult",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:5511,Energy Efficiency,energy,energy,5511," see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångst",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:5577,Energy Efficiency,energy,energy,5577,"ble to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; u",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:6009,Energy Efficiency,charge,charge,6009,"). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becom",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:9703,Energy Efficiency,charge,charge,9703,"; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgrou",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:12581,Energy Efficiency,energy,energy,12581,"tain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molec",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13106,Energy Efficiency,adapt,adapted,13106,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multipli",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13491,Energy Efficiency,energy,energy,13491,"upation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in th",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13930,Energy Efficiency,charge,charge,13930,"Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:14016,Energy Efficiency,charge,charge,14016," counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon pre",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:14180,Energy Efficiency,charge,charge,14180,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple k",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:14222,Energy Efficiency,charge,charges,14222,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple k",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:15951,Energy Efficiency,energy,energy,15951,"set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snipp",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16276,Energy Efficiency,energy,energy,16276,"-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16530,Energy Efficiency,energy,energy,16530,"s the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likew",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19427,Energy Efficiency,power,power,19427,"se variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19723,Energy Efficiency,energy,energy,19723,"sis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulat",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19806,Energy Efficiency,energy,energy,19806,"d Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single i",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19895,Energy Efficiency,energy,energy,19895," algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20052,Energy Efficiency,energy,energy,20052,"lowing; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Modul",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20332,Energy Efficiency,energy,energy,20332,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20361,Energy Efficiency,energy,energy,20361,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21382,Energy Efficiency,energy,energy,21382," both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Pyth",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21793,Energy Efficiency,energy,energy,21793,"; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:22059,Energy Efficiency,energy,energy,22059,"or a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:22555,Energy Efficiency,energy,energy,22555,"quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatti",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:22812,Energy Efficiency,energy,energy,22812,"2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:23194,Energy Efficiency,energy,energy,23194,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented fo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:11737,Integrability,depend,dependent,11737,"he symmetry keyword can be used when inputting the molecule; (see Sec. Molecule Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these sta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:15091,Integrability,wrap,wraps,15091,"be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupl",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21552,Integrability,wrap,wraps,21552,"ed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:23847,Integrability,integrat,integrated,23847,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1049,Modifiability,variab,variables,1049,"tation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversio",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1307,Modifiability,variab,variable,1307,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1555,Modifiability,variab,variables,1555,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:3596,Modifiability,variab,variables,3596,"}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:3669,Modifiability,flexible,flexible,3669,"SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:3770,Modifiability,variab,variables,3770,"SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:3836,Modifiability,variab,variables,3836,"for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; cal",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13106,Modifiability,adapt,adapted,13106,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multipli",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:19987,Modifiability,variab,variable,19987," algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20525,Modifiability,variab,variables,20525,"the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20686,Modifiability,variab,variables,20686,"nergy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specif",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21083,Modifiability,variab,variables,21083,"inted to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21635,Modifiability,variab,variable,21635,"ed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21758,Modifiability,variab,variable,21758,"; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:22305,Modifiability,variab,variable,22305,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:22371,Modifiability,variab,variables,22371,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:220,Performance,perform,performed,220,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:361,Performance,perform,performed,361,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:973,Performance,perform,performing,973,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1536,Performance,load,loaded,1536,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1586,Performance,load,loaded,1586,"test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) con",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:5079,Performance,perform,performed,5079,"r. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:5131,Performance,perform,performed,5131,"r. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:7485,Performance,perform,performed,7485," changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whose name(s) contain “benzene”, but we’re not sure of the exact IUPAC; name, the following input can be used:; molecule benzene {; pubchem:benzene*; }. Appending the “*” prevents an exact match from being found and, at the time; of writing, the following results are displayed in the output file:; Chemical ID IUPAC Name; 241 benzene; 7371 benzenesulfonic acid; 91526 benzenesulfonate; 244 phenylmethanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 ben",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:9344,Performance,optimiz,optimized,9344,"methanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:14398,Performance,perform,perform,14398,"d then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16083,Performance,perform,performs,16083,"ithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16196,Performance,perform,performed,16196,"-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16329,Performance,perform,performed,16329,"-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16974,Performance,perform,performs,16974," set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:18960,Performance,perform,perform,18960,"run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of t",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20255,Performance,perform,performing,20255,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:23209,Performance,perform,performed,23209,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented fo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:23804,Performance,perform,performed,23804,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:6323,Safety,detect,detected,6323,"he activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:;",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:10616,Safety,detect,detect,10616," used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgroup, the user might want to run in a lower point group.; To do this the symmetry keyword can be used when inputting the molecule; (see Sec. Molecule Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; frequencies, might ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:17910,Safety,detect,detect,17910," this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are avai",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20190,Security,access,accessed,20190,"y 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:22286,Security,access,access,22286,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:590,Testability,test,test,590,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:680,Testability,test,test,680,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:310,Usability,simpl,simpler,310,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:6798,Usability,intuit,intuitive,6798,"In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:6902,Usability,intuit,intuitive,6902," of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13250,Usability,simpl,simple,13250," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13282,Usability,simpl,simply,13282," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:14190,Usability,simpl,simply,14190,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple k",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20740,Usability,clear,cleared,20740,"nergy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specif",MatchSource.WIKI,psi4manual/4.0b2/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:1320,Availability,avail,available,1320,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:1724,Availability,avail,available,1724," the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:12733,Availability,reliab,reliable,12733,"For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:18876,Availability,avail,available,18876,"ymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalm",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:18987,Availability,avail,available,18987,"run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of t",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:19135,Availability,avail,available,19135,"ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Pytho",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:19512,Availability,avail,available,19512,"se variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20377,Availability,avail,available,20377,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:23847,Deployability,integrat,integrated,23847,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:25037,Deployability,update,updated,25037," first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing PSI4’s Environment; Next topic; Basis Sets; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:2112,Energy Efficiency,meter,meters,2112," if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:2499,Energy Efficiency,joule,joule,2499,"8]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 #",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:2639,Energy Efficiency,joule,joule,2639,"he physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; P",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:4964,Energy Efficiency,energy,energy,4964,"olecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of th",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:5036,Energy Efficiency,energy,energy,5036," 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and mult",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:5511,Energy Efficiency,energy,energy,5511," see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångst",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:5577,Energy Efficiency,energy,energy,5577,"ble to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; u",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:6009,Energy Efficiency,charge,charge,6009,"). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becom",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:9703,Energy Efficiency,charge,charge,9703,"; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgrou",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:12581,Energy Efficiency,energy,energy,12581,"tain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molec",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:13106,Energy Efficiency,adapt,adapted,13106,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multipli",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:13491,Energy Efficiency,energy,energy,13491,"upation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in th",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:13930,Energy Efficiency,charge,charge,13930,"Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:14016,Energy Efficiency,charge,charge,14016," counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon pre",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:14180,Energy Efficiency,charge,charge,14180,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple k",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:14222,Energy Efficiency,charge,charges,14222,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple k",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:15951,Energy Efficiency,energy,energy,15951,"set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snipp",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:16276,Energy Efficiency,energy,energy,16276,"-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:16530,Energy Efficiency,energy,energy,16530,"s the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likew",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:19427,Energy Efficiency,power,power,19427,"se variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:19723,Energy Efficiency,energy,energy,19723,"sis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulat",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:19806,Energy Efficiency,energy,energy,19806,"d Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single i",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:19895,Energy Efficiency,energy,energy,19895," algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20052,Energy Efficiency,energy,energy,20052,"lowing; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Modul",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20332,Energy Efficiency,energy,energy,20332,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20361,Energy Efficiency,energy,energy,20361,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:21382,Energy Efficiency,energy,energy,21382," both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Pyth",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:21793,Energy Efficiency,energy,energy,21793,"; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:22059,Energy Efficiency,energy,energy,22059,"or a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:22555,Energy Efficiency,energy,energy,22555,"quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatti",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:22812,Energy Efficiency,energy,energy,22812,"2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:23194,Energy Efficiency,energy,energy,23194,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented fo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:11737,Integrability,depend,dependent,11737,"he symmetry keyword can be used when inputting the molecule; (see Sec. Molecule Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as SOCC, are automatically remapped; to the lower symmetry. For example, if we were to investigate the ; state of water cation, we can specify. SOCC = [0, 0, 1, 0]; in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these sta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:15091,Integrability,wrap,wraps,15091,"be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupl",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:21552,Integrability,wrap,wraps,21552,"ed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:23847,Integrability,integrat,integrated,23847,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:1049,Modifiability,variab,variables,1049,"tation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversio",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:1307,Modifiability,variab,variable,1307,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:1555,Modifiability,variab,variables,1555,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:3596,Modifiability,variab,variables,3596,"}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:3669,Modifiability,flexible,flexible,3669,"SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:3770,Modifiability,variab,variables,3770,"SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:3836,Modifiability,variab,variables,3836,"for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; PSI4 has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H2 can be specified a number of ways, using the; molecule keyword:; molecule{; H; H 1 0.9; }. or. molecule{; H; H 1 r; r = 0.9; }. or. molecule{; H1; H2 H1 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }. or. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; cal",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:13106,Modifiability,adapt,adapted,13106,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multipli",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:19987,Modifiability,variab,variable,19987," algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20525,Modifiability,variab,variables,20525,"the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20686,Modifiability,variab,variables,20686,"nergy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specif",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:21083,Modifiability,variab,variables,21083,"inted to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:21635,Modifiability,variab,variable,21635,"ed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:21758,Modifiability,variab,variable,21758,"; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:22305,Modifiability,variab,variable,22305,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:22371,Modifiability,variab,variables,22371,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:220,Performance,perform,performed,220,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:361,Performance,perform,performed,361,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:973,Performance,perform,performing,973,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:1536,Performance,load,loaded,1536,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:1586,Performance,load,loaded,1586,"test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) con",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:5079,Performance,perform,performed,5079,"r. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:5131,Performance,perform,performed,5131,"r. molecule{; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }. or. molecule{; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the molecule keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the mints1 input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the mints4 sample input file. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:7485,Performance,perform,performed,7485," changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whose name(s) contain “benzene”, but we’re not sure of the exact IUPAC; name, the following input can be used:; molecule benzene {; pubchem:benzene*; }. Appending the “*” prevents an exact match from being found and, at the time; of writing, the following results are displayed in the output file:; Chemical ID IUPAC Name; 241 benzene; 7371 benzenesulfonic acid; 91526 benzenesulfonate; 244 phenylmethanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 ben",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:9344,Performance,optimiz,optimized,9344,"methanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:14398,Performance,perform,perform,14398,"d then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:16083,Performance,perform,performs,16083,"ithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:16196,Performance,perform,performed,16196,"-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:16329,Performance,perform,performed,16329,"-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:16974,Performance,perform,performs,16974," set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:18960,Performance,perform,perform,18960,"run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of t",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20255,Performance,perform,performing,20255,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:23209,Performance,perform,performed,23209,"e that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented fo",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:23804,Performance,perform,performed,23804,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:6323,Safety,detect,detected,6323,"he activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:;",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:10616,Safety,detect,detect,10616," used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  .  ;  ;  ;  . For example, water ( symmetry) has 3 doubly occupied ; orbitals, as well as 1 each of and symmetry; the; corresponding DOCC array is therefore:; DOCC = [3, 0, 1, 1]. Although PSI4 will detect the symmetry automatically, and use the largest; possible Abelian subgroup, the user might want to run in a lower point group.; To do this the symmetry keyword can be used when inputting the molecule; (see Sec. Molecule Specification). In most cases the standard; Schönflies symbol (one of c1, c2, ci, cs, d2,; c2h, c2v, d2h will suffice.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with symmetry in , the; axis can be chosen as either the , the , or the ; these can; be specified by requesing the symmetry as c2vx, c2vy, or c2vz, respectively.; Likewise the c2x, c2y, c2z, c2hx, c2hy, and c2hz; labels are valid. For symmetry the labels csx, csy, and; csz request the , , and planes be used as the mirror plane,; respectively. If no unique axis is specified, PSI4 will choose an appropriate; subgroup.; Certain types of finite difference computations, such as numerical vibrational; frequencies, might ",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:17910,Safety,detect,detect,17910," this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are avai",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20190,Security,access,accessed,20190,"y 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:22286,Security,access,access,22286,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:590,Testability,test,test,590,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:680,Testability,test,test,680,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:310,Usability,simpl,simpler,310,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:6798,Usability,intuit,intuitive,6798,"In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:6902,Usability,intuit,intuitive,6902," of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:13250,Usability,simpl,simple,13250," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:13282,Usability,simpl,simply,13282," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:14190,Usability,simpl,simply,14190,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple k",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/psithoninput.html:20740,Usability,clear,cleared,20740,"nergy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specif",MatchSource.WIKI,psi4manual/4.0b2/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput.html
https://psicode.org/psi4manual/4.0b2/py-modindex.html:767,Deployability,update,updated,767,"﻿. Python Module Index — PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2] » . Python Module Index. a | ; b | ; c | ; d | ; f | ; h | ; i | ; j | ; m | ; n | ; p | ; q | ; r | ; s | ; t | ; u | ; w.  . a. ACENES. aliases.  . b. BAKERJCC93. BAKERJCC96. BASIC.  . c. CORE.  . d. driver.  . f. frac. functional.  . h. HBC6. HSG. HTBH.  . i. input.  . j. JSCH.  . m. molutil.  . n. NBC10. NHTBH.  . p. physconst. plugin_testparse.    ; plugin_testparse.__init__. proc. procutil. psiexceptions. pubchem.  . q. qmmm.  . r. RGC10.  . s. S22. S22by5. S66.  . t. text.  . u. util.  . w. wrappers. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/py-modindex.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/py-modindex.html
https://psicode.org/psi4manual/4.0b2/py-modindex.html:599,Integrability,wrap,wrappers,599,"﻿. Python Module Index — PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2] » . Python Module Index. a | ; b | ; c | ; d | ; f | ; h | ; i | ; j | ; m | ; n | ; p | ; q | ; r | ; s | ; t | ; u | ; w.  . a. ACENES. aliases.  . b. BAKERJCC93. BAKERJCC96. BASIC.  . c. CORE.  . d. driver.  . f. frac. functional.  . h. HBC6. HSG. HTBH.  . i. input.  . j. JSCH.  . m. molutil.  . n. NBC10. NHTBH.  . p. physconst. plugin_testparse.    ; plugin_testparse.__init__. proc. procutil. psiexceptions. pubchem.  . q. qmmm.  . r. RGC10.  . s. S22. S22by5. S66.  . t. text.  . u. util.  . w. wrappers. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/py-modindex.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/py-modindex.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:446,Availability,avail,available,446,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:744,Availability,avail,available,744,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:3808,Deployability,update,updated,3808," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:923,Energy Efficiency,energy,energy,923,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:964,Energy Efficiency,energy,energy,964,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:1233,Energy Efficiency,energy,energy,1233,"to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:1293,Energy Efficiency,energy,energy,1293,"scribed below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiM",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:1727,Energy Efficiency,energy,energy,1727,"MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2730,Energy Efficiency,energy,energy,2730,"antities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [b",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2785,Energy Efficiency,energy,energy,2785,"t_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2842,Energy Efficiency,energy,energy,2842,"ON ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created us",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2898,Energy Efficiency,energy,energy,2898," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2961,Energy Efficiency,energy,energy,2961," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:3025,Energy Efficiency,energy,energy,3025," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:3088,Energy Efficiency,energy,energy,3088," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:3336,Energy Efficiency,energy,energy,3336," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:3472,Energy Efficiency,energy,energy,3472," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:463,Modifiability,variab,variables,463,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:844,Modifiability,variab,variables,844,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:1550,Modifiability,variab,variable,1550,"es.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banne",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2267,Modifiability,variab,variable,2267," print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. A",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2427,Modifiability,variab,variable,2427,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2405,Performance,optimiz,optimizer,2405,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2472,Performance,optimiz,optimizations,2472,"s):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-De",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:376,Security,access,accessed,376,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:446,Availability,avail,available,446,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:744,Availability,avail,available,744,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:3808,Deployability,update,updated,3808," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:923,Energy Efficiency,energy,energy,923,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:964,Energy Efficiency,energy,energy,964,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:1233,Energy Efficiency,energy,energy,1233,"to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:1293,Energy Efficiency,energy,energy,1293,"scribed below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiM",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:1727,Energy Efficiency,energy,energy,1727,"MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2730,Energy Efficiency,energy,energy,2730,"antities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [b",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2785,Energy Efficiency,energy,energy,2785,"t_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2842,Energy Efficiency,energy,energy,2842,"ON ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created us",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2898,Energy Efficiency,energy,energy,2898," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2961,Energy Efficiency,energy,energy,2961," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:3025,Energy Efficiency,energy,energy,3025," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:3088,Energy Efficiency,energy,energy,3088," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:3336,Energy Efficiency,energy,energy,3336," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:3472,Energy Efficiency,energy,energy,3472," PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:463,Modifiability,variab,variables,463,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:844,Modifiability,variab,variables,844,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:1550,Modifiability,variab,variable,1550,"es.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banne",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2267,Modifiability,variab,variable,2267," print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. A",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2427,Modifiability,variab,variable,2427,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2405,Performance,optimiz,optimizer,2405,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:2472,Performance,optimiz,optimizations,2472,"s):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-De",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddalias.html:376,Security,access,accessed,376,"﻿. Defining a Method Alias — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR aka psi4/lib, including those described below. Defining a Method Alias¶; Since quantum chemical methods in PSI4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/lib/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf +",MatchSource.WIKI,psi4manual/4.0b2/quickaddalias.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias.html
https://psicode.org/psi4manual/4.0b2/quickaddbasis-1.html:3310,Deployability,update,updated,3310," for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the path can be either relative or absolute.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one above that includes; [basis name], PUREAM; value, and element basis set specifications. Hash signs denote comments.; Copy the section into a PSI4 input file and surround it with the command basis {...},; as shown below.; Multiple basis sets can be specified by adding additional sections within the surrounding brackets.; basis {; # basis set section like in snippet above goes here; # additional basis set sections follow; }. Previous topic; Customization: Adding Simple Extensions; Next topic; Defining a Method Alias; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddbasis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddbasis-1.html
https://psicode.org/psi4manual/4.0b2/quickaddbasis-1.html:336,Integrability,rout,routes,336,"﻿. User-Defined Basis Sets — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. User-Defined Basis Sets¶; There are three routes by which a basis set in G94 format can be introduced to PSI4’s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; Name the file with the name of the basis set and a .gbs extension, after applying the following transformations. All letters lowercase; Replace all * with s; Replace all + with p; Replace all ( ) , with _ (underscores replace parentheses and commas). For example, basis 6-31++G** is stored in psi4/lib/basis/6-31ppgss.gbs,; and cc-pV(D+d)Z is stored in psi4/lib/basis/cc-pv_dpd_z.gbs.; Only one basis set may be specified per file.; Copy the new basis set file into psi4/lib/basis.; Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (2) Use new basis set file in arbitrary location.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the p",MatchSource.WIKI,psi4manual/4.0b2/quickaddbasis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddbasis-1.html
https://psicode.org/psi4manual/4.0b2/quickaddbasis.html:3310,Deployability,update,updated,3310," for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the path can be either relative or absolute.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one above that includes; [basis name], PUREAM; value, and element basis set specifications. Hash signs denote comments.; Copy the section into a PSI4 input file and surround it with the command basis {...},; as shown below.; Multiple basis sets can be specified by adding additional sections within the surrounding brackets.; basis {; # basis set section like in snippet above goes here; # additional basis set sections follow; }. Previous topic; Customization: Adding Simple Extensions; Next topic; Defining a Method Alias; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickaddbasis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddbasis.html
https://psicode.org/psi4manual/4.0b2/quickaddbasis.html:336,Integrability,rout,routes,336,"﻿. User-Defined Basis Sets — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. User-Defined Basis Sets¶; There are three routes by which a basis set in G94 format can be introduced to PSI4’s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; Name the file with the name of the basis set and a .gbs extension, after applying the following transformations. All letters lowercase; Replace all * with s; Replace all + with p; Replace all ( ) , with _ (underscores replace parentheses and commas). For example, basis 6-31++G** is stored in psi4/lib/basis/6-31ppgss.gbs,; and cc-pV(D+d)Z is stored in psi4/lib/basis/cc-pv_dpd_z.gbs.; Only one basis set may be specified per file.; Copy the new basis set file into psi4/lib/basis.; Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (2) Use new basis set file in arbitrary location.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the p",MatchSource.WIKI,psi4manual/4.0b2/quickaddbasis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddbasis.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:1456,Availability,avail,available,1456,"le molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (int",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:4137,Deployability,update,updated,4137," for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:533,Energy Efficiency,energy,energy,533,"﻿. Creating a Database — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as pyth",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:1110,Energy Efficiency,energy,energy,1110,"] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re dete",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:2448,Energy Efficiency,charge,charge,2448,"agents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:2951,Energy Efficiency,charge,charge,2951," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:3035,Energy Efficiency,charge,charge,3035," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:3526,Integrability,rout,route,3526," for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:3533,Modifiability,variab,variable,3533," for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html:1182,Usability,simpl,simply,1182,"essary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an examp",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase-1.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:1456,Availability,avail,available,1456,"le molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (int",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:4137,Deployability,update,updated,4137," for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:533,Energy Efficiency,energy,energy,533,"﻿. Creating a Database — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as pyth",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:1110,Energy Efficiency,energy,energy,1110,"] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re dete",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:2448,Energy Efficiency,charge,charge,2448,"agents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:2951,Energy Efficiency,charge,charge,2951," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:3035,Energy Efficiency,charge,charge,3035," you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:3526,Integrability,rout,route,3526," for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:3533,Modifiability,variab,variable,3533," for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.pl. Move into the directory where all your xyz files are located. Run the; script in place, probably as; $PSIDATADIR/scripts/ixyz2database.pl. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.pl script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/quickadddatabase.html:1182,Usability,simpl,simply,1182,"essary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an examp",MatchSource.WIKI,psi4manual/4.0b2/quickadddatabase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickadddatabase.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:1521,Availability,avail,available,1521,"ithout computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pic",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2316,Availability,error,errors,2316,"pear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molec",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2464,Availability,avail,available,2464,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:4147,Availability,error,error,4147,"lation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are invo",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:7070,Availability,error,error,7070,"rds¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; fr",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:7089,Availability,error,error,7089,"rds¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; fr",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:16444,Availability,avail,available,16444," -0.47692549 mH -0.29927528 kcal mol^-1; Est. Disp22 (T) -0.54385253 mH -0.34127263 kcal mol^-1; Exch-Disp20 0.64545652 mH 0.40503010 kcal mol^-1; Exch-Disp30 -0.01823411 mH -0.01144207 kcal mol^-1; Ind-Disp30 -0.91816995 mH -0.57616037 kcal mol^-1; Exch-Ind-Disp30 0.76459013 mH 0.47978757 kcal mol^-1. Total HF -5.68662366 mH -3.56841037 kcal mol^-1; Total SAPT0 -8.58408823 mH -5.38659691 kcal mol^-1; Total SAPT2 -6.72339084 mH -4.21899163 kcal mol^-1; Total SAPT2+ -7.26739725 mH -4.56036082 kcal mol^-1; Total SAPT2+(3) -6.94156528 mH -4.35589816 kcal mol^-1; Total SAPT2+3 -7.11337921 mH -4.46371303 kcal mol^-1. At the bottom of this output are the total SAPT energies (defined above),; they are composed of subsets of the individual terms printed above. The; individual terms are grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:17108,Availability,recover,recover,17108,"ies (defined above),; they are composed of subsets of the individual terms printed above. The; individual terms are grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:18365,Deployability,update,updated,18365," as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled Cluster Methods; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:342,Energy Efficiency,adapt,adapted,342,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:494,Energy Efficiency,energy,energy,494,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:543,Energy Efficiency,energy,energy,543,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:640,Energy Efficiency,energy,energy,640,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:1120,Energy Efficiency,energy,energy,1120,"|. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, a",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2059,Energy Efficiency,energy,energy,2059,"is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monom",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2337,Energy Efficiency,energy,energy,2337,"pear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molec",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2849,Energy Efficiency,energy,energy,2849,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2866,Energy Efficiency,energy,energy,2866,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2883,Energy Efficiency,energy,energy,2883,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2901,Energy Efficiency,energy,energy,2901,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2922,Energy Efficiency,energy,energy,2922,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:5674,Energy Efficiency,energy,energy,5674,"pe: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:6683,Energy Efficiency,energy,energy,6683,"rgy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition perform",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:7136,Energy Efficiency,energy,energy,7136,"rds¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; fr",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:7332,Energy Efficiency,efficient,efficient,7332," Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities c",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:9679,Energy Efficiency,energy,energy,9679,"r SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:11015,Energy Efficiency,energy,energy,11015," the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. MP2 Natural Orbitals¶; One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of the triples; contribution to disperison. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promi",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12137,Energy Efficiency,energy,energy,12137,"ications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 m",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12165,Energy Efficiency,charge,charge-transfer,12165,"ications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 m",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12218,Energy Efficiency,charge,charge-transfer,12218,"trolling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12234,Energy Efficiency,energy,energy,12234,"trolling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12413,Energy Efficiency,energy,energy,12413,"bution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-c",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12431,Energy Efficiency,energy,energy,12431,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12451,Energy Efficiency,energy,energy,12451,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12471,Energy Efficiency,energy,energy,12471,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12492,Energy Efficiency,energy,energy,12492,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12516,Energy Efficiency,energy,energy,12516,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12545,Energy Efficiency,charge,charge-transfer,12545,"the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.6",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12903,Energy Efficiency,charge,charge-transfer,12903,"racy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS option will compute MP2 natural orbi",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:13847,Energy Efficiency,energy,energy,13847,"basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------; Electrostatics -13.06429805 mH -8.19797114 kcal mol^-1; Elst10,r -13.37543274 mH -8.39321111 kcal mol^-1; Elst12,r 0.04490253 mH 0.02817676 kcal mol^-1; Elst13,r 0.26623216 mH 0.16706321 kcal mol^-1. Exchange 13.41793548 mH 8.41988199 kcal mol^-1; Exch10 11.21823471 mH 7.03954885 kcal mol^-1; Exch10(S^2) 11.13803867 mH 6.98922508 kcal mol^-1; Exch11(S^2) 0.04558910 mH 0.02860760 kcal mol^-1; Exch12(S^2) 2.15411167 mH 1.35172554 kcal mol^-1. Induction -3.91333155 mH -2.45565272 kcal mol^-1; Ind20,r -4.57531220 mH -2.87105187 kcal mol^-1; Ind30,r -4.91715479 mH -3",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:17202,Energy Efficiency,energy,energy,17202,"re grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled Cluster Methods; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:342,Modifiability,adapt,adapted,342,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:1808,Performance,perform,performance,1808," interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. en",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2451,Performance,perform,perform,2451,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:3398,Performance,perform,performing,3398,"ng is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 bas",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:3653,Performance,perform,performed,3653,"62503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:3867,Performance,perform,perform,3867," energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Def",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:4107,Performance,perform,performance,4107,"lation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are invo",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:4348,Performance,perform,perform,4348," of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommend",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:4442,Performance,scalab,scalable,4442," of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommend",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:7514,Performance,perform,performed,7514," Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:7670,Performance,perform,performed,7670,"e induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of key",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:8016,Performance,perform,perform,8016,"NATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis st",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:8472,Performance,perform,performed,8472,"pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard set",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:8594,Performance,optimiz,optimized,8594,"d for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12575,Performance,perform,perform,12575,"the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.6",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12776,Performance,perform,performs,12776," orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:13447,Performance,perform,performed,13447," energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------; Electrostatics -13.06429805 mH -8.19797114 kcal mol^-1; Elst10,r -13.37543274 mH -8.39321111 kcal mol^-1; Elst12,r 0.04490253 mH 0.02817676 kcal mol^-1; Elst13,r 0.26623216 mH 0.16706",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:17108,Safety,recover,recover,17108,"ies (defined above),; they are composed of subsets of the individual terms printed above. The; individual terms are grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled ",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:12029,Testability,test,tested,12029,"asis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-trans",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:1564,Usability,simpl,simplest,1564,"T provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt-1.html:2417,Usability,simpl,simplest,2417,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4manual/4.0b2/sapt-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html
https://psicode.org/psi4manual/4.0b2/sapt.html:1521,Availability,avail,available,1521,"ithout computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pic",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2316,Availability,error,errors,2316,"pear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molec",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2464,Availability,avail,available,2464,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:4147,Availability,error,error,4147,"lation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are invo",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:7070,Availability,error,error,7070,"rds¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; fr",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:7089,Availability,error,error,7089,"rds¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; fr",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:16444,Availability,avail,available,16444," -0.47692549 mH -0.29927528 kcal mol^-1; Est. Disp22 (T) -0.54385253 mH -0.34127263 kcal mol^-1; Exch-Disp20 0.64545652 mH 0.40503010 kcal mol^-1; Exch-Disp30 -0.01823411 mH -0.01144207 kcal mol^-1; Ind-Disp30 -0.91816995 mH -0.57616037 kcal mol^-1; Exch-Ind-Disp30 0.76459013 mH 0.47978757 kcal mol^-1. Total HF -5.68662366 mH -3.56841037 kcal mol^-1; Total SAPT0 -8.58408823 mH -5.38659691 kcal mol^-1; Total SAPT2 -6.72339084 mH -4.21899163 kcal mol^-1; Total SAPT2+ -7.26739725 mH -4.56036082 kcal mol^-1; Total SAPT2+(3) -6.94156528 mH -4.35589816 kcal mol^-1; Total SAPT2+3 -7.11337921 mH -4.46371303 kcal mol^-1. At the bottom of this output are the total SAPT energies (defined above),; they are composed of subsets of the individual terms printed above. The; individual terms are grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:17108,Availability,recover,recover,17108,"ies (defined above),; they are composed of subsets of the individual terms printed above. The; individual terms are grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:18365,Deployability,update,updated,18365," as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled Cluster Methods; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:342,Energy Efficiency,adapt,adapted,342,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:494,Energy Efficiency,energy,energy,494,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:543,Energy Efficiency,energy,energy,543,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:640,Energy Efficiency,energy,energy,640,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:1120,Energy Efficiency,energy,energy,1120,"|. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, a",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2059,Energy Efficiency,energy,energy,2059,"is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monom",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2337,Energy Efficiency,energy,energy,2337,"pear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molec",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2849,Energy Efficiency,energy,energy,2849,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2866,Energy Efficiency,energy,energy,2866,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2883,Energy Efficiency,energy,energy,2883,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2901,Energy Efficiency,energy,energy,2901,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2922,Energy Efficiency,energy,energy,2922,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:5674,Energy Efficiency,energy,energy,5674,"pe: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:6683,Energy Efficiency,energy,energy,6683,"rgy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition perform",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:7136,Energy Efficiency,energy,energy,7136,"rds¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; fr",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:7332,Energy Efficiency,efficient,efficient,7332," Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities c",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:9679,Energy Efficiency,energy,energy,9679,"r SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:11015,Energy Efficiency,energy,energy,11015," the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. MP2 Natural Orbitals¶; One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of the triples; contribution to disperison. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promi",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12137,Energy Efficiency,energy,energy,12137,"ications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 m",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12165,Energy Efficiency,charge,charge-transfer,12165,"ications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 m",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12218,Energy Efficiency,charge,charge-transfer,12218,"trolling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12234,Energy Efficiency,energy,energy,12234,"trolling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12413,Energy Efficiency,energy,energy,12413,"bution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-c",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12431,Energy Efficiency,energy,energy,12431,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12451,Energy Efficiency,energy,energy,12451,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12471,Energy Efficiency,energy,energy,12471,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12492,Energy Efficiency,energy,energy,12492,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12516,Energy Efficiency,energy,energy,12516,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12545,Energy Efficiency,charge,charge-transfer,12545,"the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.6",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12903,Energy Efficiency,charge,charge-transfer,12903,"racy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS option will compute MP2 natural orbi",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:13847,Energy Efficiency,energy,energy,13847,"basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------; Electrostatics -13.06429805 mH -8.19797114 kcal mol^-1; Elst10,r -13.37543274 mH -8.39321111 kcal mol^-1; Elst12,r 0.04490253 mH 0.02817676 kcal mol^-1; Elst13,r 0.26623216 mH 0.16706321 kcal mol^-1. Exchange 13.41793548 mH 8.41988199 kcal mol^-1; Exch10 11.21823471 mH 7.03954885 kcal mol^-1; Exch10(S^2) 11.13803867 mH 6.98922508 kcal mol^-1; Exch11(S^2) 0.04558910 mH 0.02860760 kcal mol^-1; Exch12(S^2) 2.15411167 mH 1.35172554 kcal mol^-1. Induction -3.91333155 mH -2.45565272 kcal mol^-1; Ind20,r -4.57531220 mH -2.87105187 kcal mol^-1; Ind30,r -4.91715479 mH -3",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:17202,Energy Efficiency,energy,energy,17202,"re grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled Cluster Methods; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:342,Modifiability,adapt,adapted,342,"﻿. Symmetry-Adapted Perturbation Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Symmetry-Adapted Perturbation Theory¶; Code author: Edward G. Hohenstein; Section author: Edward G. Hohenstein; Module: Keywords, PSI Variables, LIBSAPT_SOLVER; Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:1808,Performance,perform,performance,1808," interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. en",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2451,Performance,perform,perform,2451,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:3398,Performance,perform,performing,3398,"ng is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 bas",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:3653,Performance,perform,performed,3653,"62503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:3867,Performance,perform,perform,3867," energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Def",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:4107,Performance,perform,performance,4107,"lation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are invo",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:4348,Performance,perform,perform,4348," of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommend",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:4442,Performance,scalab,scalable,4442," of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommend",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:7514,Performance,perform,performed,7514," Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:7670,Performance,perform,performed,7670,"e induction energy is not going to be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of key",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:8016,Performance,perform,perform,8016,"NATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis st",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:8472,Performance,perform,performed,8472,"pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard set",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:8594,Performance,optimiz,optimized,8594,"d for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this requirement; computations on the adenine-thymine complex can be performed with an; aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12575,Performance,perform,perform,12575,"the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.6",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12776,Performance,perform,performs,12776," orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:13447,Performance,perform,performed,13447," energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------; Electrostatics -13.06429805 mH -8.19797114 kcal mol^-1; Elst10,r -13.37543274 mH -8.39321111 kcal mol^-1; Elst12,r 0.04490253 mH 0.02817676 kcal mol^-1; Elst13,r 0.26623216 mH 0.16706",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:17108,Safety,recover,recover,17108,"ies (defined above),; they are composed of subsets of the individual terms printed above. The; individual terms are grouped according to the component of the interaction; to which they contribute. The total component energies (i.e.,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings; used in PSI4 as a “chemist’s grouping” as opposed to a more; mathematically based grouping, which would group all exchange terms; (i.e. , , etc. in; the exchange component. A final note is that both Disp22(T); and Est.Disp22(T) results appear if MP2 natural orbitals are; used to evaluate the triples correction to dispersion. The Disp22(T); result is the triples correction as computed in the truncated NO basis;; Est.Disp22(T) is a scaled result that attempts to recover; the effect of the truncated virtual space. The Est.Disp22(T); value used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]; for details). Table Of Contents. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; NO_RESPONSE; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; SAPT_OS_SCALE; SAPT_SS_SCALE; DEBUG. Higher-Order SAPT; Basic Keywords for Higher-order SAPT; BASIS; DF_BASIS_SAPT; FREEZE_CORE; PRINT. Advanced Keywords for Higher-order SAPT; INTS_TOLERANCE; SAPT_MEM_CHECK; DEBUG. MP2 Natural Orbitals; Basic Keywords Controlling MP2 NO Approximations; NAT_ORBS; OCC_TOLERANCE. Advanced Keywords Controlling MP2 NO Approximations; NAT_ORBS_T2. Charge-Transfer in SAPT; Interpreting SAPT Results. Previous topic; Ab Initio Polarization Propagator; Next topic; Coupled ",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:12029,Testability,test,tested,12029,"asis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-trans",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:1564,Usability,simpl,simplest,1564,"T provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/sapt.html:2417,Usability,simpl,simplest,2417,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4manual/4.0b2/sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:2456,Availability,error,error,2456,".00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often re",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:2863,Availability,avail,available,2863,"71e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock w",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:3099,Availability,avail,available,3099," -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; ele",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:10540,Availability,toler,tolerance,10540,"s the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 14",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:12797,Availability,avail,available,12797,"ergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry c",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:13625,Availability,checkpoint,checkpoint,13625," metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overla",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:14811,Availability,error,error,14811,"ent molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; S",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:15246,Availability,failure,failure,15246,"bility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iter",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:15847,Availability,down,down,15847," orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:16920,Availability,avail,available,16920,"This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:17130,Availability,error,error,17130,"” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:17166,Availability,avail,available,17166,"” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:19566,Availability,avail,available,19566,"ible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:20640,Deployability,update,updated,20640,"s). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:729,Energy Efficiency,efficient,efficient,729,"﻿. Hartree–Fock Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:1052,Energy Efficiency,energy,energy,1052,"ation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-0",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:2187,Energy Efficiency,energy,energy,2187,"ectron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and vir",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:2287,Energy Efficiency,energy,energy,2287," the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Mole",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:2534,Energy Efficiency,energy,energy,2534,"4195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational pa",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:4001,Energy Efficiency,energy,energy,4001,"rformed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization o",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:4137,Energy Efficiency,energy,energy,4137,"erties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:5180,Energy Efficiency,energy,energy,5180,"ergy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flex",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:5233,Energy Efficiency,energy,energy,5233,"ck matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavef",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:5377,Energy Efficiency,energy,energy,5377," found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:5806,Energy Efficiency,efficient,efficient,5806,"sistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unres",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:6999,Energy Efficiency,charge,charge,6999,"als are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC opti",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:8250,Energy Efficiency,energy,energy,8250,"elian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerica",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:10077,Energy Efficiency,adapt,adapted,10077,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:10661,Energy Efficiency,energy,energy,10661,"RANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:11406,Energy Efficiency,adapt,adapted,11406,"metry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be not",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:12198,Energy Efficiency,energy,energy,12198,"---------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals a",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:14110,Energy Efficiency,energy,energy,14110," of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. I",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:14196,Energy Efficiency,efficient,efficient,14196,"e spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:14464,Energy Efficiency,energy,energy,14464,"y-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbit",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:16247,Energy Efficiency,energy,energy,16247,"developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:16305,Energy Efficiency,energy,energy,16305," partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exa",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:17241,Energy Efficiency,reduce,reduce,17241,"ns with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:17462,Energy Efficiency,reduce,reduce,17462,"gh care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:17588,Energy Efficiency,reduce,reduce,17588,"m adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set th",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:18762,Energy Efficiency,power,powerful,18762," enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:20120,Energy Efficiency,energy,energy,20120,"s). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:3438,Integrability,contract,contracted,3438,"e error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the ge",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:4621,Integrability,depend,depends,4621," orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular sp",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:2784,Modifiability,enhance,enhanced,2784,"71e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock w",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:9269,Modifiability,enhance,enhanced,9269," 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:10077,Modifiability,adapt,adapted,10077,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:11406,Modifiability,adapt,adapted,11406,"metry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be not",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:18558,Modifiability,extend,extended,18558,"-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:18749,Modifiability,flexible,flexible,18749," enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:3005,Performance,perform,performed,3005,"3841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamilt",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:3348,Performance,optimiz,optimized,3348,"ional due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. H",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:7472,Performance,perform,performance,7472,"utput file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basi",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:13225,Performance,perform,performed,13225,"change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:14257,Performance,perform,performing,14257," the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure,",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:15394,Performance,optimiz,optimized,15394,".0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM c",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:17358,Performance,bottleneck,bottleneck,17358,"escue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT au",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:17925,Performance,optimiz,optimized,17925,"e terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:19341,Performance,perform,performing,19341,"ither absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algor",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:19844,Performance,optimiz,optimized,19844,"s). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:6477,Safety,avoid,avoid,6477,"orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:9120,Safety,avoid,avoided,9120," 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs ",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:3678,Usability,simpl,simplest,3678," high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbita",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:13461,Usability,simpl,simple,13461,"ften requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf-1.html:19260,Usability,simpl,simple,19260,"ither absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algor",MatchSource.WIKI,psi4manual/4.0b2/scf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html
https://psicode.org/psi4manual/4.0b2/scf.html:2456,Availability,error,error,2456,".00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often re",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:2863,Availability,avail,available,2863,"71e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock w",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:3099,Availability,avail,available,3099," -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; ele",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:10540,Availability,toler,tolerance,10540,"s the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 14",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:12797,Availability,avail,available,12797,"ergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry c",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:13625,Availability,checkpoint,checkpoint,13625," metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overla",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:14811,Availability,error,error,14811,"ent molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; S",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:15246,Availability,failure,failure,15246,"bility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iter",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:15847,Availability,down,down,15847," orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:16920,Availability,avail,available,16920,"This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:17130,Availability,error,error,17130,"” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:17166,Availability,avail,available,17166,"” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:19566,Availability,avail,available,19566,"ible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:20640,Deployability,update,updated,20640,"s). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:729,Energy Efficiency,efficient,efficient,729,"﻿. Hartree–Fock Theory — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:1052,Energy Efficiency,energy,energy,1052,"ation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-0",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:2187,Energy Efficiency,energy,energy,2187,"ectron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and vir",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:2287,Energy Efficiency,energy,energy,2287," the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Mole",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:2534,Energy Efficiency,energy,energy,2534,"4195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational pa",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:4001,Energy Efficiency,energy,energy,4001,"rformed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization o",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:4137,Energy Efficiency,energy,energy,4137,"erties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:5180,Energy Efficiency,energy,energy,5180,"ergy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flex",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:5233,Energy Efficiency,energy,energy,5233,"ck matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavef",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:5377,Energy Efficiency,energy,energy,5377," found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:5806,Energy Efficiency,efficient,efficient,5806,"sistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unres",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:6999,Energy Efficiency,charge,charge,6999,"als are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC opti",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:8250,Energy Efficiency,energy,energy,8250,"elian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerica",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:10077,Energy Efficiency,adapt,adapted,10077,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:10661,Energy Efficiency,energy,energy,10661,"RANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:11406,Energy Efficiency,adapt,adapted,11406,"metry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be not",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:12198,Energy Efficiency,energy,energy,12198,"---------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals a",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:14110,Energy Efficiency,energy,energy,14110," of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. I",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:14196,Energy Efficiency,efficient,efficient,14196,"e spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:14464,Energy Efficiency,energy,energy,14464,"y-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbit",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:16247,Energy Efficiency,energy,energy,16247,"developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:16305,Energy Efficiency,energy,energy,16305," partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exa",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:17241,Energy Efficiency,reduce,reduce,17241,"ns with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:17462,Energy Efficiency,reduce,reduce,17462,"gh care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:17588,Energy Efficiency,reduce,reduce,17588,"m adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set th",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:18762,Energy Efficiency,power,powerful,18762," enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:20120,Energy Efficiency,energy,energy,20120,"s). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:3438,Integrability,contract,contracted,3438,"e error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the ge",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:4621,Integrability,depend,depends,4621," orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular sp",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:2784,Modifiability,enhance,enhanced,2784,"71e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock w",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:9269,Modifiability,enhance,enhanced,9269," 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:10077,Modifiability,adapt,adapted,10077,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:11406,Modifiability,adapt,adapted,11406,"metry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be not",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:18558,Modifiability,extend,extended,18558,"-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:18749,Modifiability,flexible,flexible,18749," enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:3005,Performance,perform,performed,3005,"3841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamilt",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:3348,Performance,optimiz,optimized,3348,"ional due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. H",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:7472,Performance,perform,performance,7472,"utput file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basi",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:13225,Performance,perform,performed,13225,"change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:14257,Performance,perform,performing,14257," the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure,",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:15394,Performance,optimiz,optimized,15394,".0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM c",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:17358,Performance,bottleneck,bottleneck,17358,"escue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT au",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:17925,Performance,optimiz,optimized,17925,"e terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:19341,Performance,perform,performing,19341,"ither absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algor",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:19844,Performance,optimiz,optimized,19844,"s). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:6477,Safety,avoid,avoid,6477,"orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:9120,Safety,avoid,avoided,9120," 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs ",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:3678,Usability,simpl,simplest,3678," high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbita",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:13461,Usability,simpl,simple,13461,"ften requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/scf.html:19260,Usability,simpl,simple,19260,"ither absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algor",MatchSource.WIKI,psi4manual/4.0b2/scf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf.html
https://psicode.org/psi4manual/4.0b2/search.html:498,Deployability,update,updated,498,"﻿. Search — PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2] » . Search. Please activate JavaScript to enable the search; functionality.; . From here you can search these documents. Enter your search; words into the box below and click ""search"". Note that the search; function will automatically search for all of the words. Pages; containing fewer words won't appear in the result list.; . Navigation. index. modules |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/search.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/search.html
