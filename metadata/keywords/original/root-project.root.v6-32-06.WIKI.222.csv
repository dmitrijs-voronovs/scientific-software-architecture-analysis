id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html532/TF2.html:15411,Availability,error,errors,15411,"Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidSetNpy(Int_t npy = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:22897,Availability,error,errors,22897,"er of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParMax[fNpar] Array of upper limits of the fNpar parameters; Double_t*TF1::fParMin[fNpar] Array of lower limits of the fNpar parameters; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TObject*TF1::fParent!Parent object hooking this function (if one); TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; Double_t*TF1::fSave[fNsave] Array of fNsave function values; TStringTNamed::fTitleobject title; Int_tTF1::fType(=0 for standard functions, 1 if pointer to function); Double_tTF1::fXmaxUpper bounds for the range; Double_tTF1::fXminLower bounds for the range; Double_tfYmaxUpper bound for the range in y; Double_tfYminLower bound for the range in y; static Bool_tTF1::fgAbsValueuse absolute value of function when computing integral; static TF1*TF1::fgCurrentpointer to current function being processed; static Bool_tTF1::fgRejectPointTrue if point must be rejected in a fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TF2(); F2 default constructor*-*-*-*-*-*-; *-* ======================. TF2(const char* name, const char* formula, Double_t xmin = 0, Double_t xmax = 1, Double_t ymin = 0, Double_t ymax = 1); F2 constructor using a formula definition. See TFormula constructor for explanation of the formula syntax. if formula has the form ""fffffff;xxxx;yyyy"", it is assum",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:30489,Deployability,integrat,integrated,30489,"um on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, Minuit minimization is used with starting values found by the grid search. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape*-; *-* ====================================================; -. void GetRandom2(Double_t& xrandom, Double_t& yrandom); Return 2 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF2 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the two random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function*-*-; *-* ==============================. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:21015,Integrability,wrap,wrap,21015," kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDfContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plot",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:30489,Integrability,integrat,integrated,30489,"um on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, Minuit minimization is used with starting values found by the grid search. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape*-; *-* ====================================================; -. void GetRandom2(Double_t& xrandom, Double_t& yrandom); Return 2 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF2 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the two random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function*-*-; *-* ==============================. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:2642,Modifiability,variab,variable,2642,"static voidTF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0e-11); virtual Double_tTF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); virtual Double_tCentralMoment2(Double_t nx, Double_t ax, Double_t bx, Double_t ny, Double_t ay, Double_t by, Double_t epsilon = 0.000001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f2) const; virtual Double_tCovariance2XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual TH1*CreateHistogram(); virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidDrawF2(const char* formula, Double_t xmi",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:22578,Modifiability,variab,variables,22578,"la::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tfNpyNumber of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the ",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:20352,Performance,cache,cache,20352,al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDfContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TOb,MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:21860,Performance,optimiz,optimization,21860,"la::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tfNpyNumber of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the ",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:29490,Performance,perform,performed,29490,"-* of an existing picture, specify option ""SL""; -; *. void DrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); -*-*Draw formula between xmin,ymin and xmax,ymax; *-* ============================================; -. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F2 is clicked with the locator; -; *. Int_t GetContour(Double_t* levels = 0); Return contour values into array levels*-*-; *-* =======================================; -; *-* The number of contour levels can be returned by getContourLevel; -; *. Double_t GetContourLevel(Int_t level) const; Return the number of contour levels*-*-*-*-*-; *-* ===================================. void GetMinimumXY(Double_t& x, Double_t& y); return the X and Y values corresponding to the minimum value of the function; To find the minimum on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, Minuit minimization is used with starting values found by the grid search. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape*-; *-* ====================================================; -. void GetRandom2(Double_t& xrandom, Double_t& yrandom); Return 2 random numbers following this function shape; *-* ============================",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:5622,Testability,log,logx,5622,"e_tTF1::GetChisquare() const; virtual Int_tGetContour(Double_t* levels = 0); virtual Double_tGetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() cons",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:5769,Testability,log,logx,5769,"Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:5955,Testability,log,logx,5955,"Fill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors(",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:6102,Testability,log,logx,6102," Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = ",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2.html:8021,Testability,log,logx,8021,"::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tGetYmax() const; virtual Double_tGetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsil = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsil = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by",MatchSource.WIKI,root/html532/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2.html
https://root.cern/root/html532/TF2GL.html:2068,Performance,cache,cached,2068,"obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html532/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2GL.html
https://root.cern/root/html532/TF2GL.html:830,Testability,log,logx,830," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() cons",MatchSource.WIKI,root/html532/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2GL.html
https://root.cern/root/html532/TF2GL.html:843,Testability,log,logy,843," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() cons",MatchSource.WIKI,root/html532/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2GL.html
https://root.cern/root/html532/TF2GL.html:856,Testability,log,logz,856," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() cons",MatchSource.WIKI,root/html532/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF2GL.html
https://root.cern/root/html532/TF3.html:4778,Availability,error,error,4778,"x, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*TF2::DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidTF2::DrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* = ""al""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTF1::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tTF1::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; virtual Int_tTF2::GetContour(Double_t* levels = 0); virtual Double_tTF2::GetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinear",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:4862,Availability,error,error,4862,"s() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*TF2::DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidTF2::DrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* = ""al""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTF1::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tTF1::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; virtual Int_tTF2::GetContour(Double_t* levels = 0); virtual Double_tTF2::GetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLin",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:16991,Availability,error,error,16991,"::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTF2::SetNpy(Int_t npy = 100)MENU ; virtual voidSetNpz(Int_t npz = 30); virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax)MENU ; virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual ",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:17045,Availability,error,errors,17045,"oidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTF2::SetNpy(Int_t npy = 100)MENU ; virtual voidSetNpz(Int_t npz = 30); virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax)MENU ; virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:25029,Availability,error,errors,25029,"entation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParMax[fNpar] Array of upper limits of the fNpar parameters; Double_t*TF1::fParMin[fNpar] Array of lower limits of the fNpar parameters; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TObject*TF1::fParent!Parent object hooking this function (if one); TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; Double_t*TF1::fSave[fNsave] Array of fNsave function values; TStringTNamed::fTitleobject title; Int_tTF1::fType(=0 for standard functions, 1 if pointer to function); Double_tTF1::fXmaxUpper bounds for the range; Double_tTF1::fXminLower bounds for the range; Double_tTF2::fYmaxUpper bound for the range in y; Double_tTF2::fYminLower bound for the range in y; Double_tfZmaxUpper bound for the range in z; Double_tfZminLower bound for the range in z; static Bool_tTF1::fgAbsValueuse absolute value of function when computing integral; static TF1*TF1::fgCurrentpointer to current function being processed; static Bool_tTF1::fgRejectPointTrue if point must be rejected in a fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TF3(); F3 default constructor*-*-*-*-*-*-; *-* ======================. TF3(const char* name, const char* formula, Double_t xmin = 0, Double_t xmax = 1, Double_t ymin = 0, Double_t ymax = 1, Double_t zmin = 0, Double_t zmax = 1); F3 constructor using a formula definition*-*-*-*-; *-* ====================",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:31275,Deployability,integrat,integrated,31275,"============================. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F3 is clicked with the locator; -; *. void GetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); Return the X, Y and Z values corresponding to the minimum value of the function; on its range. To find the minimum on a subrange, use the SetRange() function first.; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided; into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; Then, Minuit minimization is used with starting values found by the grid search. void GetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); Return 3 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF3 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the three random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy * fNpz points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_t GetSave(const Double_t* x); Get value corresponding to X in array of fSave values. Double_t Integral(Double_t ax, Double_t bx, D",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:23069,Integrability,wrap,wrap,23069,"FunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDTF2::fContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for pl",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:31275,Integrability,integrat,integrated,31275,"============================. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F3 is clicked with the locator; -; *. void GetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); Return the X, Y and Z values corresponding to the minimum value of the function; on its range. To find the minimum on a subrange, use the SetRange() function first.; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided; into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; Then, Minuit minimization is used with starting values found by the grid search. void GetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); Return 3 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF3 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the three random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy * fNpz points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_t GetSave(const Double_t* x); Get value corresponding to X in array of fSave values. Double_t Integral(Double_t ax, Double_t bx, D",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:3213,Modifiability,variab,variable,3213,"*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f3) const; virtual Double_tTF2::Covariance2XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual Double_tCovariance3XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 0.000001); virtual Double_tCovariance3XZ(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 0.000001); virtual Double_tCovariance3YZ(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 0.000001); virtual TH1*CreateHistogram(); virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*TF2::DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidTF2::DrawF2(const char* formula, Do",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:24710,Modifiability,variab,variables,24710,"o make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF2::fNpyNumber of points along y used for the graphical representation; Int_tfNpzNumber of points along z used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fP",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:22401,Performance,cache,cache,22401,al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDTF2::fContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width,MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:23914,Performance,optimiz,optimization,23914,"o make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF2::fNpyNumber of points along y used for the graphical representation; Int_tfNpzNumber of points along z used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fP",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:30695,Performance,perform,performed,30695,"-* ========================. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*Compute distance from point px,py to a function; *-* ===============================================; *-* Compute the closest distance of approach from point px,py to this function.; *-* The distance is computed in pixels units.; -; *-* Algorithm:; -; -; *. void Draw(Option_t* option = """"); -*-*-*-*-*-*Draw this function with its current attributes; *-* ==============================================. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F3 is clicked with the locator; -; *. void GetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); Return the X, Y and Z values corresponding to the minimum value of the function; on its range. To find the minimum on a subrange, use the SetRange() function first.; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided; into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; Then, Minuit minimization is used with starting values found by the grid search. void GetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); Return 3 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF3 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the three random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy * fNpz points.; *-* If the function has sharp p",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:6213,Testability,log,logx,6213,"tChisquare() const; virtual Int_tTF2::GetContour(Double_t* levels = 0); virtual Double_tTF2::GetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF2::GetObjectInfo(Int_t ",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:6360,Testability,log,logx,6360,"Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF2::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFo",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:6546,Testability,log,logx,6546,"Fill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF2::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetP",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:6693,Testability,log,logx,6693,,MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TF3.html:8810,Testability,log,logx,8810," q, const Double_t* probSum); virtual Double_tTF2::GetRandom(); virtual Double_tTF2::GetRandom(Double_t xmin, Double_t xmax); virtual voidTF2::GetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tTF2::GetYmax() const; virtual Double_tTF2::GetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tGetZmax() const; virtual Double_tGetZmin() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual Double_tIntegral(Double_t",MatchSource.WIKI,root/html532/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TF3.html
https://root.cern/root/html532/TFcnAdapter.html:306,Integrability,interface,interface,306,". TFcnAdapter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » TFcnAdapter. class TFcnAdapter: public ROOT::Minuit2::FCNGradientBase. Adapt the interface used in TMinuit (and the TVirtualFitter) for; passing the objective function in a Minuit2 interface; (ROOT::Minuit2::FCNGradientBase or ROOT::Minuit2::FCNBase). Function Members (Methods); public:. TFcnAdapter(void (*)(int&, double*, double&, double*, int) fcn); TFcnAdapter(const TFcnAdapter&); virtual~TFcnAdapter(); const ROOT::Minuit2::FCNBase&Base() const; virtual boolROOT::Minuit2::FCNGradientBase::CheckGradient() const; static TClass*Class(); virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual vector<double>Gradient(const vector<double>&) const; virtual TClass*IsA() const; virtual doubleoperator()(const vector<double>&) const; doubleoperator()(int npar, double* params, int iflag = 4) const; TFcnAdapter&operator=(const TFcnAdapter&); virtual voidSetErrorDef(double up); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleUp() const. Data Members; private:. void (*)(int&, double*, double&, double*, int)fFCN; vector<double>fGradCache; doublefUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFcnAdapter(void (*fcn)(int&, double*, double&, double*, int)); {}. virtual ~TFcnAdapter(); {}. double operator()(const vector<double>& ) const. double Up() const; {return fUp; }. void SetErrorDef(double up); { fUp = up; }. std::vector<double> Gradient(const vector<double>& ) const. double operator()(int npar, double* params, int iflag = 4) const; forward interface. » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFcnAdapter.h 20880 2007-11-19 11:23:41Z rdm $ » Last gene",MatchSource.WIKI,root/html532/TFcnAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFcnAdapter.html
https://root.cern/root/html532/TFcnAdapter.html:406,Integrability,interface,interface,406,". TFcnAdapter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » TFcnAdapter. class TFcnAdapter: public ROOT::Minuit2::FCNGradientBase. Adapt the interface used in TMinuit (and the TVirtualFitter) for; passing the objective function in a Minuit2 interface; (ROOT::Minuit2::FCNGradientBase or ROOT::Minuit2::FCNBase). Function Members (Methods); public:. TFcnAdapter(void (*)(int&, double*, double&, double*, int) fcn); TFcnAdapter(const TFcnAdapter&); virtual~TFcnAdapter(); const ROOT::Minuit2::FCNBase&Base() const; virtual boolROOT::Minuit2::FCNGradientBase::CheckGradient() const; static TClass*Class(); virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual vector<double>Gradient(const vector<double>&) const; virtual TClass*IsA() const; virtual doubleoperator()(const vector<double>&) const; doubleoperator()(int npar, double* params, int iflag = 4) const; TFcnAdapter&operator=(const TFcnAdapter&); virtual voidSetErrorDef(double up); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleUp() const. Data Members; private:. void (*)(int&, double*, double&, double*, int)fFCN; vector<double>fGradCache; doublefUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFcnAdapter(void (*fcn)(int&, double*, double&, double*, int)); {}. virtual ~TFcnAdapter(); {}. double operator()(const vector<double>& ) const. double Up() const; {return fUp; }. void SetErrorDef(double up); { fUp = up; }. std::vector<double> Gradient(const vector<double>& ) const. double operator()(int npar, double* params, int iflag = 4) const; forward interface. » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFcnAdapter.h 20880 2007-11-19 11:23:41Z rdm $ » Last gene",MatchSource.WIKI,root/html532/TFcnAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFcnAdapter.html
https://root.cern/root/html532/TFcnAdapter.html:1817,Integrability,interface,interface,1817,"s; class charts. ROOT; » MATH; » MINUIT2; » TFcnAdapter. class TFcnAdapter: public ROOT::Minuit2::FCNGradientBase. Adapt the interface used in TMinuit (and the TVirtualFitter) for; passing the objective function in a Minuit2 interface; (ROOT::Minuit2::FCNGradientBase or ROOT::Minuit2::FCNBase). Function Members (Methods); public:. TFcnAdapter(void (*)(int&, double*, double&, double*, int) fcn); TFcnAdapter(const TFcnAdapter&); virtual~TFcnAdapter(); const ROOT::Minuit2::FCNBase&Base() const; virtual boolROOT::Minuit2::FCNGradientBase::CheckGradient() const; static TClass*Class(); virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual vector<double>Gradient(const vector<double>&) const; virtual TClass*IsA() const; virtual doubleoperator()(const vector<double>&) const; doubleoperator()(int npar, double* params, int iflag = 4) const; TFcnAdapter&operator=(const TFcnAdapter&); virtual voidSetErrorDef(double up); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual doubleUp() const. Data Members; private:. void (*)(int&, double*, double&, double*, int)fFCN; vector<double>fGradCache; doublefUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFcnAdapter(void (*fcn)(int&, double*, double&, double*, int)); {}. virtual ~TFcnAdapter(); {}. double operator()(const vector<double>& ) const. double Up() const; {return fUp; }. void SetErrorDef(double up); { fUp = up; }. std::vector<double> Gradient(const vector<double>& ) const. double operator()(int npar, double* params, int iflag = 4) const; forward interface. » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFcnAdapter.h 20880 2007-11-19 11:23:41Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFcnAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFcnAdapter.html
https://root.cern/root/html532/TFeldmanCousins.html:2602,Availability,error,error,2602,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCL() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLowerLimit() const; Double_tGetMuMax() const; Double_tGetMuMin() const; Double_tGetMuStep() const; virtual const char*TObject::GetName() const; Double_tGetNbackground() const; Double_tGetNMax() const; Double_tGetNobserved() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Doub",MatchSource.WIKI,root/html532/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFeldmanCousins.html
https://root.cern/root/html532/TFeldmanCousins.html:2686,Availability,error,error,2686,"owser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCL() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLowerLimit() const; Double_tGetMuMax() const; Double_tGetMuMin() const; Double_tGetMuStep() const; virtual const char*TObject::GetName() const; Double_tGetNbackground() const; Double_tGetNMax() const; Double_tGetNobserved() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetUpperLimit() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtua",MatchSource.WIKI,root/html532/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFeldmanCousins.html
https://root.cern/root/html532/TFeldmanCousins.html:882,Integrability,depend,depending,882,". TFeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TFeldmanCousins. class TFeldmanCousins: public TObject. TFeldmanCousins. class to calculate the CL upper limit using; the Feldman-Cousins method as described in PRD V57 #7, p3873-3889. The default confidence interval calvculated using this method is 90%; This is set either by having a default the constructor, or using the; appropriate fraction when instantiating an object of this class (e.g. 0.9). The simple extension to a gaussian resolution function bounded at zero; has not been addressed as yet -> `time is of the essence' as they write; on the wall of the maze in that classic game ... VARIABLES THAT CAN BE ALTERED. => depending on your desired precision: The intial values of fMuMin,; fMuMax, fMuStep and fNMax are those used in the PRD:; fMuMin = 0.0; fMuMax = 50.0; fMuStep= 0.005; but there is total flexibility in changing this should you desire. see example of use in $ROOTSYS/tutorials/math/FeldmanCousins.C. see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Author: Adrian Bevan, Liverpool University. Copyright Liverpool University 2001 bevan@slac.stanford.edu. Function Members (Methods); public:. TFeldmanCousins(const TFeldmanCousins&); TFeldmanCousins(Double_t newCL = 0.9, TString options = """"); virtual~TFeldmanCousins(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* ne",MatchSource.WIKI,root/html532/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFeldmanCousins.html
https://root.cern/root/html532/TFeldmanCousins.html:658,Usability,simpl,simple,658,". TFeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TFeldmanCousins. class TFeldmanCousins: public TObject. TFeldmanCousins. class to calculate the CL upper limit using; the Feldman-Cousins method as described in PRD V57 #7, p3873-3889. The default confidence interval calvculated using this method is 90%; This is set either by having a default the constructor, or using the; appropriate fraction when instantiating an object of this class (e.g. 0.9). The simple extension to a gaussian resolution function bounded at zero; has not been addressed as yet -> `time is of the essence' as they write; on the wall of the maze in that classic game ... VARIABLES THAT CAN BE ALTERED. => depending on your desired precision: The intial values of fMuMin,; fMuMax, fMuStep and fNMax are those used in the PRD:; fMuMin = 0.0; fMuMax = 50.0; fMuStep= 0.005; but there is total flexibility in changing this should you desire. see example of use in $ROOTSYS/tutorials/math/FeldmanCousins.C. see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Author: Adrian Bevan, Liverpool University. Copyright Liverpool University 2001 bevan@slac.stanford.edu. Function Members (Methods); public:. TFeldmanCousins(const TFeldmanCousins&); TFeldmanCousins(Double_t newCL = 0.9, TString options = """"); virtual~TFeldmanCousins(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* ne",MatchSource.WIKI,root/html532/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFeldmanCousins.html
https://root.cern/root/html532/TFFTComplex.html:2628,Availability,error,error,2628,"; TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t",MatchSource.WIKI,root/html532/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplex.html
https://root.cern/root/html532/TFFTComplex.html:2712,Availability,error,error,2712," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_",MatchSource.WIKI,root/html532/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplex.html
https://root.cern/root/html532/TFFTComplex.html:747,Energy Efficiency,allocate,allocate,747,". TFFTComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplex. class TFFTComplex: public TVirtualFFT. TFFTComplex; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; Computes complex input/output discrete Fourier transforms (DFT); in one or more dimensions. For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointComplex() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags or sign, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTComplex(); TFFTComplex(const TFFTComplex&); TFFTComplex(Int_t n, Bool_t inPlace); TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TOb",MatchSource.WIKI,root/html532/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplex.html
https://root.cern/root/html532/TFFTComplex.html:322,Integrability,interface,interface,322,". TFFTComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplex. class TFFTComplex: public TVirtualFFT. TFFTComplex; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; Computes complex input/output discrete Fourier transforms (DFT); in one or more dimensions. For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointComplex() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags or sign, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTComplex(); TFFTComplex(const TFFTComplex&); TFFTComplex(Int_t n, Bool_t inPlace); TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TOb",MatchSource.WIKI,root/html532/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplex.html
https://root.cern/root/html532/TFFTComplex.html:428,Integrability,interface,interface,428,". TFFTComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplex. class TFFTComplex: public TVirtualFFT. TFFTComplex; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; Computes complex input/output discrete Fourier transforms (DFT); in one or more dimensions. For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointComplex() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags or sign, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTComplex(); TFFTComplex(const TFFTComplex&); TFFTComplex(Int_t n, Bool_t inPlace); TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TOb",MatchSource.WIKI,root/html532/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplex.html
https://root.cern/root/html532/TFFTComplex.html:9806,Integrability,depend,depending,9806,"ex(); default. TFFTComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidim. transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. ~TFFTComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t sign, const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 2nd parameter: +1; Argument kind is dummy and doesn't need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output(or input) into the argument array. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; returns real and imaginary parts of the point #ipoint. void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns real and imaginary parts of the point #ipoint. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Copies real and imaginary parts of",MatchSource.WIKI,root/html532/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplex.html
https://root.cern/root/html532/TFFTComplex.html:9532,Performance,perform,performance,9532,"ex(); default. TFFTComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidim. transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. ~TFFTComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t sign, const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 2nd parameter: +1; Argument kind is dummy and doesn't need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output(or input) into the argument array. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; returns real and imaginary parts of the point #ipoint. void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns real and imaginary parts of the point #ipoint. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Copies real and imaginary parts of",MatchSource.WIKI,root/html532/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplex.html
https://root.cern/root/html532/TFFTComplexReal.html:596,Availability,redundant,redundant,596,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:2770,Availability,error,error,2770,"); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:2854,Availability,error,error,2854," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:764,Energy Efficiency,allocate,allocate,764,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:338,Integrability,interface,interface,338,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:444,Integrability,interface,interface,444,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:9910,Integrability,depend,depending,9910,"ion; TFFTComplexReal(); default. TFFTComplexReal(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTComplexReal(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument array with the computed transform; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). void GetPointComplex(Int_t",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:9637,Performance,perform,performanc,9637,"ion; TFFTComplexReal(); default. TFFTComplexReal(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTComplexReal(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument array with the computed transform; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). void GetPointComplex(Int_t",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:596,Safety,redund,redundant,596,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTComplexReal.html:616,Testability,log,logically,616,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html532/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTComplexReal.html
https://root.cern/root/html532/TFFTReal.html:3154,Availability,error,error,3154,"FALSE); TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im,",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTReal.html:3238,Availability,error,error,3238," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(Int_t ipoint, Double_",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTReal.html:10433,Availability,avail,available,10433,"e sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. Returns point #ipoint. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; For multidim.transforms. Returns point #ipoint. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Only for input of HC2R and output of R2HC. void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Only for input of HC2R and output of R2HC and for 1d. Double_t* GetPointsReal(",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTReal.html:965,Energy Efficiency,allocate,allocate,965,"a members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->DST-I; DST-II<-->DST-III; DST-IV<-->DST-IV. Function Members (Methods); public:. TFFTReal(); TFFTReal(const TFFTReal&); TFFTReal(Int_t n, Bool_t inPlace = kFALSE); TFFTReal(Int_t ndim, Int_t* n,",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTReal.html:310,Integrability,interface,interface,310,". TFFTReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTReal.html:416,Integrability,interface,interface,416,". TFFTReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTReal.html:10115,Integrability,depend,depending,10115,"ault transformer; static TVirtualFFT*TVirtualFFT::fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFFTReal(); default. TFFTReal(Int_t n, Bool_t inPlace = kFALSE); For 1d transforms; n here is the physical size of the transform (see FFTW manual for more details). TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidimensional transforms; 1st parameter is the # of dimensions,; 2nd is the sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. ",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTReal.html:9841,Performance,perform,performance,9841,"ault transformer; static TVirtualFFT*TVirtualFFT::fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFFTReal(); default. TFFTReal(Int_t n, Bool_t inPlace = kFALSE); For 1d transforms; n here is the physical size of the transform (see FFTW manual for more details). TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidimensional transforms; 1st parameter is the # of dimensions,; 2nd is the sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. ",MatchSource.WIKI,root/html532/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTReal.html
https://root.cern/root/html532/TFFTRealComplex.html:2728,Availability,error,error,2728,"); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:2812,Availability,error,error,2812," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:825,Energy Efficiency,allocate,allocate,825,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTRealComplex(); TFFTRealComplex(const TFFTRealComplex&); TFFTRealComplex(Int_t n, Bool_t inPlace); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; vi",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:338,Integrability,interface,interface,338,". TFFTRealComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTRealComplex(); TFFTRealComplex(const TFFTRealComplex&); TFFTRealComplex(Int_t n, Bool_t inPlace); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual co",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:444,Integrability,interface,interface,444,". TFFTRealComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTRealComplex(); TFFTRealComplex(const TFFTRealComplex&); TFFTRealComplex(Int_t n, Bool_t inPlace); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual co",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:9868,Integrability,depend,depending,9868,"ion; TFFTRealComplex(); default. TFFTRealComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTRealComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the array data with the computed transform.; Only (roughly) a half of the transform is copied (exactly the output of FFTW),; the rest being Hermitian symmetric with the first half. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the ",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:11437,Integrability,interface,interface,11437,"al part of the point #ipoint from the output or the point #ipoint; from the input. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Returns the point #ipoint.; For 1d, if ipoint > fN/2+1 (the point is in the Hermitian symmetric part), it is still; returned. For >1d, only the first (roughly)half of points can be returned; For 2d, see function GetPointComplex(Int_t *ipoint,...). void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint.; In case of transforms of more than 2 dimensions,; only points from the first (roughly)half are returned, the rest being Hermitian symmetric. Double_t* GetPointsReal(Bool_t fromInput = kFALSE) const; Returns the input array// One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void GetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void SetPoint(Int_t ipoint, Double_t re, Double_t im = 0); Set the point #ipoint. void SetPoint(const Int_t* ipoint, Double_t re, Double_t im = 0); For multidimensional transforms. Set the point #ipoint. void SetPoints(const Double_t* data); Set all input points. void SetPointComplex(Int_t ipoint, TComplex& c)",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:11543,Integrability,interface,interface,11543," ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Returns the point #ipoint.; For 1d, if ipoint > fN/2+1 (the point is in the Hermitian symmetric part), it is still; returned. For >1d, only the first (roughly)half of points can be returned; For 2d, see function GetPointComplex(Int_t *ipoint,...). void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint.; In case of transforms of more than 2 dimensions,; only points from the first (roughly)half are returned, the rest being Hermitian symmetric. Double_t* GetPointsReal(Bool_t fromInput = kFALSE) const; Returns the input array// One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void GetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void SetPoint(Int_t ipoint, Double_t re, Double_t im = 0); Set the point #ipoint. void SetPoint(const Int_t* ipoint, Double_t re, Double_t im = 0); For multidimensional transforms. Set the point #ipoint. void SetPoints(const Double_t* data); Set all input points. void SetPointComplex(Int_t ipoint, TComplex& c); Sets the point #ipoint (only the real part of the argument is taken). void SetPointsComplex(const Double_t* re, cons",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFFTRealComplex.html:9595,Performance,perform,performanc,9595,"ion; TFFTRealComplex(); default. TFFTRealComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTRealComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the array data with the computed transform.; Only (roughly) a half of the transform is copied (exactly the output of FFTW),; the rest being Hermitian symmetric with the first half. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the ",MatchSource.WIKI,root/html532/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFFTRealComplex.html
https://root.cern/root/html532/TFile.html:4931,Availability,error,error,4931,"obj, const char* name, Int_t bufsize); virtual TKey*CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*GetArchive() const; Long64_tGetArchiveOffset() const; static TFile::EAsyncOpenStatusGetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusGetAsyncOpenStatus(TFileOpenHandle* handle); Int_tGetBestBuffer() const",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:5015,Availability,error,error,5015,"nst void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*GetArchive() const; Long64_tGetArchiveOffset() const; static TFile::EAsyncOpenStatusGetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusGetAsyncOpenStatus(TFileOpenHandle* handle); Int_tGetBestBuffer() const; virtual Int_tTDirectoryFile::GetBufferSize() const; virtual Long64_tGetBytesRead()",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:27463,Availability,recover,recovery,27463,"ttings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject* obj, const c",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:30034,Availability,error,error,30034,"cle = """"); Delete object namecycle.; Namecycle identifies an object in the top directory of the file; namecycle has the format name;cycle; name = * means all; cycle = * means all cycles (memory and keys); cycle = """" or cycle = 9999 ==> apply to a memory object; When name=* use T* to delete subdirectories also. Examples:; foo : delete object named foo in memory; foo;1 : delete cycle 1 of foo on file; foo;* : delete all cycles of foo on disk and also from memory; *;2 : delete all objects on file having the cycle 2; *;* : delete all objects from memory and file; T*;* : delete all objects from memory and file and all subdirectories. void Draw(Option_t* option = """"); Fill Graphics Structure and Paint.; Loop on all objects (memory or file) and all subdirectories. void DrawMap(const char* keys = ""*"", Option_t* option = """"); Draw map of objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read t",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:34657,Availability,failure,failure,34657,"574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:34968,Availability,failure,failure,34968,"At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The funct",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:35317,Availability,failure,failure,35317,"50443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new di",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:35911,Availability,recover,recover,35911," low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is impor",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36005,Availability,recover,recovered,36005,"_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::Auto",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36035,Availability,recover,recovered,36035,"f blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36290,Availability,recover,recover,36290,"tc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootr",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36436,Availability,recover,recovered,36436," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36686,Availability,recover,recovered,36686," single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which ca",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36789,Availability,recover,recovered,36789,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36861,Availability,recover,recovered,36861," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:37021,Availability,recover,recovered,37021,"covered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetComp",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:37221,Availability,recover,recovery,37221,"fied.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:37673,Availability,failure,failure,37673,"ile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:41008,Availability,failure,failure,41008," 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested insi",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:42634,Availability,error,error,42634,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to gene",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:45181,Availability,error,error,45181," clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();.",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:45413,Availability,error,error,45413,"ating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the lo",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:46833,Availability,down,downloaded,46833,"le::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be c",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:46888,Availability,down,download,46888," may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before o",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:46950,Availability,down,downloaded,46950,"e; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; spe",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48334,Availability,error,error,48334,"e plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instanc",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48747,Availability,down,downloaded,48747,"e plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support as",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48802,Availability,down,download,48802,"r expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support asynchronous open functionality. Currently, only TXNetFile; ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48864,Availability,down,downloaded,48864,"; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support asynchronous open functionality. Currently, only TXNetFile; supports it. If the functionality is not implemented, this call ac",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:53766,Availability,avail,available,53766," = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EA",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36242,Deployability,update,update,36242,"tc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootr",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:42890,Deployability,update,update,42890,"tors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executa",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:45599,Deployability,update,updated,45599,"nly the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is save",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:34710,Integrability,rout,routine,34710,"At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShor",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36378,Integrability,message,message,36378,"ffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from R",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:42640,Integrability,message,message,42640,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to gene",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:47412,Integrability,depend,depends,47412,"id WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFi",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:51170,Integrability,interface,interface,51170," * Open(TFileOpenHandle* handle); Waits for the completion of an asynchronous open request.; Returns the associated TFile, transferring ownership of the; handle to the TFile instance. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open(). Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close(). Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read(). Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system lseek. All arguments like in POSIX lseek(); except that the offset and return value are of a type which are; able to handle 64 bit file systems. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). The function returns 0 in; case of success and 1 if the file could not be stat'ed. Int_t SysSync(Int_t fd); Interface to system fsync. All arguments like in POSIX fsync(). Long64_t GetBytesWritten() const; Return the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:53480,Integrability,depend,dependent,53480,"age/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:23715,Modifiability,plugin,plugin,23715,"s opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFile(); File default Constructor. TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:24676,Modifiability,plugin,plugins,24676,"he correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:24832,Modifiability,plugin,plugins,24832,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:27541,Modifiability,variab,variable,27541,"ttings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject* obj, const c",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:47261,Modifiability,plugin,plugin,47261,"Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is on",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:47313,Modifiability,plugin,plugin,47313,"Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is on",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:47338,Modifiability,plugin,plugin,47338,"Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is on",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:47762,Modifiability,plugin,plugin,47762,"en a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:13137,Performance,cache,cacheDir,13137,"TObject* obj, const char* keyname); virtual Int_tRecover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bo",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:13257,Performance,cache,cache,13257,"ual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static v",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:13308,Performance,cache,cache,13308,"nt_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtua",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:19261,Performance,cache,cache,19261,,MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:19326,Performance,cache,cache,19326,,MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:20895,Performance,cache,cache,20895," list of the streamer infos in this file; Bool_tfInitDone!True if the file has been initialized; Bool_tfIsArchive!True if this is a pure archive file; Bool_tfIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset cache; TList*fOpenPhases!Time info about open phases; TStringfOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritab",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:21150,Performance,cache,cache,21150," keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset cache; TList*fOpenPhases!Time info about open phases; TStringfOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:22432,Performance,cache,cache,22432,"GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tfgBytesReadNumber of bytes read by all TFile objects; static Long64_tfgBytesWriteNumber of bytes written by all TFile objects; static TStringfgCacheFileDirDirectory where to locally stage files; static Bool_tfgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tfgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tfgFileCounterCounter for all opened files; static Bool_tfgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:22462,Performance,cache,cached,22462,"GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tfgBytesReadNumber of bytes read by all TFile objects; static Long64_tfgBytesWriteNumber of bytes written by all TFile objects; static TStringfgCacheFileDirDirectory where to locally stage files; static Bool_tfgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tfgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tfgFileCounterCounter for all opened files; static Bool_tfgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:27277,Performance,perform,performed,27277,"press is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:29992,Performance,cache,cache,29992,"hat was a file. void Delete(const char* namecycle = """"); Delete object namecycle.; Namecycle identifies an object in the top directory of the file; namecycle has the format name;cycle; name = * means all; cycle = * means all cycles (memory and keys); cycle = """" or cycle = 9999 ==> apply to a memory object; When name=* use T* to delete subdirectories also. Examples:; foo : delete object named foo in memory; foo;1 : delete cycle 1 of foo on file; foo;* : delete all cycles of foo on disk and also from memory; *;2 : delete all objects on file having the cycle 2; *;* : delete all objects from memory and file; T*;* : delete all objects from memory and file and all subdirectories. void Draw(Option_t* option = """"); Fill Graphics Structure and Paint.; Loop on all objects (memory or file) and all subdirectories. void DrawMap(const char* keys = ""*"", Option_t* option = """"); Draw map of objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:30814,Performance,cache,cache,30814,"bdirectories. void DrawMap(const char* keys = ""*"", Option_t* option = """"); Draw map of objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TLi",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:30900,Performance,cache,cache,30900,"f objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this f",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:31728,Performance,cache,cached,31728," TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:34821,Performance,cache,cache,34821,"At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShor",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:35390,Performance,cache,cache,35390,":407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening t",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:35445,Performance,cache,cache,35445,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:35471,Performance,cache,cache,35471,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:35513,Performance,cache,cache,35513,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39321,Performance,cache,cache,39321,"ettings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this f",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39355,Performance,cache,cache,39355,"ettings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this f",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39411,Performance,cache,cache,39411,"ompression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the f",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39475,Performance,cache,cache,39475,"ompression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the f",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39508,Performance,cache,cache,39508,"ompression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the f",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39657,Performance,cache,cache,39657,"ssion level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The link",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39692,Performance,cache,cache,39692,"ssion level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The link",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:39735,Performance,cache,cache,39735,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:40082,Performance,cache,cache,40082,"ngs will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write v",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:40132,Performance,cache,cache,40132,"ngs will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write v",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:40178,Performance,cache,caches,40178,"ngs will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write v",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:41089,Performance,cache,cache,41089,"d compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qual",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:41109,Performance,cache,cache,41109,"ed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. F",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:41151,Performance,cache,cache,41151,"ed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. F",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:41193,Performance,cache,cache,41193,"ed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. F",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:44706,Performance,load,load,44706," generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:46068,Performance,load,loaded,46068,"ProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:46809,Performance,cache,cache,46809,"eamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""fi",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:46851,Performance,cache,cache,46851,"le::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be c",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48722,Performance,cache,cache,48722,"rned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, .",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48765,Performance,cache,cache,48765,"e plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support as",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:51774,Performance,cache,caches,51774,"buf, Int_t len); Interface to system write. All arguments like in POSIX write(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system lseek. All arguments like in POSIX lseek(); except that the offset and return value are of a type which are; able to handle 64 bit file systems. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). The function returns 0 in; case of success and 1 if the file could not be stat'ed. Int_t SysSync(Int_t fd); Interface to system fsync. All arguments like in POSIX fsync(). Long64_t GetBytesWritten() const; Return the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInte",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:52393,Performance,cache,cacheDir,52393,"eturn the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:52514,Performance,cache,cache,52514,"eturn the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:52662,Performance,cache,cache,52662,"n(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUr",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:52778,Performance,cache,cache,52778,"hat might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:52950,Performance,cache,cache,52950,"t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(c",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:54420,Performance,load,loading,54420,"UE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:54456,Performance,cache,cache,54456,"UE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:54566,Performance,cache,cache,54566,"ng on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListOfProcessIDs() const; {return fProcessIDs;}. TList * GetListOfFree() const; { return fFree",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:14195,Safety,timeout,timeout,14195,"eread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCache(Int_t maxCacheSize = 10, I",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:27008,Safety,detect,detect,27008," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:27242,Safety,detect,detected,27242,"press is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:27463,Safety,recover,recovery,27463,"ttings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject* obj, const c",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:35911,Safety,recover,recover,35911," low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is impor",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36005,Safety,recover,recovered,36005,"_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::Auto",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36035,Safety,recover,recovered,36035,"f blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36290,Safety,recover,recover,36290,"tc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootr",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36436,Safety,recover,recovered,36436," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36478,Safety,safe,safely,36478," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36686,Safety,recover,recovered,36686," single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which ca",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36789,Safety,recover,recovered,36789,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36861,Safety,recover,recovered,36861," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:37021,Safety,recover,recovered,37021,"covered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetComp",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:37221,Safety,recover,recovery,37221,"fied.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48468,Safety,timeout,timeout,48468,"equentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may b",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:48514,Safety,timeout,timeout,48514,"equentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may b",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:52996,Safety,timeout,timeout,52996,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Re",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:53016,Safety,timeout,timeout,53016,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Re",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:53055,Safety,timeout,timeout,53055,"sRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:53108,Safety,timeout,timeout,53108,"bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:23708,Security,access,access,23708,"s opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFile(); File default Constructor. TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:24096,Security,access,access,24096,"har* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:24175,Security,access,access,24175,"har* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:24669,Security,access,access,24669,"he correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:24825,Security,access,access,24825,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:24852,Security,access,access,24852,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:31999,Security,access,access,31999,"len); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:37357,Security,access,access,37357," gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:27348,Testability,log,logical,27348,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:31027,Testability,log,logical,31027," cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:31468,Testability,log,logical,31468,"eviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:33044,Testability,log,logical,33044,"st();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of a file sequentially.; For each logical record found, it prints:; Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor. Example of output; 20010404/150437 At:64 N=150 TFile; 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 20010404/150441 At:155364 N=29594 TBasket CX = 1.08; 20010404/150441 At:184958 N=29616 TBasket CX = 1.08; 20010404/150441 At:214574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 2",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36565,Testability,test,test,36565,"st.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36763,Testability,test,test,36763,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36459,Usability,usab,usable,36459," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:36538,Usability,usab,usable,36538,"st.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFile.html:44170,Usability,clear,clear,44170,"ootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is give",MatchSource.WIKI,root/html532/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFile.html
https://root.cern/root/html532/TFileCacheRead.html:1998,Availability,error,error,1998,"actMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtual TFilePrefetch*GetPrefetchObj(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char**, Long64_t, Int_t, Bool_t*); virtual Bool_tTObject::HandleTimer(TTimer* timer",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:2082,Availability,error,error,2082,"); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtual TFilePrefetch*GetPrefetchObj(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char**, Long64_t, Int_t, Bool_t*); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:9343,Availability,error,error,9343,"e. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:318,Performance,cache,cache,318,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:476,Performance,cache,cache,476,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:508,Performance,cache,cache,508,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:639,Performance,cache,cache,639,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:8650,Performance,cache,cache,8650,"fPrefetchedBlocksNumber of blocks prefetched.; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base functi",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:8961,Performance,cache,cache,8961,"uffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be pre",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:9038,Performance,cache,cache,9038,"ed (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers ",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:9367,Performance,cache,cache,9367,"e. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:9394,Performance,cache,cache,9394,"e. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:9863,Performance,cache,cache,9863,"head = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize() const; { return fBufferSize; }. Int_t GetUnzipBuffer(char** , Long64_t , Int_t , Bool_t* ); { return -1; }. Long64_t GetPrefetchedBlocks() const; { return fPrefetchedBlocks; }. Bool_t IsAsyncReading() const; { return fAsyncReading; }. void SetEnablePrefetching(Bool_t setPrefetching = kFALSE); { fEnablePrefetching = setPrefetching; }. Bool_t IsEnablePrefetchin",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:592,Safety,avoid,avoiding,592,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheRead.html:9774,Safety,avoid,avoid,9774,"tes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize() const; { return fBufferSize; }. Int_t GetUnzipBuffer(char** , Long64_t , Int_t , Bool_t* ); { return -1; }. Long64_t GetPrefetchedBlocks() const; { return fPrefetchedBlocks; }. Bool_t IsAsyncReading() const; { return fAsyncReading; }. void SetEnablePrefetching(Bool_t setPrefetch",MatchSource.WIKI,root/html532/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheRead.html
https://root.cern/root/html532/TFileCacheWrite.html:1883,Availability,error,error,1883,"eWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tFlush(); virtual Int_tGetBytesInCache() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:1967,Availability,error,error,1967," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tFlush(); virtual Int_tGetBytesInCache() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObje",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6681,Availability,error,error,6681,"tusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:7279,Availability,error,error,7279,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:322,Performance,cache,cache,322,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:480,Performance,cache,cache,480,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:512,Performance,cache,cache,512,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:644,Performance,cache,cache,644,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:753,Performance,cache,cache,753,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6078,Performance,cache,cached,6078,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6187,Performance,cache,cache,6187,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6426,Performance,cache,cache,6426,"evel, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCach",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6476,Performance,cache,cache,6476,"t::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const;",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6834,Performance,cache,cache,6834,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6892,Performance,cache,cache,6892,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6939,Performance,cache,cache,6939,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:7337,Performance,cache,cache,7337,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:596,Safety,avoid,avoiding,596,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCacheWrite.html:6117,Safety,avoid,avoid,6117,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html532/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCacheWrite.html
https://root.cern/root/html532/TFileCollection.html:1847,Availability,error,error,1847,"Int_tAdd(const char* path); Int_tAddFromFile(const char* file, Int_t nfiles = -1, Int_t firstfile = 1); Bool_tAddMetaData(TObject* meta); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TObjString*ExportInfo(const char* name = 0, Int_t popt = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0, Bool_t curronly = kFALSE); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGe",MatchSource.WIKI,root/html532/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCollection.html
https://root.cern/root/html532/TFileCollection.html:1931,Availability,error,error,1931,"t_t firstfile = 1); Bool_tAddMetaData(TObject* meta); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TObjString*ExportInfo(const char* name = 0, Int_t popt = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0, Bool_t curronly = kFALSE); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGetNStagedFiles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const",MatchSource.WIKI,root/html532/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCollection.html
https://root.cern/root/html532/TFileCollection.html:9056,Availability,error,error,9056,"he specified text file.; The file should contain one url per line; empty lines or lines starting with '#'; (commented lines) are ignored.; If nfiles > 0 only nfiles files are added, starting from file 'firstfile' (>= 1).; The method returns the number of added files. Int_t Add(const char* path); Add all files matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines). void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f)",MatchSource.WIKI,root/html532/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCollection.html
https://root.cern/root/html532/TFileCollection.html:9277,Availability,avail,available,9277,"ile' (>= 1).; The method returns the number of added files. Int_t Add(const char* path); Add all files matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines). void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for all TFileInfos. void ResetBitAll(UInt_t f); Reset the bit for all TFileInfos. const char * GetDefaultTreeName() const; Returns the tree set with SetDefaultTreeName if set; Returns the name o",MatchSource.WIKI,root/html532/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCollection.html
https://root.cern/root/html532/TFileCollection.html:9410,Availability,failure,failure,9410,"uses all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines). void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for all TFileInfos. void ResetBitAll(UInt_t f); Reset the bit for all TFileInfos. const char * GetDefaultTreeName() const; Returns the tree set with SetDefaultTreeName if set; Returns the name of the first tree in the meta data list.; Returns 0 in case no trees are found in the meta data list. Long64_t GetTotalEntries(const char* tree) const; Returns the number of entries for the specified tree (retrieve",MatchSource.WIKI,root/html532/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCollection.html
https://root.cern/root/html532/TFileCollection.html:9294,Deployability,update,updates,9294,"iles matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines). void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for all TFileInfos. void ResetBitAll(UInt_t f); Reset the bit for all TFileInfos. const char * GetDefaultTreeName() const; Returns the tree set with SetDefaultTreeName if set; Returns the name of the first tree in the meta data list.; Returns 0 in case no trees are found in the meta data lis",MatchSource.WIKI,root/html532/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileCollection.html
https://root.cern/root/html532/TFileDrawMap.html:3623,Availability,error,error,3623,"(const char* method) const; virtual voidAnimateTree(const char* branches = """")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawObject()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpObject()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html532/TFileDrawMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileDrawMap.html
https://root.cern/root/html532/TFileDrawMap.html:3707,Availability,error,error,3707," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawObject()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpObject()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) ",MatchSource.WIKI,root/html532/TFileDrawMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileDrawMap.html
https://root.cern/root/html532/TFileHandler.html:430,Availability,mask,mask,430," TFileHandler(int fd, int mask); virtual~TFileHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal =",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:3749,Availability,error,error,3749,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); intGetFd() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObje",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:3833,Availability,error,error,3833,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); intGetFd() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:7405,Availability,mask,mask,7405,"ers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Bool_tReadNotify(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(); virtual voidTSysEvtHandler::Removed()SIGNAL ; voidTObject::ResetBit(UInt_t f); virtual voidResetReadyMask(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFd(int fd); virtual voidSetInterest(Int_t mask); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadReady(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWriteReady(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Bool_tWriteNotify().",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9333,Availability,mask,mask,9333,"ender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9413,Availability,mask,mask,9413,"ender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9741,Availability,mask,mask,9741,"der(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void Set",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9791,Availability,mask,mask,9791,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9859,Availability,mask,mask,9859,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9921,Availability,mask,mask,9921,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:10457,Availability,mask,mask,10457,"ess mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:10477,Availability,mask,mask,10477,"ess mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:10486,Availability,mask,mask,10486,"ess mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9819,Energy Efficiency,monitor,monitor,9819,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9880,Energy Efficiency,monitor,monitor,9880,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileHandler.html:9948,Energy Efficiency,monitor,monitor,9948,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html532/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileHandler.html
https://root.cern/root/html532/TFileInfo.html:1555,Availability,error,error,1555," voidTObject::AbstractMethod(const char* method) const; Bool_tAddMetaData(TObject* meta); Bool_tAddUrl(const char* url, Bool_t infront = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TUrl*FindByUrl(const char* url, Bool_t withDeflt = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TUrl*GetCurrentUrl() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TUrl*GetFirstUrl() const; virtual const char*TObject::GetIconName() const; TMD5*GetMD5() const; TFileInfoMeta*GetMetaData(const char* meta = 0) const; TList*GetMetaDataList() const; virtual const char*TNamed::GetName() const; Int_tGetNUrls() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const;",MatchSource.WIKI,root/html532/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileInfo.html
https://root.cern/root/html532/TFileInfo.html:1639,Availability,error,error,1639,"eta); Bool_tAddUrl(const char* url, Bool_t infront = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TUrl*FindByUrl(const char* url, Bool_t withDeflt = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TUrl*GetCurrentUrl() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TUrl*GetFirstUrl() const; virtual const char*TObject::GetIconName() const; TMD5*GetMD5() const; TFileInfoMeta*GetMetaData(const char* meta = 0) const; TList*GetMetaDataList() const; virtual const char*TNamed::GetName() const; Int_tGetNUrls() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() c",MatchSource.WIKI,root/html532/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileInfo.html
https://root.cern/root/html532/TFileInfo.html:6290,Security,access,access,6290,"arning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileInfo&operator=(const TFileInfo&); voidParseInput(const char* in). Data Members; public:. enum EStatusBits { kStaged; kCorrupted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TUrl*fCurrentUrl! current URL to access the file, points to URL; TMD5*fMD5-> md5 digest of the file; TList*fMetaDataListgeneric list of file meta data object(s); Long64_tfSizefile size; TUUID*fUUID-> uuid of the referenced file; TList*fUrlListlist of file URLs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileInfo(const char* url = 0, Long64_t size = -1, const char* uuid = 0, const char* md5 = 0, TObject* meta = 0); Constructor. TFileInfo(const TFileInfo& ); Copy constructor. ~TFileInfo(); Destructor. void ParseInput(const char* in); Parse the input line to extract init information from 'in'; the input; string is tokenized on ' '; the tokens can be prefixed by the following; keys:. url:<url1>,<url2>,... URLs for the file; stored in the order given; sz:<size> size of the file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the",MatchSource.WIKI,root/html532/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileInfo.html
https://root.cern/root/html532/TFileInfo.html:8121,Security,hash,hashed,8121," file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the entry range. obj:<name>,<class>,<entries>; meta-information about a generic object in the file;; the should be in the form <subdir>/obj-name; 'class'; is the object class; 'entries' is the number of occurences; for this object.; Multiple occurences of 'tree:' or 'obj:' can be specified.; The initializations done via the input string are superseeded by the ones by other; parameters in the constructor, if any.; If no key is given, the token is interpreted as URL(s). void SetUUID(const char* uuid); Set the UUID to the value associated to the string 'uuid'. This is; useful to set the UUID to the one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists; of these objects hashed on the name. Those lists need to be rebuild.; TFileCollection does that in RemoveDuplicates. TUrl * GetCurrentUrl() const; Return the current url. TUrl * NextUrl(); Iterator function, start iteration by calling ResetUrl().; The first call to NextUrl() will return the 1st element,; the seconde the 2nd element etc. Returns 0 in case no more urls. TUrl * FindByUrl(const char* url, Bool_t withDeflt = kFALSE); Find an element from a URL. Returns 0 if not found. Bool_t AddUrl(const char* url, Bool_t infront = kFALSE); Add a new URL. If 'infront' is TRUE the new url is pushed at the beginning; of the list; otherwise is pushed back.; Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrl(const char* url); Remove an URL. Returns kTRUE if successful, kFALSE otherwise. Bool_t SetCurrentUrl(const char* url); Set 'url' as current URL, if in the list; Return kFALSE if not in the list. Bool_t SetCurrentUrl(TUrl* url); Set 'url' as current URL, if i",MatchSource.WIKI,root/html532/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileInfo.html
https://root.cern/root/html532/TFileInfoMeta.html:1770,Availability,error,error,1770,"st = -1, Long64_t totbytes = -1, Long64_t zipbytes = -1); virtual~TFileInfoMeta(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TNamed::GetName() const; const char*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotBytes() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html532/TFileInfoMeta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileInfoMeta.html
https://root.cern/root/html532/TFileInfoMeta.html:1854,Availability,error,error,1854,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TNamed::GetName() const; const char*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotBytes() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetZipBytes() const; virtual Bool_tTObject::HandleTimer",MatchSource.WIKI,root/html532/TFileInfoMeta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileInfoMeta.html
https://root.cern/root/html532/TFileIter.html:1195,Availability,avail,available,1195," members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now loop over all objects in inverse order < -- \n"");; for( readObj = size-1; (int)readObj >= 0; --readObj); {; nextObject = *readObj;; if (nextObject) {; printf("" Object \""%s\"" of class \",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:10384,Modifiability,config,config,10384,"e that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t shift). { SkipObjects(shift); return *this;}. TFileIter & operator-=(Int_t shift). { return operator+=(-shift);}. TFileIter & operator++(). { SkipObjects( 1); return *this;}. TFileIter & operator--(). { SkipObjects(-1); return *this;}. TObject * operator*() const. { return GetObject();}. inline operator int",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:10503,Modifiability,config,config,10503,"is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t shift). { SkipObjects(shift); return *this;}. TFileIter & operator-=(Int_t shift). { return operator+=(-shift);}. TFileIter & operator++(). { SkipObjects( 1); return *this;}. TFileIter & operator--(). { SkipObjects(-1); return *this;}. TObject * operator*() const. { return GetObject();}. inline operator int() const. { return CurrentCursorPosition(); }. int operator==(const char* name) const. { return name ? !strcmp(name,GetK",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:7960,Safety,avoid,avoid,7960,", Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDirectory.; It is too costly and it can be abused. TObject * Next(Int_t nSkip); return the pointer to the object defined by next TKey; This method is not recommended. It was done for the sake; of the compatibility with TListIter. void PurgeKeys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator i",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:9578,Safety,avoid,avoid,9578,"Keys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator is not changed. nSkip > 0; iterator skips nSkip objects in the container.; the direction of the iteration is; sign(nSkip)*kIterForward. Returns: TKey that can be used to fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}.",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:562,Testability,test,tests,562,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:786,Testability,test,test,786,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:1130,Testability,test,test,1130,"hy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now loop over all objects in inverse order < -- \n"");; for( readObj = size",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:7259,Testability,assert,assert,7259," whether this classs creates TFile on its own to delete; TDirectory*fRootFileTDirectory/TFile to be iterated over; UInt_tfRunNumbercurrent ""run number""; Bool_tTListIter::fStartediteration started. private:. TFileIter*fNestedIterator! The inner TFidrectory interator;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileIter(TFile* file = 0); Create iterator over all objects from the TFile provided. TFileIter(TDirectory* directory); Create iterator over all objects from the TDirectory provided. TFileIter(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDi",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:10066,Testability,log,logical,10066,"o fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileIter.html:652,Usability,simpl,simple,652,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html532/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileIter.html
https://root.cern/root/html532/TFileMergeInfo.html:1368,Availability,down,down,1368,"fo. class TFileMergeInfo. TFileMergeInfo. This class helps passing information from the TFileMerger to; the objects being merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. TFileMergeInfo(TDirectory* outputfile); TFileMergeInfo(const TFileMergeInfo&); virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; TFileMergeInfo&operator=(const TFileMergeInfo&); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete fUserData; fUserData = 0; }. » Author: Philippe Canal May, 2011 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TFileMergeInfo.h 39495 2011-05-31 05:59:31Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMergeInfo.html
https://root.cern/root/html532/TFileMergeInfo.html:379,Security,access,access,379,". TFileMergeInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TFileMergeInfo. class TFileMergeInfo. TFileMergeInfo. This class helps passing information from the TFileMerger to; the objects being merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. TFileMergeInfo(TDirectory* outputfile); TFileMergeInfo(const TFileMergeInfo&); virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; TFileMergeInfo&operator=(const TFileMergeInfo&); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete fUserData; fUserData = 0; }. » Author: Philippe Canal May, 2011 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TFile",MatchSource.WIKI,root/html532/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMergeInfo.html
https://root.cern/root/html532/TFileMerger.html:1930,Availability,error,error,1930,"kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxOpenedFies() const; TList*GetMergeList() const; const char*GetMsgPrefix() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFile*GetOutputFile() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual ",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:2014,Availability,error,error,2014,"ool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxOpenedFies() const; TList*GetMergeList() const; const char*GetMsgPrefix() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFile*GetOutputFile() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasCompressionChange() const; virtu",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:10127,Availability,error,error,10127,"f the addition was successful. Bool_t OutputFile(const char* url, Bool_t force, Int_t compressionLevel); Open merger output file. Bool_t OutputFile(const char* url, Bool_t force); Open merger output file. Bool_t OutputFile(const char* url, const char* mode, Int_t compressionLevel); Open merger output file. 'mode' is passed to the TFile constructor as the option, it should; be one of 'NEW','CREATE','RECREATE','UPDATE'; 'UPDATE' is usually used in conjunction with IncrementalMerge. Bool_t OutputFile(const char* url, const char* mode = ""RECREATE""); Open merger output file. 'mode' is passed to the TFile constructor as the option, it should; be one of 'NEW','CREATE','RECREATE','UPDATE'; 'UPDATE' is usually used in conjunction with IncrementalMerge. void PrintFiles(Option_t* options); Print list of files being merged. Bool_t Merge(Bool_t = kTRUE); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error. Bool_t MergeRecursive(TDirectory* target, TList* sourcelist, Int_t type = kRegular|kAll); Merge all objects in a directory; The type is defined by the bit values in EPartialMergeType:; kRegular : normal merge, overwritting the output file (default); kIncremental : merge the input file with the (existing) content of the output file (if already exising); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function. Bool_t PartialMerge(Int_t type = kAll|kIncremental); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error.; The type is defined by the bit values in EPartialMergeType:; kRegular : normal merge, overwritting the output file; kIncremental : merge the input file with the content of the output file (i",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:10910,Availability,error,error,10910,"ions); Print list of files being merged. Bool_t Merge(Bool_t = kTRUE); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error. Bool_t MergeRecursive(TDirectory* target, TList* sourcelist, Int_t type = kRegular|kAll); Merge all objects in a directory; The type is defined by the bit values in EPartialMergeType:; kRegular : normal merge, overwritting the output file (default); kIncremental : merge the input file with the (existing) content of the output file (if already exising); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function. Bool_t PartialMerge(Int_t type = kAll|kIncremental); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error.; The type is defined by the bit values in EPartialMergeType:; kRegular : normal merge, overwritting the output file; kIncremental : merge the input file with the content of the output file (if already exising) (default); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function. If the type is set to kIncremental the output file is done deleted at the end of; this operation. If the type is not set to kIncremental, the output file is closed. Bool_t OpenExcessFiles(); Open up to fMaxOpenedFiles of the excess files. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. void SetMaxOpenedFiles(Int_t newmax); Set a limit to the number file that TFileMerger will opened at one time.; If the request is higher than the system limit, we reset it to the system limit.; If the request is less tha",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:588,Integrability,interface,interface,588,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* pa",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:7850,Integrability,message,message,7850,"sk; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfCompressionChangeTrue if the output and input have different compression level (default kFALSE); TList*fExcessFiles! List of TObjString containing the name of the files not yet added to fFileList due to user or system limitiation on the max number of files opened.; Bool_tfExplicitCompLevelTrue if the user explicitly requested a compressio level change (default kFALSE); Bool_tfFastMethodTrue if using Fast merging algorithm (default); TList*fFileLista list the file (TFile*) which shall be merged; Bool_tfHistoOneGoMerger histos in one go (default is kTRUE); Bool_tfLocalMakes local copies of merging files if True (default is kTRUE); Int_tfMaxOpenedFilesMaximum number of files opened at the same time by the TFileMerger.; TList*fMergeListlist of TObjString containing the name of the files need to be merged; TStringfMsgPrefixPrefix to be used when printing informational message (default TFileMerger); Bool_tfNoTreesTrue if Trees should not be merged (default is kFALSE); TFile*fOutputFilethe outputfile for merging; TStringfOutputFilenamethe name of the outputfile for merging; Int_tfPrintLevelHow much information to print out at run time.; TStopwatchfWatchstop watch to measure file copy speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); Create file merger object. ~TFileMerger(); Cleanup. void Reset(); Reset merger file list. Bool_t AddFile(const char* url, Bool_t cpProgress = kTRUE); Add file to file merger. Bool_t AddFile(TFile* source, Bool_t cpProgress = kTRUE); Add the TFile to this file merger and *do not* give ownership of the TFile to this; object. Return kTRUE if the addition was successful. Bool_t AddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); Add the TFile to this file merger and give ownership of the TFile to this; object (unless kFALSE is returned). Return kTRUE if the addition was ",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:12062,Integrability,message,message,12062,"e output file; kIncremental : merge the input file with the content of the output file (if already exising) (default); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function. If the type is set to kIncremental the output file is done deleted at the end of; this operation. If the type is not set to kIncremental, the output file is closed. Bool_t OpenExcessFiles(); Open up to fMaxOpenedFiles of the excess files. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. void SetMaxOpenedFiles(Int_t newmax); Set a limit to the number file that TFileMerger will opened at one time.; If the request is higher than the system limit, we reset it to the system limit.; If the request is less than two, we reset it to 2 (one for the output file and one for the input file). void SetMsgPrefix(const char* prefix); Set the prefix to be used when printing informational message. TFileMerger(const TFileMerger& ). TFileMerger& operator=(const TFileMerger& ). Int_t GetPrintLevel() const; { return fPrintLevel; }. void SetPrintLevel(Int_t level); { fPrintLevel = level; }. Bool_t HasCompressionChange() const; { return fCompressionChange; }. const char * GetOutputFileName() const; { return fOutputFilename; }. TList * GetMergeList() const; { return fMergeList; }. TFile * GetOutputFile() const; { return fOutputFile; }. Int_t GetMaxOpenedFies() const; { return fMaxOpenedFiles; }. const char * GetMsgPrefix() const; { return fMsgPrefix; }. Bool_t SetCWD(const char* ); --- file management interface. { MayNotUse(""SetCWD""); return kFALSE; }. const char * GetCWD(); { MayNotUse(""GetCWD""); return 0; }. void SetFastMethod(Bool_t fast = kTRUE); {fFastMethod = fast;}. void SetNotrees(Bool_t notrees = kFALSE); {fNoTrees = notrees;}. » Author: Andreas Peters + Fons Rademakers 26/5/2005 » Copyright (C) 1995-2005, Rene Brun and Fons ",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:12680,Integrability,interface,interface,12680,"t a MergeAfterReset member function. If the type is set to kIncremental the output file is done deleted at the end of; this operation. If the type is not set to kIncremental, the output file is closed. Bool_t OpenExcessFiles(); Open up to fMaxOpenedFiles of the excess files. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. void SetMaxOpenedFiles(Int_t newmax); Set a limit to the number file that TFileMerger will opened at one time.; If the request is higher than the system limit, we reset it to the system limit.; If the request is less than two, we reset it to 2 (one for the output file and one for the input file). void SetMsgPrefix(const char* prefix); Set the prefix to be used when printing informational message. TFileMerger(const TFileMerger& ). TFileMerger& operator=(const TFileMerger& ). Int_t GetPrintLevel() const; { return fPrintLevel; }. void SetPrintLevel(Int_t level); { fPrintLevel = level; }. Bool_t HasCompressionChange() const; { return fCompressionChange; }. const char * GetOutputFileName() const; { return fOutputFilename; }. TList * GetMergeList() const; { return fMergeList; }. TFile * GetOutputFile() const; { return fOutputFile; }. Int_t GetMaxOpenedFies() const; { return fMaxOpenedFiles; }. const char * GetMsgPrefix() const; { return fMsgPrefix; }. Bool_t SetCWD(const char* ); --- file management interface. { MayNotUse(""SetCWD""); return kFALSE; }. const char * GetCWD(); { MayNotUse(""GetCWD""); return 0; }. void SetFastMethod(Bool_t fast = kTRUE); {fFastMethod = fast;}. void SetNotrees(Bool_t notrees = kFALSE); {fNoTrees = notrees;}. » Author: Andreas Peters + Fons Rademakers 26/5/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFileMerger.h 41444 2011-10-18 09:36:59Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:453,Modifiability,plugin,plugins,453,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* pa",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:446,Security,access,access,446,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* pa",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFileMerger.html:534,Security,access,accessable,534,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* pa",MatchSource.WIKI,root/html532/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileMerger.html
https://root.cern/root/html532/TFilePrefetch.html:1585,Availability,error,error,1585," Bool_tBinarySearchReadList(TFPBlock*, Long64_t, Int_t, Int_t*); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckBlockInCache(char*&, TFPBlock*); Bool_tCheckCachePath(const char*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TFPBlock*CreateBlockObj(Long64_t*, Int_t*, Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMutex*GetMutexSynch() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObjec",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFilePrefetch.html:1669,Availability,error,error,1669,"::Browse(TBrowser* b); Bool_tCheckBlockInCache(char*&, TFPBlock*); Bool_tCheckCachePath(const char*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TFPBlock*CreateBlockObj(Long64_t*, Int_t*, Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMutex*GetMutexSynch() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFilePrefetch.html:6197,Performance,cache,cache,6197,"tual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static TThread::VoidRtnFunc_tThreadProc(void*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TThread*fConsumerconsumer thread; TFile*fFilereference to the file; TMutex*fMutexPendingListmutex for the pending list; TMutex*fMutexReadListmutex for the list of read blocks; TMutex*fMutexSynchmutex for synchronisation between working and main thread; TCondition*fNewBlockAddedcondition used to signal the addition of a new pending block; TStringfPathCachepath to the cache directory; TList*fPendingBlockslist of pending block to be read; TCondition*fReadBlockAddedcondition usd to signal the addition of a new red block; TList*fReadBlockslist of block read; TSemaphore*fSemsemaphore used to kill the consumer thread; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t )",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFilePrefetch.html:7985,Performance,cache,cache,7985,"sert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFilePrefetch.h 41698 2011-11-01 21:22:54Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFilePrefetch.html:8060,Performance,cache,cache,8060,"sert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFilePrefetch.h 41698 2011-11-01 21:22:54Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFilePrefetch.html:8128,Performance,cache,cache,8128,"sert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFilePrefetch.h 41698 2011-11-01 21:22:54Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFilePrefetch.html:8196,Performance,cache,cache,8196,"sert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFilePrefetch.h 41698 2011-11-01 21:22:54Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFilePrefetch.html:8259,Performance,cache,cache,8259,"sert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFilePrefetch.h 41698 2011-11-01 21:22:54Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html
https://root.cern/root/html532/TFileSet.html:2035,Availability,error,error,2035," virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() c",MatchSource.WIKI,root/html532/TFileSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileSet.html
https://root.cern/root/html532/TFileSet.html:2119,Availability,error,error,2119,"ataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainS",MatchSource.WIKI,root/html532/TFileSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileSet.html
https://root.cern/root/html532/TFileStager.html:1659,Availability,error,error,1659,"tager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringGetPathName(TObject* o); virtual TList*GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virt",MatchSource.WIKI,root/html532/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileStager.html
https://root.cern/root/html532/TFileStager.html:1743,Availability,error,error,1743,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringGetPathName(TObject* o); virtual TList*GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tT",MatchSource.WIKI,root/html532/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileStager.html
https://root.cern/root/html532/TFileStager.html:312,Integrability,interface,interface,312,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html532/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileStager.html
https://root.cern/root/html532/TFileStager.html:474,Modifiability,plug-in,plug-in,474,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html532/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileStager.html
https://root.cern/root/html532/TFileStager.html:6808,Modifiability,plugin,plugin,6808,"TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileStager(const char* stager); { }. virtual ~TFileStager(); { }. TList * GetStaged(TCollection* pathlist). Bool_t IsStaged(const char* ). Int_t Locate(const char* u, TString& f). Bool_t Matches(const char* s); { return ((s && (fName == s)) ? kTRUE : kFALSE); }. Bool_t Stage(const char* , Option_t* = 0); { return kTRUE; }. Bool_t Stage(TCollection* pathlist, Option_t* opt = 0). Bool_t IsValid() const; { return kTRUE; }. TString GetPathName(TObject* o); Extract the path name from supported object types. TFileStager * Open(const char* stager); --- Load desired plugin. » Author: A. Peters, G. Ganis 7/2/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TFileStager.h 23091 2008-04-09 15:04:27Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileStager.html
https://root.cern/root/html532/TFileStager.html:455,Performance,load,load,455,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html532/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileStager.html
https://root.cern/root/html532/TFileStager.html:539,Performance,load,load,539,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html532/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFileStager.html
https://root.cern/root/html532/TFitEditor.html:1420,Availability,error,error,1420,"pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weight",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:1960,Availability,robust,robust,1960,"nd shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw fun",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:2269,Availability,error,errors,2269,"implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; val",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:2412,Availability,error,error,2412,"ed string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desir",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:2522,Availability,error,error,2522,"ent; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages ",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:3745,Availability,avail,available,3745,"out deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQ",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:3798,Availability,avail,available,3798,"out deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQ",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:4038,Availability,toler,tolerance,4038,"draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignal",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:9266,Availability,error,error,9266,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillFunctionList(Int_t selected = -1); voidFillMinMethodList(Int_t selected = -1); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_t",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:9350,Availability,error,error,9350,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillFunctionList(Int_t selected = -1); voidFillMinMethodList(Int_t selected = -1); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelecte",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:24439,Availability,error,errors,24439,,MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:25205,Availability,robust,robust,25205,"CheckButton*fAdd2FuncListswitch on/off option 'add to list'; TGCheckButton*fAllWeights1switch on/off option 'all weights=1'; Pixel_tTGFrame::fBackgroundframe background color; TGCheckButton*fBestErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayout",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:25317,Availability,error,error,25317," weights=1'; Pixel_tTGFrame::fBackgroundframe background color; TGCheckButton*fBestErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayoutConvlayout hints of fConv radio button; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLayou",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:25398,Availability,mask,mask,25398,"estErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayoutConvlayout hints of fConv radio button; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLayoutHints*fLayoutNonelayout hints of fNone radio button; TGRadioButton*fLibFumiliset",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:28384,Availability,robust,robust,28384,,MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:29409,Availability,toler,tolerance,29409,GLabel*fSelLabelcontains selected fit function; TGTextButton*fSetParamopen set parameters dialog; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGDoubleHSlider*fSliderXslider to set fit range along x-axis; TGNumberEntry*fSliderXMaxentry to set the maximum in the range; TGNumberEntry*fSliderXMinentry to set the minumum in the range; TGHorizontalFrame*fSliderXParentparent of fSliderX; TGDoubleHSlider*fSliderYslider to set fit range along y-axis; TGNumberEntry*fSliderYMaxentry to set the maximum in the range; TGNumberEntry*fSliderYMinentry to set the minumum in the range; TGHorizontalFrame*fSliderYParentparent of fSliderY; TGDoubleHSlider*fSliderZslider to set fit range along z-axis; TGHorizontalFrame*fSliderZParentparent of fSliderZ; TGStatusBar*fStatusBarstatusbar widget; vector<TF1*>fSystemFuncsfunctions managed by the fitpanel; TGTab*fTabtab widget holding the editor; TGCompositeFrame*fTabContainermain tab container; TGNumberEntryField*fTolerancecontains tolerance set for minimization; EObjectTypefTypeobject type info; TGComboBox*fTypeFitcontains the types of functions to be selected; TGTextButton*fUpdateButtonupdates data from gROOT and gDirectory; TGCheckButton*fUseGradientswitch on/off option 'use gradient'; TGCheckButton*fUseRangeswitch on/off option 'use function range'; TGTextButton*fUserButtonopens a dialog for user-defined fit method; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; TAxis*f,MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:34679,Availability,robust,robust,34679,"ted to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void ProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); If the input is valid, insert the tree with the selections as an entry to fDataSet. void DoFunction(Int_t sel); Slot connected to predefined fit function settings. void DoEnteredFunction(); Slot connected to entered function in text entry. void DoLinearFit(); Slot connected to linear fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range settings on y-axis. void DoNumericSliderYChanged(); syncronize the numeric slider with the graphical one. void DoSliderZMoved(); Slot connected to range settings on z-axis. void DoUserDialog(); Open a dialog for getting a user defined method. void SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable fo",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:392,Integrability,interface,interface,392,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:1426,Integrability,message,message,1426,"pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weight",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:1677,Integrability,interface,interface,1677,"ation settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF ",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:33090,Integrability,depend,depending,33090,"eate 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doe",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:33201,Integrability,depend,depending,33201,"nect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:36506,Integrability,depend,depending,36506,"id SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable for fitting and set; its type, dimension and method combo box accordingly. void ShowObjectName(TObject* obj); Show object name on the top. Option_t * GetDrawOption() const; Get draw options of the selected object. void DoLibrary(Bool_t on); Set selected minimization library in use. void DoMinMethod(Int_t ); Set selected minimization method in use. void DoMaxIterations(); Set the maximum number of iterations. void MakeTitle(TGCompositeFrame* parent, const char* title); Create section title in the GUI. TF1* HasFitFunction(); Look in the list of function for TF1. If a TF1 is; found in the list of functions, it will be returned. void RetrieveOptions(Foption_t& , TString& , ROOT::Math::MinimizerOptions& , Int_t ); Retrieve the fitting options from all the widgets. void SetEditable(Bool_t ); Set the state of some input widgets depending on whether the fit; function can be defined by text or if it is an existing one. void GetRanges(ROOT::Fit::DataRange& ); Return the ranges selected by the sliders. TList* GetFitObjectListOfFunctions(); Get the list of functions previously used in the fitobject. void GetFunctionsFromSystem(); Looks for all the functions registered in the current ROOT; session. TList* GetListOfFittingFunctions(TObject* obj = 0); This function returns a TList with all the functions used in the; FitPanel to fit a given object. If the object passed is NULL,; then the object used is the currently selected one. It is; important to notice that the FitPanel is still the owner of; those functions. This means that the user SHOULD NOT delete any; of these functions, as the FitPanel will do so in the; destructor. TF1* GetFitFunction(); Get the fit function selected or declared in the fiteditor. TFitEditor(const TFitEditor& ). TFitEditor& operator=(const TFitEditor& ). » Author: Ilka Antcheva, Lorenzo Moneta, David Gon",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:23244,Modifiability,variab,variables,23244,"_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGComboBox*BuildMethodList(TGFrame* parent, Int_t id); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tCheckFunctionString(const char* str); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidCreateFunctionGroup(); voidCreateGeneralTab(); voidCreateMinimizationTab(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawSelection(bool restore = false); voidFillDataSetList(); TF1*FindFunction(); TF1*GetFitFunction(); TList*GetFitObjectListOfFunctions(); voidGetFunctionsFromSystem(); static Time_tTGFrame::GetLastClick(); TStringTGMainFrame::GetMWMfuncString() const; TStringTGMainFrame::GetMWMinpString() const; TStringTGMainFrame::GetMWMvalueString() const; TStringTGFrame::GetOptionString() const; voidGetRanges(ROOT::Fit::DataRange&); const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TF1*HasFitFunction(); voidMakeTitle(TGCompositeFrame* parent, const char* title); voidTObject::MakeZombie(); voidProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); virtual voidSetCanvas(TCanvas* c); virtual voidSetEditable(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TFitEditor(const TFitEditor&); TFitEditor&operator=(const TFitEditor&); voidRetrieveOptions(Foption_t&, TString&, ROOT::Math::Min",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:34253,Modifiability,variab,variables,34253," Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void ProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); If the input is valid, insert the tree with the selections as an entry to fDataSet. void DoFunction(Int_t sel); Slot connected to predefined fit function settings. void DoEnteredFunction(); Slot connected to entered function in text entry. void DoLinearFit(); Slot connected to linear fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:320,Performance,perform,perform,320,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:4297,Performance,perform,performs,4297,"the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidT",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:35588,Performance,perform,performed,35588,"near fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range settings on y-axis. void DoNumericSliderYChanged(); syncronize the numeric slider with the graphical one. void DoSliderZMoved(); Slot connected to range settings on z-axis. void DoUserDialog(); Open a dialog for getting a user defined method. void SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable for fitting and set; its type, dimension and method combo box accordingly. void ShowObjectName(TObject* obj); Show object name on the top. Option_t * GetDrawOption() const; Get draw options of the selected object. void DoLibrary(Bool_t on); Set selected minimization library in use. void DoMinMethod(Int_t ); Set selected minimization method in use. void DoMaxIterations(); Set the maximum number of iterations. void MakeTitle(TGCompositeFrame* parent, const char* title); Create section title in the GUI. TF1* HasFitFunction(); Look in the list of function for TF1. If a TF1 is; found in the list of functions, it will be returned. void RetrieveOptions(Foption_t& , TString& , ROOT::Math::MinimizerOptions& , Int_t ); Retrieve the fitting options from all the widgets. void SetEditable(Bool_t ); Set the state of some input widgets depending on whether the fit; function can be defined",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitEditor.html:32980,Usability,clear,clear,32980,"ion about the; function. void CreateGeneralTab(); Create 'General' tab. void CreateMinimizationTab(); Create 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to additi",MatchSource.WIKI,root/html532/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitEditor.html
https://root.cern/root/html532/TFitParametersDialog.html:4835,Availability,error,error,4835,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:4919,Availability,error,error,4919,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:19249,Availability,error,error,19249,,MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:19827,Availability,mask,mask,19827,,MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:21798,Availability,error,errors,21798,l_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKOK button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParBndbound setting switch; TGNumberEntryField**fParErrerror values; TGCheckButton**fParFixfix setting switch; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParStpstep values; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPstporiginal patameters' step; Double_t*fPvaloriginal patameters' values; Double_tfRangexmaxmax function range; Double_tfRangexminmin function range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Int_t*fRetCodeaddress to store return code; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateimmediate update switch; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGF,MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:8323,Deployability,update,update,8323,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:20242,Deployability,update,updated,20242,"of error values; TGCompositeFrame*fContFixcontainer of fix settings; TGCompositeFrame*fContMaxcontainer of max range values; TGCompositeFrame*fContMincontainer of min range values; TGCompositeFrame*fContNamcontainer of parameter names; TGCompositeFrame*fContSldcontainer of sliders; TGCompositeFrame*fContStpcontainer of step values; TGCompositeFrame*fContValcontainer of parameter values; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TVirtualPad*fFpadpad where the function is drawn; TF1*fFuncfunction passed to this dialog; Bool_tfHasChangeskTRUE if function was redrawn;; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfImmediateDrawkTRUE if function is updated on run-time; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawk",MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:22288,Deployability,update,update,22288,ton*fOKOK button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParBndbound setting switch; TGNumberEntryField**fParErrerror values; TGCheckButton**fParFixfix setting switch; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParStpstep values; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPstporiginal patameters' step; Double_t*fPvaloriginal patameters' values; Double_tfRangexmaxmax function range; Double_tfRangexminmin function range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Int_t*fRetCodeaddress to store return code; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateimmediate update switch; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame:,MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:24931,Deployability,update,update,24931,"ectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0); Create a dialog for fit function parameters' settings. ~TFitParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoParBound(Bool_t on); Slot related to the Bound check button. void DoParStep(); Slot related to parameter step setting. void DoParFix(Bool_t on); Slot related to the Fix check button. void SetParameters(); Set the parameter values inside the function. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void DrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. void DisconnectSlots(); Disconnect signals from slot methods. » Author: Ilka Antcheva, Lorenzo Moneta, David Gonzalez Maline 03/10/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id: TFitParametersDialog.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitParametersDialog.html:24958,Integrability,depend,dependent,24958,"ectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0); Create a dialog for fit function parameters' settings. ~TFitParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoParBound(Bool_t on); Slot related to the Bound check button. void DoParStep(); Slot related to parameter step setting. void DoParFix(Bool_t on); Slot related to the Fix check button. void SetParameters(); Set the parameter values inside the function. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void DrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. void DisconnectSlots(); Disconnect signals from slot methods. » Author: Ilka Antcheva, Lorenzo Moneta, David Gonzalez Maline 03/10/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id: TFitParametersDialog.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html
https://root.cern/root/html532/TFitResult.html:1742,Availability,error,error,1742,"irtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult",MatchSource.WIKI,root/html532/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResult.html
https://root.cern/root/html532/TFitResult.html:1826,Availability,error,error,1826," char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::FittedFunction() const; voidROOT::Fit::FitResult::GetConfidenceIntervals(const ROO",MatchSource.WIKI,root/html532/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResult.html
https://root.cern/root/html532/TFitResult.html:9904,Availability,error,errors,9904,"of limited parameters; doubleROOT::Fit::FitResult::fChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>ROOT::Fit::FitResult::fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intROOT::Fit::FitResult::fCovStatuscovariance matrix status code; doubleROOT::Fit::FitResult::fEdmexpected distance from mimimum; vector<double>ROOT::Fit::FitResult::fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>ROOT::Fit::FitResult::fFixedParamslist of fixed parameters; vector<double>ROOT::Fit::FitResult::fGlobalCCglobal Correlation coefficient; stringROOT::Fit::FitResult::fMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >ROOT::Fit::FitResult::fMinosErrorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym G",MatchSource.WIKI,root/html532/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResult.html
https://root.cern/root/html532/TFitResult.html:10268,Availability,error,errors,10268,"of limited parameters; doubleROOT::Fit::FitResult::fChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>ROOT::Fit::FitResult::fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intROOT::Fit::FitResult::fCovStatuscovariance matrix status code; doubleROOT::Fit::FitResult::fEdmexpected distance from mimimum; vector<double>ROOT::Fit::FitResult::fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>ROOT::Fit::FitResult::fFixedParamslist of fixed parameters; vector<double>ROOT::Fit::FitResult::fGlobalCCglobal Correlation coefficient; stringROOT::Fit::FitResult::fMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >ROOT::Fit::FitResult::fMinosErrorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym G",MatchSource.WIKI,root/html532/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResult.html
https://root.cern/root/html532/TFitResult.html:10902,Availability,error,errors,10902,"rorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym GetCovarianceMatrix() const; Return the covariance matrix from fit; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TMatrixDSym GetCorrelationMatrix() const; Return the correlation matrix from fit.; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TFitResult(int status = 0); Default constructor for I/O. TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult. {}. virtual ~TFitResult(); {}. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; »",MatchSource.WIKI,root/html532/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResult.html
https://root.cern/root/html532/TFitResult.html:10944,Availability,error,error,10944,"rorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym GetCovarianceMatrix() const; Return the covariance matrix from fit; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TMatrixDSym GetCorrelationMatrix() const; Return the correlation matrix from fit.; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TFitResult(int status = 0); Default constructor for I/O. TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult. {}. virtual ~TFitResult(); {}. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; »",MatchSource.WIKI,root/html532/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResult.html
https://root.cern/root/html532/TFitResultPtr.html:1341,Testability,assert,assert,1341,"sultPtr. class TFitResultPtr. Function Members (Methods); public:. TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs); virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class ; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id: TFitResultPtr.h 31262 2009-11-18 07:38:37Z brun $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitResultPtr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResultPtr.html
https://root.cern/root/html532/TFitResultPtr.html:1519,Testability,assert,assert,1519,"sultPtr. class TFitResultPtr. Function Members (Methods); public:. TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs); virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class ; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id: TFitResultPtr.h 31262 2009-11-18 07:38:37Z brun $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitResultPtr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitResultPtr.html
https://root.cern/root/html532/TFITSHDU.html:1654,Availability,error,error,1654,"); virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); Int_tGetColumnNumber(const char* colname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TString&GetKeywordValue(const char* keyword); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFITSHDU::HDURecord*GetRecord(const char* keyword); Int_tGetRecordNumber() const; Int_tGetTabNColumns() cons",MatchSource.WIKI,root/html532/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFITSHDU.html
https://root.cern/root/html532/TFITSHDU.html:1738,Availability,error,error,1738,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); Int_tGetColumnNumber(const char* colname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TString&GetKeywordValue(const char* keyword); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFITSHDU::HDURecord*GetRecord(const char* keyword); Int_tGetRecordNumber() const; Int_tGetTabNColumns() const; Int_tGetTabNRows() const; TVectorD*GetTabRealVectorCell(Int_t rownum, Int_t colnu",MatchSource.WIKI,root/html532/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFITSHDU.html
https://root.cern/root/html532/TFITSHDU.html:298,Integrability,interface,interface,298,". TFITSHDU. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » FITSIO; » TFITSHDU. class TFITSHDU: public TNamed. FITS file interface class; TFITS is a class that allows extracting images and data from FITS files and contains; several methods to manage them.; . Function Members (Methods); public:. TFITSHDU(const char* filepath_with_filter); TFITSHDU(const TFITSHDU&); TFITSHDU(const char* filepath, Int_t extension_number); TFITSHDU(const char* filepath, const char* extension_name); virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html532/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFITSHDU.html
https://root.cern/root/html532/TFITSHDU.html:10959,Integrability,depend,depending,10959,"""T"" : print column information when HDU is a table; ""T+"" : print full table (columns header and rows). TImage * ReadAsImage(Int_t layer = 0, TImagePalette* pal = 0); Read image HDU as a displayable image. Return 0 if conversion cannot be done.; If the HDU seems to be a multilayer image, 'layer' parameter can be used; to retrieve the specified layer (starting from 0). void Draw(Option_t* opt = """"); If the HDU is an image, draw the first layer of the primary array; To set a title to the canvas, pass it in ""opt"". TMatrixD* ReadAsMatrix(Int_t layer = 0, Option_t* opt = """"); Read image HDU as a matrix. Return 0 if conversion cannot be done; If the HDU seems to be a multilayer image, 'layer' parameter can be used; to retrieve the specified layer (starting from 0) in matrix form.; Options (value of 'opt'):; ""S"": stretch pixel values to a range from 0.0 to 1.0. TH1 * ReadAsHistogram(); Read image HDU as a histogram. Return 0 if conversion cannot be done.; The returned object can be TH1D, TH2D or TH3D depending on data dimensionality.; Please, check condition (returnedValue->IsA() == TH*D::Class()) to; determine the object class.; NOTE: do not confuse with image histogram! This function interprets; the array as a histogram. It does not compute the histogram of pixel; values of an image! Here ""pixels"" are interpreted as number of entries. TVectorD* GetArrayRow(UInt_t row); Get a row from the image HDU when it's a 2D array. TVectorD* GetArrayColumn(UInt_t col); Get a column from the image HDU when it's a 2D array. Int_t GetColumnNumber(const char* colname); Get column number given its name. TObjArray* GetTabStringColumn(Int_t colnum); Get a string-typed column from a table HDU given its column index (>=0). TObjArray* GetTabStringColumn(const char* colname); Get a string-typed column from a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const ",MatchSource.WIKI,root/html532/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFITSHDU.html
https://root.cern/root/html532/TFITSHDU.html:13088,Security,access,access,13088,"ndex (>=0). TObjArray* GetTabStringColumn(const char* colname); Get a string-typed column from a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id: TFITS.h 38935 2011-04-19 20:38:15Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFITSHDU.html
https://root.cern/root/html532/TFitter.html:1344,Availability,error,error,1344,"r = 25); virtual~TFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceI",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:1428,Availability,error,error,1428,"t::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:12109,Availability,error,errors,12109," args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:12122,Availability,error,errors,12122," args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:12360,Availability,error,error,12360,"x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumber",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:13032,Availability,error,errors,13032," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:13095,Availability,error,error,13095," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:13117,Availability,error,error,13117," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:13143,Availability,error,error,13143," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:13409,Availability,error,error,13409,"al value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) co",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:13769,Availability,error,error,13769," * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Dou",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:15140,Availability,error,error,15140,"ouble_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:15521,Availability,error,error,15521,"if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for eac",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:15849,Availability,error,error,15849,"the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the P",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:16492,Availability,error,error,16492," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z r",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:17081,Availability,error,error,17081,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:14228,Modifiability,variab,variable,14228,"globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for t",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:9580,Performance,cache,cache,9580,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFit",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:15457,Performance,cache,cache,15457,"if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for eac",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:15782,Performance,cache,cache,15782,"the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the P",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:16428,Performance,cache,cache,16428," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z r",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:17014,Performance,cache,cache,17014,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:16249,Safety,predict,predict,16249,"rameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x ",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:16858,Safety,predict,predict,16858,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:10603,Testability,log,logs,10603,"eNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitter(Int_t maxpar = 25); default constructor*-*-; *-* ===================. ~TFitter(); default destructor*-*-*-; *-* ==================. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* option = """"); reset the fitter environment. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in o",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:14325,Testability,log,log,14325,"eturn the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag)",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:14347,Testability,log,log,14347,"eturn the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag)",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:14874,Testability,log,loglikelihood,14874,"alue for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content,",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:16321,Testability,log,logs,16321,"* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene ",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitter.html:16930,Testability,log,logs,16930,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitter.html
https://root.cern/root/html532/TFitterFumili.html:1414,Availability,error,error,1414,"» TFitterFumili. class TFitterFumili: public TFitterMinuit. Function Members (Methods); public:. TFitterFumili(); TFitterFumili(Int_t maxpar); TFitterFumili(const TFitterFumili&); virtual~TFitterFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFitterMinuit::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tTFitterMinuit::ExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidTFitterMinuit::FixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, ",MatchSource.WIKI,root/html532/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterFumili.html
https://root.cern/root/html532/TFitterFumili.html:1498,Availability,error,error,1498,"» TFitterFumili. class TFitterFumili: public TFitterMinuit. Function Members (Methods); public:. TFitterFumili(); TFitterFumili(Int_t maxpar); TFitterFumili(const TFitterFumili&); virtual~TFitterFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFitterMinuit::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tTFitterMinuit::ExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidTFitterMinuit::FixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, ",MatchSource.WIKI,root/html532/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterFumili.html
https://root.cern/root/html532/TFitterFumili.html:11931,Integrability,interface,interface,11931,"tringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMinimizerType ); virtual FunctionMinimum Minimize( int nfcn = 0, double edmval = 0.1) const;. void CreateChi2FCN(). void CreateChi2ExtendedFCN(). void CreateUnbinLikelihoodFCN(); {}. void CreateBinLikelihoodFCN(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFitterFumili.h 22730 2008-03-19 10:22:46Z moneta $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterFumili.html
https://root.cern/root/html532/TFitterFumili.html:11921,Modifiability,inherit,inherited,11921,"tringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMinimizerType ); virtual FunctionMinimum Minimize( int nfcn = 0, double edmval = 0.1) const;. void CreateChi2FCN(). void CreateChi2ExtendedFCN(). void CreateUnbinLikelihoodFCN(); {}. void CreateBinLikelihoodFCN(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFitterFumili.h 22730 2008-03-19 10:22:46Z moneta $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterFumili.html
https://root.cern/root/html532/TFitterFumili.html:10833,Performance,cache,cache,10833,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMini",MatchSource.WIKI,root/html532/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterFumili.html
https://root.cern/root/html532/TFitterMinuit.html:1470,Availability,error,error,1470,"t. class TFitterMinuit: public TVirtualFitter. Function Members (Methods); public:. TFitterMinuit(); TFitterMinuit(Int_t maxpar); TFitterMinuit(const TFitterMinuit&); virtual~TFitterMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const ",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:1554,Availability,error,error,1554,"t. class TFitterMinuit: public TVirtualFitter. Function Members (Methods); public:. TFitterMinuit(); TFitterMinuit(Int_t maxpar); TFitterMinuit(const TFitterMinuit&); virtual~TFitterMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const ",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:13643,Availability,toler,tolerance,13643,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:13701,Availability,toler,tolerances,13701,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:14574,Availability,error,error,14574,"nctions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFitterMinuit.h 20880 2007-11-19 11:23:41Z rdm $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:11704,Integrability,interface,interface,11704," Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterMinuit(). TFitterMinuit(Int_t maxpar). virtual ~TFitterMinuit(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void Pri",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:13058,Integrability,interface,interface,13058,"nst; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. voi",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:11694,Modifiability,inherit,inherited,11694," Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterMinuit(). TFitterMinuit(Int_t maxpar). virtual ~TFitterMinuit(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void Pri",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:10274,Performance,cache,cache,10274,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:14344,Performance,perform,perform,14344,"nctions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id: TFitterMinuit.h 20880 2007-11-19 11:23:41Z rdm $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFitterMinuit.html:13656,Safety,avoid,avoid,13656,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root/html532/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html
https://root.cern/root/html532/TFoam.html:5966,Availability,error,error,5966," = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCarver(Int_t&, Double_t&, Double_t&); virtual Int_tCellFill(Int_t, TFoamCell*); virtual voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDivide(TFoamCell*); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExplore(TFoamCell* Cell); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFinalize(Double_t&, Double_t&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerCel2(TFoamCell*&); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetIntegMC(Double_t&, Double_t&); virtual voidGetIntNorm(Double_t&, Double_t&); virtual voidGetMCvect(Double_t*); virtual Double_tGetMCwt(); virtual voidGetMCwt(Double_t&); virtual const char*TObject::GetName() const; virtual Long_tGetnCalls() const; virtual Long_tGetnEffev() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:6050,Availability,error,error,6050,"t&, Double_t&); virtual Int_tCellFill(Int_t, TFoamCell*); virtual voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDivide(TFoamCell*); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExplore(TFoamCell* Cell); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFinalize(Double_t&, Double_t&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerCel2(TFoamCell*&); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetIntegMC(Double_t&, Double_t&); virtual voidGetIntNorm(Double_t&, Double_t&); virtual voidGetMCvect(Double_t*); virtual Double_tGetMCwt(); virtual voidGetMCwt(Double_t&); virtual const char*TObject::GetName() const; virtual Long_tGetnCalls() const; virtual Long_tGetnEffev() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetPrimary() ",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:12214,Availability,error,error,12214,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:20880,Availability,avail,available,20880,"-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(Double_t* MCvect); User subprogram which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t ,",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:23056,Availability,failure,failures,23056,"& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetChat(Int_t Chat); {fChat = Chat;}. void SetOptRej(Int_t OptRej); {fOptRej =OptRej;}. void SetOptDrive(Int_t OptDrive); {fOptDrive =OptDrive;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetMaxWtRej(Double_t MaxWtRej); {fMaxWtRej=MaxWtRej;}. const char * GetVersion() const; Getters and Setters. {return fVersion.Data();}. I",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:23097,Availability,failure,failures,23097,"& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetChat(Int_t Chat); {fChat = Chat;}. void SetOptRej(Int_t OptRej); {fOptRej =OptRej;}. void SetOptDrive(Int_t OptDrive); {fOptDrive =OptDrive;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetMaxWtRej(Double_t MaxWtRej); {fMaxWtRej=MaxWtRej;}. const char * GetVersion() const; Getters and Setters. {return fVersion.Data();}. I",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:813,Deployability,integrat,integrate,813,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:1042,Deployability,integrat,integrator,1042,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:1257,Deployability,integrat,integrated,1257,"ic TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:3500,Deployability,integrat,integration,3500,"<<endl;; hst_xy->Fill(x,y); // fill scattergram; }// loop; Double_t mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distri",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:11784,Deployability,integrat,integration,11784,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:17193,Deployability,update,updated,17193,"alization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Inte",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:18565,Deployability,update,updated,18565,"t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the purpose of the division. Int_t Divide(TFoamCell* ); Internal subrogram used by Initialize.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (TFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. void MakeActiveList(); Internal subrogram used by Initialize.; It finds out number of active cells fNoAct,; creates list of active cell fCellsAct and primary cumulative fPrimAcu.; They are used during the MC generation to choose randomly an active cell. void ResetPseRan(TRandom* PseRan); User may optionally reset random number generator using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing random number generator registered in the FOAM object.; In particular such an object is created by the streamer during the disk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set (register) random number generator used by; the given instance of the FOAM event generator. Note that single r.n. generator; may serve several FOAM objects. void ResetRho(TFoamIntegrand* Rho); User may optionally reset the distr",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:829,Energy Efficiency,efficient,efficient,829,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:840,Energy Efficiency,adapt,adaptive,840,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:3561,Energy Efficiency,allocate,allocated,3561,"mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distribution, while using OptRej=0. Past versions of FOAM: August 2003, v.",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:14942,Energy Efficiency,allocate,allocated,14942,"ector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructor for streamer, user should not use it. TFoam(const Char_t* ); User constructor, to be employed by the user. ~TFoam(); Default destructor; cout<<"" DESTRUCTOR entered ""<<endl;. TFoam(const TFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure E",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:15409,Energy Efficiency,allocate,allocated,15409,"R USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho pri",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:16592,Energy Efficiency,allocate,allocated,16592,"edu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the M",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:813,Integrability,integrat,integrate,813,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:1042,Integrability,integrat,integrator,1042,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:1257,Integrability,integrat,integrated,1257,"ic TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:3500,Integrability,integrat,integration,3500,"<<endl;; hst_xy->Fill(x,y); // fill scattergram; }// loop; Double_t mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distri",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:11784,Integrability,integrat,integration,11784,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:17311,Integrability,rout,routine,17311,"tion object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the pur",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:774,Modifiability,variab,variable,774,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:840,Modifiability,adapt,adaptive,840,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:20979,Modifiability,variab,variable,20979,"ribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(Double_t* MCvect); User subprogram which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; R",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:22334,Modifiability,variab,variables,22334,"program which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable f",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:22457,Modifiability,variab,variable,22457,"ovides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom *",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:22695,Modifiability,variab,variable,22695,"ORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCell",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:13078,Performance,optimiz,optimization,13078,"tMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptDriveOptimization switch =1,2 for variance or maximum weight optimization; Int_tfOptPRDOption switch for predefined division, for quick check; Int_tfOptRejSwitch =0 for weighted events; =1 for unweighted events in MC; Double_t*fPrimAcu[fNoAct] Array of cumulative probability of all active cells; Double_tfPrimePrimary integral R' (R=R'<wt>); TRandom*fPseRanPointer to user-defined generator of pseudorandom numbers; Int_tfRNmaxMaximum No. of the rand. numb. requested at once; TFoamIntegrand*fRho! Pointer to the user-defined integrand function/distribution; Double_t*fRvec[fRNmax] random number vector from r.n. generator fDim+1 maximum elements; Double_tfSumOveTotal Sum of overveighted events; Double_tfSumWt; Double_tfSumWt2Total sum of wt and wt^2; TStringfVersionActual version of the FOAM like (1.01m); Double_tfWtMax; Double_tfWtMinMaximum/Minimum MC weight; TFoamVect**fXdivPRD! Lists of division values encoded in one vector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructor for streamer, user should not use it. TFoam(con",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:15369,Performance,perform,performs,15369,"R USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho pri",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:15632,Performance,optimiz,optimization,15632,"itialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Ini",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:17832,Performance,optimiz,optimization,17832,"rue and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the purpose of the division. Int_t Divide(TFoamCell* ); Internal subrogram used by Initialize.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (TFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. void MakeActiveList(); Internal subrogram used b",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:15899,Security,access,access,15899,"ializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average ",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:952,Usability,simpl,simplified,952,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoam.html:20275,Usability,simpl,simple,20275,"ject is created by the streamer during the disk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set (register) random number generator used by; the given instance of the FOAM event generator. Note that single r.n. generator; may serve several FOAM objects. void ResetRho(TFoamIntegrand* Rho); User may optionally reset the distribution using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing distribution object registered in the FOAM object.; In particular such an object is created by the streamer diring the disk-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(",MatchSource.WIKI,root/html532/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoam.html
https://root.cern/root/html532/TFoamCell.html:1578,Availability,error,error,1578,"l(); TFoamCell(Int_t); TFoamCell(TFoamCell&); virtual~TFoamCell(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TFoamCell*, TFoamCell*, TFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TFoamCell*GetDau0() const; TFoamCell*GetDau1() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); voidGetHcub(TFoamVect&, TFoamVect&) const; voidGetHSize(TFoamVect&) const; virtual const char*TObject::GetIconName() const; Double_tGetIntg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFoamCell*GetPare() const; Double_tGetPrim() const; Int_tGet",MatchSource.WIKI,root/html532/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamCell.html
https://root.cern/root/html532/TFoamCell.html:1662,Availability,error,error,1662,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TFoamCell*, TFoamCell*, TFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TFoamCell*GetDau0() const; TFoamCell*GetDau1() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); voidGetHcub(TFoamVect&, TFoamVect&) const; voidGetHSize(TFoamVect&) const; virtual const char*TObject::GetIconName() const; Double_tGetIntg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFoamCell*GetPare() const; Double_tGetPrim() const; Int_tGetSerial() const; Int_tGetStat() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html532/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamCell.html
https://root.cern/root/html532/TFoamCell.html:6929,Energy Efficiency,allocate,allocated,6929,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return fVolume;}. Double_t GetIntg() const; { return fIntegral;}. Double_t GetDriv() const; { return fDrive;}. Double_t GetPrim() ",MatchSource.WIKI,root/html532/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamCell.html
https://root.cern/root/html532/TFoamCell.html:6723,Testability,test,tested,6723,"lic:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double",MatchSource.WIKI,root/html532/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamCell.html
https://root.cern/root/html532/TFoamIntegrand.html:437,Availability,avail,available,437,". TFoamIntegrand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamIntegrand. class TFoamIntegrand: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root/html532/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamIntegrand.html
https://root.cern/root/html532/TFoamIntegrand.html:1457,Availability,error,error,1457," virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root/html532/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamIntegrand.html
https://root.cern/root/html532/TFoamIntegrand.html:1541,Availability,error,error,1541," const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamIntegrand.html
https://root.cern/root/html532/TFoamMaxwt.html:1675,Availability,error,error,1675,"(); TFoamMaxwt(TFoamMaxwt& From); TFoamMaxwt(Double_t, Int_t); virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; voidGetMCeff(Double_t, Double_t&, Double_t&); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) con",MatchSource.WIKI,root/html532/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamMaxwt.html
https://root.cern/root/html532/TFoamMaxwt.html:1759,Availability,error,error,1759," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; voidGetMCeff(Double_t, Double_t&, Double_t&); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_t",MatchSource.WIKI,root/html532/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamMaxwt.html
https://root.cern/root/html532/TFoamMaxwt.html:6271,Availability,toler,tolerance,6271,"; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TH1D*fWtHst1Histogram of the weight wt; TH1D*fWtHst2Histogram of wt filled with wt. private:. Double_tfNentNo. of MC events; Int_tfnBinNo. of bins on the weight distribution; Double_tfwmaxMaximum analyzed weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamMaxwt(); Constructor for streamer. TFoamMaxwt(Double_t , Int_t ); Principal user constructor. TFoamMaxwt(TFoamMaxwt& From); Explicit COPY CONSTRUCTOR (unused, so far). ~TFoamMaxwt(); Destructor. void Reset(); Reseting weight analysis. TFoamMaxwt& operator=(const TFoamMaxwt& ); substitution =. void Fill(Double_t ); Filling analyzed weight. void Make(Double_t , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; To be called at the end of the MC run. void GetMCeff(Double_t , Double_t& , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; using information stored in two histograms.; To be called at the end of the MC run. » Last changed: root/foam:$Id: TFoamMaxwt.h 22726 2008-03-19 09:53:41Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamMaxwt.html
https://root.cern/root/html532/TFoamMaxwt.html:6435,Availability,toler,tolerance,6435,"; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TH1D*fWtHst1Histogram of the weight wt; TH1D*fWtHst2Histogram of wt filled with wt. private:. Double_tfNentNo. of MC events; Int_tfnBinNo. of bins on the weight distribution; Double_tfwmaxMaximum analyzed weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamMaxwt(); Constructor for streamer. TFoamMaxwt(Double_t , Int_t ); Principal user constructor. TFoamMaxwt(TFoamMaxwt& From); Explicit COPY CONSTRUCTOR (unused, so far). ~TFoamMaxwt(); Destructor. void Reset(); Reseting weight analysis. TFoamMaxwt& operator=(const TFoamMaxwt& ); substitution =. void Fill(Double_t ); Filling analyzed weight. void Make(Double_t , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; To be called at the end of the MC run. void GetMCeff(Double_t , Double_t& , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; using information stored in two histograms.; To be called at the end of the MC run. » Last changed: root/foam:$Id: TFoamMaxwt.h 22726 2008-03-19 09:53:41Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamMaxwt.html
https://root.cern/root/html532/TFoamMaxwt.html:412,Integrability,depend,depending,412,". TFoamMaxwt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamMaxwt. class TFoamMaxwt: public TObject. Class TFoamMaxwt. Small auxiliary class for controlling MC weight.; It provides certain measure of the ""maximum weight""; depending on small user-parameter ""epsilon"".; It creates and uses 2 histograms of the TH1D class.; User defines no. of bins nBin, nBin=1000 is recommended; wmax defines weight range (1,wmax), it is adjusted ""manually"". Function Members (Methods); public:. TFoamMaxwt(); TFoamMaxwt(TFoamMaxwt& From); TFoamMaxwt(Double_t, Int_t); virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual",MatchSource.WIKI,root/html532/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamMaxwt.html
https://root.cern/root/html532/TFoamSampler.html:1314,Availability,error,error,1314," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html532/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamSampler.html
https://root.cern/root/html532/TFoamSampler.html:1434,Availability,error,errors,1434," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html532/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamSampler.html
https://root.cern/root/html532/TFoamSampler.html:3175,Availability,error,error,3175,"etRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFoam*fFoamfoam engine class; TFoamIntegrand*fFoamDistfoam distribution interface ; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer; boolfOneDimflag to indicate if the function is 1 dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamSampler(); fDiscrete(false),; fHasMode(false), fHasArea(false),; fMode(0), fArea(0),. {}. ~TFoamSampler(). bool Init(const char* = """"). bool Init(const ROOT::Math::DistSamplerOptions& opt); initialize foam classes using the given algorithm. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TFoamSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: TFoamSampler.h 37419 2010-12-08 21:19:45Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamSampler.html
https://root.cern/root/html532/TFoamSampler.html:380,Integrability,interface,interface,380,". TFoamSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler",MatchSource.WIKI,root/html532/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamSampler.html
https://root.cern/root/html532/TFoamSampler.html:2284,Integrability,interface,interface,2284,"ror = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFoam*fFoamfoam engine class; TFoamIntegrand*fFoamDistfoam distribution interface ; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer; boolfOneDimflag to indicate if the function is 1 dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamSampler(); fDiscrete(false),; fHasMode(false), fHasArea(false),; fMode(0), fArea(0),. {}. ~TFoamSampler(). bool Init(const char* = """"). bool Init(const ROOT::Math::DistSamplerOptions& opt); initialize foam classes using the given algorithm. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TFoamSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunctio",MatchSource.WIKI,root/html532/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamSampler.html
https://root.cern/root/html532/TFoamSampler.html:760,Modifiability,extend,extend,760," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html532/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamSampler.html
https://root.cern/root/html532/TFoamSampler.html:901,Modifiability,extend,extend,901," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html532/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamSampler.html
https://root.cern/root/html532/TFoamVect.html:1446,Availability,error,error,1446," TFoamVect(); TFoamVect(Int_t); TFoamVect(const TFoamVect&); virtual~TFoamVect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virt",MatchSource.WIKI,root/html532/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamVect.html
https://root.cern/root/html532/TFoamVect.html:1530,Availability,error,error,1530," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inh",MatchSource.WIKI,root/html532/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamVect.html
https://root.cern/root/html532/TFoamVect.html:6059,Security,access,access,6059,"Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension; TFoamVect*fNextpointer for tree construction; TFoamVect*fPrevpointer for tree construction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamVect(); Default constructor for streamer. TFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. TFoamVect(const TFoamVect& ); Copy constructor. ~TFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TFoamVect& operator+=(const TFoamVect& ); unary addition operator +=; adding vector c*=x,. TFoamVect& operator-=(const TFoamVect& ); unary subtraction operator -=. TFoamVect operator+(const TFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TFoamVect operator-(const TFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components on ""cout"". void PrintList(void); Printout of all member vectors in the list starting from ""this"". Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; {return fCoords[i];}. » Last changed: root/foam:$Id: TFoamVect.h 20882 20",MatchSource.WIKI,root/html532/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFoamVect.html
https://root.cern/root/html532/TFolder.html:4519,Availability,error,error,4519,"idTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFullPathName(const char* name) const; virtual const char*FindFullPathName(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetListOfFolders() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::G",MatchSource.WIKI,root/html532/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFolder.html
https://root.cern/root/html532/TFolder.html:4603,Availability,error,error,4603,"TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFullPathName(const char* name) const; virtual const char*FindFullPathName(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetListOfFolders() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong",MatchSource.WIKI,root/html532/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFolder.html
https://root.cern/root/html532/TFolder.html:944,Energy Efficiency,efficient,efficient,944,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html532/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFolder.html
https://root.cern/root/html532/TFolder.html:1032,Modifiability,coupling,coupling,1032,"e; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a fold",MatchSource.WIKI,root/html532/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFolder.html
https://root.cern/root/html532/TFolder.html:3337,Modifiability,variab,variable,3337,"xample, the following folders exist:; //root/Files with the list of currently connected Root files; //root/Classes with the list of active classes; //root/Geometries with active geometries; //root/Canvases with the list of active canvases; //root/Styles with the list of graphics styles; //root/Colors with the list of active colors. For example, if a file ""myFile.root"" is added to the list of files, one can; retrieve a pointer to the corresponding TFile object with a statement like:; TFile *myFile = (TFile*)gROOT->FindObject(""//root/Files/myFile.root"");; The above statement can be abbreviated to:; TFile *myFile = (TFile*)gROOT->FindObject(""/Files/myFile.root"");; or even to:; TFile *myFile = (TFile*)gROOT->FindObjectAny(""myFile.root"");; In this last case, the TROOT::FindObjectAny function will scan the folder hierarchy; starting at //root and will return the first object named ""myFile.root"". Because a string-based search mechanism is expensive, it is recommended; to save the pointer to the object as a class member or local variable; if this pointer is used frequently or inside loops. /*. */. Function Members (Methods); public:. TFolder(); TFolder(const char* name, const char* title); virtual~TFolder(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html532/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFolder.html
https://root.cern/root/html532/TFolder.html:716,Security,access,access,716,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html532/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFolder.html
https://root.cern/root/html532/TFolder.html:1326,Security,access,access,1326,"ders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a folder does not own its contained objects.; NOTE that folder ownership can be set; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. Standard Root objects are automatically added to the folder hierarchy.; For example, the following folders exi",MatchSource.WIKI,root/html532/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFolder.html
https://root.cern/root/html532/TFormula.html:5484,Availability,error,error,5484,"Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tCompile(const char* expression = """"); virtual voidCopy(TObject& formula) const; virtual char*DefinedString(Int_t code); virtual Double_tDefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tEvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringGetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i); virtual const char*TNamed::GetName() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParameter(Int_t ipar) const; Double_tGetParameter(const char",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:5568,Availability,error,error,5568,"ression = """"); virtual voidCopy(TObject& formula) const; virtual char*DefinedString(Int_t code); virtual Double_tDefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tEvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringGetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i); virtual const char*TNamed::GetName() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParameter(Int_t ipar) const; Double_tGetParameter(const char* name) const; virtual Double_t*GetParameters() const; virtual voidGetParameters(Dou",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:15890,Availability,error,errors,15890, 0); Analyze a sub-expression in one formula*-*-; *-* =======================================; -; *-* Expressions in one formula are recursively analyzed.; *-* Result of analysis is stored in the object tables.; -; *-* Table of function codes and errors; *-* ==================================; -; *-* * functions :; -; *-* + 1 pow 20; *-* - 2 sq 21; *-* * 3 sqrt 22; *-* / 4 strstr 23; *-* % 5 min 24; *-* max 25; *-* log 30; *-* cos 10 exp 31; *-* sin 11 log10 32; *-* tan 12; *-* acos 13 abs 41; *-* asin 14 sign 42; *-* atan 15 int 43; *-* atan2 16; *-* fmod 17 rndm 50; -; *-* cosh 70 acosh 73; *-* sinh 71 asinh 74; *-* tanh 72 atanh 75; -; *-* expo 100 gaus 110 gausn (see note below); *-* expo(0) 100 0 gaus(0) 110 0 gausn(0); *-* expo(1) 100 1 gaus(1) 110 1 gausn(1); *-* xexpo 100 x xgaus 110 x xgausn; *-* yexpo 101 x ygaus 111 x ygausn; *-* zexpo 102 x zgaus 112 x zgausn; *-* xyexpo 105 x xygaus 115 x xygausn; *-* yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); *-* xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); -; *-* landau 120 x landaun (see note below); *-* landau(0) 120 0 landaun(0); *-* landau(1) 120 1 landaun(1); *-* xlandau 120 x xlandaun; *-* ylandau 121 x ylandaun; *-* zlandau 122 x zlandaun; *-* xylandau 125 x xylandaun; *-* ylandau(5) 121 5 ylandaun(5); *-* xylandau(2) 125 2 xylandaun(2); -; *-* pol0 130 x pol1 130 1xx; *-* pol0(0) 130 0 pol1(0) 130 100; *-* pol0(1) 130 1 pol1(1) 130 101; *-* xpol0 130 x xpol1 130 101; *-* ypol0 131 x ypol1 131 101; *-* zpol0 132 x zpol1 132 1xx; *-* ypol0(5) 131 5 ypol1(5) 131 105; -; *-* pi 40; -; *-* && 60 < 64; *-* || 61 > 65; *-* == 62 <= 66; *-* != 63 => 67; *-* ! 68; *-* ==(string) 76 & 78; *-* !=(string) 77 | 79; *-* <<(shift) 80 >>(shift) 81; *_* ? : 82; -; *-* * constants (kConstants) :; -; *-* c0 141 1 c1 141 2 etc..; -; *-* * strings (kStringConst):; -; *-* sX 143 x; -; *-* * variables (kFormulaVar) :; -; *-* x 144 0 y 144 1 z 144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special,MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:19051,Availability,error,errors,19051,"; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial not specified; *-* 24 : Degree of polynomial must be positive; *-* 25 : Degree of polynomial must be less than 20; *-* 26 : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* I",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:2915,Deployability,update,updated,2915,"t to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware;",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:27146,Integrability,depend,depend,27146,"s is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual value; *-* of the parameter. Example:; *-* if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; *-* and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; *-* ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; return value of parameter number ipar. Double_t GetParameter(const char* name) const; return value of parameter named parName. const char * GetParName(Int_t ipar) const; Return name of one parameter*-*-*-*-*-*-*-*-; *-* ============================. Int_t GetParNumber(const char* name) const; return parameter number by name. Bool_t IsString(Int_t oper) const; return true if the expression at the index 'oper' is to be treated as; as string. void Print(Option_t* option = ",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:2810,Modifiability,inherit,inheriting,2810,"t to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware;",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:4748,Modifiability,variab,variable,4748,,MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:13826,Modifiability,variab,variables,13826,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:17497,Modifiability,variab,variables,17497," xyexpo 105 x xygaus 115 x xygausn; *-* yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); *-* xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); -; *-* landau 120 x landaun (see note below); *-* landau(0) 120 0 landaun(0); *-* landau(1) 120 1 landaun(1); *-* xlandau 120 x xlandaun; *-* ylandau 121 x ylandaun; *-* zlandau 122 x zlandaun; *-* xylandau 125 x xylandaun; *-* ylandau(5) 121 5 ylandaun(5); *-* xylandau(2) 125 2 xylandaun(2); -; *-* pol0 130 x pol1 130 1xx; *-* pol0(0) 130 0 pol1(0) 130 100; *-* pol0(1) 130 1 pol1(1) 130 101; *-* xpol0 130 x xpol1 130 101; *-* ypol0 131 x ypol1 131 101; *-* zpol0 132 x zpol1 132 1xx; *-* ypol0(5) 131 5 ypol1(5) 131 105; -; *-* pi 40; -; *-* && 60 < 64; *-* || 61 > 65; *-* == 62 <= 66; *-* != 63 => 67; *-* ! 68; *-* ==(string) 76 & 78; *-* !=(string) 77 | 79; *-* <<(shift) 80 >>(shift) 81; *_* ? : 82; -; *-* * constants (kConstants) :; -; *-* c0 141 1 c1 141 2 etc..; -; *-* * strings (kStringConst):; -; *-* sX 143 x; -; *-* * variables (kFormulaVar) :; -; *-* x 144 0 y 144 1 z 144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special cases for normalized gaussian or landau distributions; *-* =============================================================; *-* the expression ""gaus"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2); *-* to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; *-* the expression ""gausn"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); *-* WARNING: gaus and gausn are mutually exclusive in the same expression.; -; *-* In the same way the expression ""landau"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kFALSE); *-* to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; *-* the expression ""landaun"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kTRUE); *-* WARNING: landau and landaun are mutually exclusive in the same expression.; -; *-* boolean optimization (kBoolOptmize) :; *-* ===================",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:19902,Modifiability,variab,variable,19902,"; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial not specified; *-* 24 : Degree of polynomial must be positive; *-* 25 : Degree of polynomial must be less than 20; *-* 26 : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* I",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:24791,Modifiability,variab,variable,24791,"e,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if expression is in the list of defined variables; *-* =======================================================; -; *-* This member function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:24865,Modifiability,variab,variables,24865,"e,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if expression is in the list of defined variables; *-* =======================================================; -; *-* This member function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:26017,Modifiability,variab,variables,26017,"function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* inst",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:26391,Modifiability,variab,variables,26391,"ructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:26748,Modifiability,variab,variables,26748,"has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual value; *-* of the parameter. Example:; *-* if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; *-* and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; *-* ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; return value of parameter number ipar. Double_t GetParameter(const char* name) const; return value of parameter named parNam",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:26850,Modifiability,variab,variables,26850,"has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual value; *-* of the parameter. Example:; *-* if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; *-* and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; *-* ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; return value of parameter number ipar. Double_t GetParameter(const char* name) const; return value of parameter named parNam",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:30335,Modifiability,variab,variables,30335,"nst char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10""); Set up to 10 parameter names*-*-*-*-*-; *-* ============================. void Streamer(TBuffer& b); Stream a class object*-*-*-*-*-*-*-; *-* =========================================. void Convert(UInt_t fromVersion); Convert the fOper of a TFormula version fromVersion to the current in memory version. void MakePrimitive(const char* expr, Int_t pos). MakePrimitive; find TFormulaPrimitive replacement for some operands. void Optimize(). MI include. Optimize formula; 1.) Minimize the number of operands; a.) several operanands are glued togther; b.) some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); c.) maximize number of standard calls minimizing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is choosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Do",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:31253,Modifiability,variab,variable,31253,"zing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is choosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive0(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive1(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive2(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from t",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:32117,Modifiability,variab,variables,32117,":TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive0(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive1(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive2(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*; ; */. -; -; -. Int_t PreCompile(). Pre compile function. void SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); static function to set the maximum value of 3 parameters; -maxop : maximum number of operations; -maxpar : maximum number of parameters; -maxconst : maximum number of constants; None of these parameters cannot be less than 10 (default is 1000); call this function to increase one or all maxima when processing; very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; If you process many functions with a small number of operations/parameters; you may gain some memory and performance by decreasing these values. Int_t * GetOper() const; { return fOper; }. Short_t GetAction(Int_t code",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:2532,Performance,perform,performance,2532,"ned names can be given. For example, if the formula; *-* TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; *-* the name of the object = title = formula itself.; *-* old.SetName(""old"").; *-* then, old can be reused in a new expression.; *-* TFormula new(""x*old"") is equivalent to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a freq",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:3077,Performance,perform,performant,3077," and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware; *-* of all TMath functions.; -; -. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:13070,Performance,cache,cache,13070,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:13441,Performance,optimiz,optimization,13441,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:18478,Performance,optimiz,optimization,18478,"144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special cases for normalized gaussian or landau distributions; *-* =============================================================; *-* the expression ""gaus"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2); *-* to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; *-* the expression ""gausn"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); *-* WARNING: gaus and gausn are mutually exclusive in the same expression.; -; *-* In the same way the expression ""landau"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kFALSE); *-* to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; *-* the expression ""landaun"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kTRUE); *-* WARNING: landau and landaun are mutually exclusive in the same expression.; -; *-* boolean optimization (kBoolOptmize) :; *-* =====================================; -; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial ",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:32952,Performance,perform,performance,32952,"imitive2(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*; ; */. -; -; -. Int_t PreCompile(). Pre compile function. void SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); static function to set the maximum value of 3 parameters; -maxop : maximum number of operations; -maxpar : maximum number of parameters; -maxconst : maximum number of constants; None of these parameters cannot be less than 10 (default is 1000); call this function to increase one or all maxima when processing; very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; If you process many functions with a small number of operations/parameters; you may gain some memory and performance by decreasing these values. Int_t * GetOper() const; { return fOper; }. Short_t GetAction(Int_t code) const; { return fOper[code] >> kTFOperShift; }. Int_t GetActionParam(Int_t code) const; { return fOper[code] & kTFOperMask; }. void SetAction(Int_t code, Int_t value, Int_t param = 0). Int_t * GetOperOptimized() const; { return fOperOptimized; }. Short_t GetActionOptimized(Int_t code) const; { return fOperOptimized[code] >> kTFOperShift; }. Int_t GetActionParamOptimized(Int_t code) const; { return fOperOptimized[code] & kTFOperMask; }. void SetActionOptimized(Int_t code, Int_t value, Int_t param = 0). Double_t EvalPar(const Double_t* x, const Double_t* params = 0); {return ((*this).*fOptimal)(x,params);}. Int_t GetN",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:3008,Security,access,access,3008," and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware; *-* of all TMath functions.; -; -. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:3088,Security,access,access,3088," and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware; *-* of all TMath functions.; -; -. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:19939,Security,access,accessible,19939,"; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial not specified; *-* 24 : Degree of polynomial must be positive; *-* 25 : Degree of polynomial must be less than 20; *-* 26 : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* I",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:2068,Testability,log,logic,2068,"; *-* expo(3) is a substitute for exp([3]+[4]*x); *-* pol3(5) is a substitute for par[5]+par[6]*x+par[7]*x**2+par[8]*x**3; *-* (here Pol3 stands for Polynomial of degree 3); -; *-* TMath functions can be part of the expression, eg:; *-* - TMath::Landau(x)*sin(x); *-* - TMath::Erf(x); -; *-* Comparisons operators are also supported (&&, ||, ==, <=, >=, !); *-* Examples:; *-* sin(x*(x<0.5 || x>1)); *-* If the result of a comparison is TRUE, the result is 1, otherwise 0.; -; *-* Already predefined names can be given. For example, if the formula; *-* TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; *-* the name of the object = title = formula itself.; *-* old.SetName(""old"").; *-* then, old can be reused in a new expression.; *-* TFormula new(""x*old"") is equivalent to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* ",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:16062,Testability,log,log,16062, 0); Analyze a sub-expression in one formula*-*-; *-* =======================================; -; *-* Expressions in one formula are recursively analyzed.; *-* Result of analysis is stored in the object tables.; -; *-* Table of function codes and errors; *-* ==================================; -; *-* * functions :; -; *-* + 1 pow 20; *-* - 2 sq 21; *-* * 3 sqrt 22; *-* / 4 strstr 23; *-* % 5 min 24; *-* max 25; *-* log 30; *-* cos 10 exp 31; *-* sin 11 log10 32; *-* tan 12; *-* acos 13 abs 41; *-* asin 14 sign 42; *-* atan 15 int 43; *-* atan2 16; *-* fmod 17 rndm 50; -; *-* cosh 70 acosh 73; *-* sinh 71 asinh 74; *-* tanh 72 atanh 75; -; *-* expo 100 gaus 110 gausn (see note below); *-* expo(0) 100 0 gaus(0) 110 0 gausn(0); *-* expo(1) 100 1 gaus(1) 110 1 gausn(1); *-* xexpo 100 x xgaus 110 x xgausn; *-* yexpo 101 x ygaus 111 x ygausn; *-* zexpo 102 x zgaus 112 x zgausn; *-* xyexpo 105 x xygaus 115 x xygausn; *-* yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); *-* xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); -; *-* landau 120 x landaun (see note below); *-* landau(0) 120 0 landaun(0); *-* landau(1) 120 1 landaun(1); *-* xlandau 120 x xlandaun; *-* ylandau 121 x ylandaun; *-* zlandau 122 x zlandaun; *-* xylandau 125 x xylandaun; *-* ylandau(5) 121 5 ylandaun(5); *-* xylandau(2) 125 2 xylandaun(2); -; *-* pol0 130 x pol1 130 1xx; *-* pol0(0) 130 0 pol1(0) 130 100; *-* pol0(1) 130 1 pol1(1) 130 101; *-* xpol0 130 x xpol1 130 101; *-* ypol0 131 x ypol1 131 101; *-* zpol0 132 x zpol1 132 1xx; *-* ypol0(5) 131 5 ypol1(5) 131 105; -; *-* pi 40; -; *-* && 60 < 64; *-* || 61 > 65; *-* == 62 <= 66; *-* != 63 => 67; *-* ! 68; *-* ==(string) 76 & 78; *-* !=(string) 77 | 79; *-* <<(shift) 80 >>(shift) 81; *_* ? : 82; -; *-* * constants (kConstants) :; -; *-* c0 141 1 c1 141 2 etc..; -; *-* * strings (kStringConst):; -; *-* sX 143 x; -; *-* * variables (kFormulaVar) :; -; *-* x 144 0 y 144 1 z 144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special,MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:2610,Usability,simpl,simple,2610," to the formula. By default; *-* the name of the object = title = formula itself.; *-* old.SetName(""old"").; *-* then, old can be reused in a new expression.; *-* TFormula new(""x*old"") is equivalent to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompili",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:20221,Usability,simpl,simple,20221," : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; -. Bool_t CheckOperands(Int_t operation, Int_t& err); Check whether the operand at 'oper-1' is compatible with the operation at 'oper'. Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); Check whether the operands at 'leftoper' and 'oper-1' are compatible with the operation at 'oper'. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void Clear(Option_t* option = """"); Resets the objects*-*-; *-* ==",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormula.html:25719,Usability,usab,usable,25719,"-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if expression is in the list of defined variables; *-* =======================================================; -; *-* This member function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal ",MatchSource.WIKI,root/html532/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormula.html
https://root.cern/root/html532/TFormulaPrimitive.html:2571,Availability,error,error,2571,"FormulaPrimitive* formula); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html532/TFormulaPrimitive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormulaPrimitive.html
https://root.cern/root/html532/TFormulaPrimitive.html:2655,Availability,error,error,2655,"irtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULon",MatchSource.WIKI,root/html532/TFormulaPrimitive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFormulaPrimitive.html
https://root.cern/root/html532/TFPBlock.html:1565,Availability,error,error,1565," TFPBlock(const TFPBlock&); TFPBlock(Long64_t*, Int_t*, Int_t); virtual~TFPBlock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBuffer() const; virtual Option_t*TObject::GetDrawOption() const; s",MatchSource.WIKI,root/html532/TFPBlock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFPBlock.html
https://root.cern/root/html532/TFPBlock.html:1649,Availability,error,error,1649," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBuffer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFullSize() const; virtual const char*TObject::GetIconName() const; Int_t*GetLen() const; Int_tGetLen(Int_t) const; virtual const char*TObject::GetName() const; Int_tGetNoElem() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_t*GetPos() const; Long64_tGetPos(Int_t) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html532/TFPBlock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFPBlock.html
https://root.cern/root/html532/TFractionFitter.html:4476,Availability,error,errors,4476,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:4543,Availability,error,error,4543,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:5370,Availability,error,error,5370," fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual ",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:6554,Availability,error,error,6554,"nst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidErrorAnalysis(Double_t UP); voidExcludeBin(Int_t bin); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:6638,Availability,error,error,6638,"ual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidErrorAnalysis(Double_t UP); voidExcludeBin(Int_t bin); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:7472,Availability,error,error,7472,"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIncludeBin(Int_t bin); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator dele",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:13499,Availability,error,error,13499," TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetR",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:13799,Availability,error,error,13799,"aration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; h",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:14178,Availability,error,error,14178," verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures ",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:14488,Availability,error,error,14488,"revious fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower Y bin number; high: upper Y bin number. void ReleaseRangeY(); Release restrictions on the Y range of the histogram to be used in the fit. void SetRangeZ(Int_t low, Int_t high); Set",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:16886,Availability,error,error,16886,"de the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. ",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:17165,Availability,error,error,17165," the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare(",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:13108,Integrability,message,message,13108,"ension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a ",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:1822,Performance,perform,perform,1822,"ters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }. Assumptions. A few assumptions need to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; temp",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:11574,Performance,perform,performed,11574," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:16686,Performance,perform,performed,16686,"bin number. void ReleaseRangeZ(); Release restrictions on the Z range of the histogram to be used in the fit. void ExcludeBin(Int_t bin); Exclude the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& mi",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:17081,Performance,perform,perform,17081,"ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:698,Safety,predict,predictions,698,". TFractionFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TFractionFitter. class TFractionFitter: public TObject. Fits MC fractions to data histogram (a la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f). The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""sam",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:4609,Safety,predict,prediction,4609,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:11327,Safety,predict,predictions,11327," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:12319,Safety,predict,predictions,12319," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:17329,Safety,predict,prediction,17329,"e input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambd",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:18144,Safety,predict,prediction,18144,"INOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the num",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:19659,Safety,predict,prediction,19659,"pute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1. » Last changed: root/hist:$Id: TFractionFitter.h 38775 2011-04-08 08:27:27Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:3283,Security,access,access,3283,"much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by speci",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:14252,Security,access,access,14252,"); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower Y ",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:3163,Usability,simpl,simplify,3163,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weig",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:4649,Usability,simpl,simple,4649,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFractionFitter.html:17550,Usability,simpl,simply,17550,"nsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> de",MatchSource.WIKI,root/html532/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFractionFitter.html
https://root.cern/root/html532/TFrame.html:1710,Availability,error,error,1710,"voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& frame) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html532/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFrame.html
https://root.cern/root/html532/TFrame.html:1794,Availability,error,error,1794,"me = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& frame) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::G",MatchSource.WIKI,root/html532/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFrame.html
https://root.cern/root/html532/TFrame.html:7671,Availability,down,down,7671,"CurrentStyle()MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TBox::[unnamed] { kCannotMove; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Short_tTWbox::fBorderModeBordermode (-1=down, 0 = no border, 1=up); Short_tTWbox::fBorderSizewindow box bordersize in pixels; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Bool_tTBox::fResizing!True if box is being resized; Double_tTBox::fX1X of 1st point; Double_tTBox::fX2X of 2nd point; Double_tTBox::fY1Y of 1st point; Double_tTBox::fY2Y of 2nd point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFrame(); Frame default constructor. TFrame(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Frame normal constructor. TFrame(const TFrame& frame); Frame copy constructor. ~TFrame(); Frame default destructor. void Copy(TObject& frame) const; Copy this frame to frame. void Draw(Option_t* option = """"); Draw this frame with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TFrame object is clicked. void Paint(Option_t* option = """"); Paint this wbox with its current attributes. void Pop(); Do not pop frame's, if allowed they would cover t",MatchSource.WIKI,root/html532/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFrame.html
https://root.cern/root/html532/TFrameEditor.html:4655,Availability,error,error,4655,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFrameEditor.html
https://root.cern/root/html532/TFrameEditor.html:4739,Availability,error,error,4739,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFrameEditor.html
https://root.cern/root/html532/TFrameEditor.html:17766,Availability,mask,mask,17766,,MatchSource.WIKI,root/html532/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFrameEditor.html
https://root.cern/root/html532/TFree.html:2009,Availability,error,error,2009," last); virtual~TFree(); voidTObject::AbstractMethod(const char* method) const; TFree*AddFree(TList* lfree, Long64_t first, Long64_t last); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFree*GetBestFree(TList* lfree, Int_t nbytes); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const",MatchSource.WIKI,root/html532/TFree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFree.html
https://root.cern/root/html532/TFree.html:2093,Availability,error,error,2093,"e*AddFree(TList* lfree, Long64_t first, Long64_t last); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFree*GetBestFree(TList* lfree, Int_t nbytes); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html532/TFree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFree.html
https://root.cern/root/html532/TFriendElement.html:1918,Availability,error,error,1918,"s); virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTree*GetParentTree() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree(); virtual const char*GetTreeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); v",MatchSource.WIKI,root/html532/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFriendElement.html
https://root.cern/root/html532/TFriendElement.html:2002,Availability,error,error,2002," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTree*GetParentTree() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree(); virtual const char*GetTreeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, co",MatchSource.WIKI,root/html532/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFriendElement.html
https://root.cern/root/html532/TFriendElement.html:468,Modifiability,variab,variable,468,". TFriendElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TFriendElement. class TFriendElement: public TNamed. TFriendElement. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. To add a TFriendElement to an existing TTree T, do:; T.AddFriend(""friendTreename"",""friendTreeFile"");. See TTree::AddFriend for more information. Function Members (Methods); public:. TFriendElement(); TFriendElement(TTree* tree, const char* treename, const char* filename); TFriendElement(TTree* tree, const char* treename, TFile* file); TFriendElement(TTree* tree, TTree* friendtree, const char* alias); virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t*",MatchSource.WIKI,root/html532/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFriendElement.html
https://root.cern/root/html532/TFTP.html:1969,Availability,error,error,1969,"ectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeDirectory(Bool_t print = kFALSE); voidget(const char* file, const char* localName = 0); Int_tGetBlockSize() const; const char*GetDirEntry(Bool_t print = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFile(const char* file, const char* localName = 0); virtual const char*TObject::GetIconName() const; Int_tGetMode() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPathInfo(const char* path, FileStat_t& buf, Bool_t p",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:2053,Availability,error,error,2053,"onst; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeDirectory(Bool_t print = kFALSE); voidget(const char* file, const char* localName = 0); Int_tGetBlockSize() const; const char*GetDirEntry(Bool_t print = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFile(const char* file, const char* localName = 0); virtual const char*TObject::GetIconName() const; Int_tGetMode() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Long64_tGetRestartAt() const; TSocket*GetSocket() const; virtual con",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:8641,Availability,error,error,8641,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:8667,Availability,error,error,8667,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:8806,Availability,error,error,8806,"d Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of f",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:9106,Availability,error,error,9106,":port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you ar",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:9149,Availability,error,error,9149,"will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can forc",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:9197,Availability,failure,failure,9197,"is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(con",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:9728,Availability,error,error,9728," EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote dire",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:9771,Availability,error,error,9771,"essage kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in c",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:9819,Availability,failure,failure,9819,"and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = ",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:10376,Availability,echo,echoed,10376," not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) cons",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:10437,Availability,failure,failure,10437,"otd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Re",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:10630,Availability,failure,failure,10630," file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permission",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:10804,Availability,failure,failure,10804,"nection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:10999,Availability,failure,failure,10999,"esired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remot",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:11124,Availability,failure,failure,11124," the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in ca",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:11303,Availability,failure,failure,11303,"e remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a File",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:11462,Availability,failure,failure,11462,"ure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, ",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:11661,Availability,failure,failure,11661,"nt_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, biza",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:11755,Availability,failure,failure,11755,"t delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:11917,Availability,error,error,11917,"e options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetResta",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:12138,Availability,error,error,12138," cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii)",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:8925,Energy Efficiency,power,power,8925,"el = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() i",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:348,Integrability,protocol,protocol,348,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:7467,Integrability,protocol,protocol,7467,"Zombie(). private:. TFTP(); TFTP(const TFTP&); voidInit(const char* url, Int_t parallel, Int_t wsize); voidoperator=(const TFTP&); voidPrintError(const char* where, Int_t err) const; Int_tRecv(Int_t& status, EMessageTypes& kind) const; voidSetMode(Int_t mode). Data Members; public:. enum { kDfltBlockSize; kDfltWindowSize; kBinary; kAscii; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBlockSizesize of data buffer used to transfer; Long64_tfBytesReadnumber of bytes received; Long64_tfBytesWritenumber of bytes sent; TStringfCurrentFilefile currently being get or put; Bool_tfDirIndicates if a remote directory is open; TStringfHostFQDN of remote host; Int_tfLastBlocklast block successfully transfered; Int_tfModebinary or ascii file transfer mode; Int_tfParallelnumber of parallel sockets; Int_tfPortport to which to connect; Int_tfProtocolrootd protocol level; Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t ",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:8476,Integrability,message,message,8476," Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; ",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:8654,Integrability,depend,depending,8654,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:8769,Integrability,message,message,8769,"tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of er",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:10313,Integrability,message,message,10313," not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) cons",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:322,Performance,perform,performant,322,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:444,Performance,perform,performance,444,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:12524,Security,access,access,12524,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:12558,Security,access,access,12558,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFTP.html:12605,Security,access,access,12605,"ge permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir); }. void rmdir(const char* dir) const; { DeleteDirectory(dir); }. void ls(Option_t* cmd = """") const; { ListDi",MatchSource.WIKI,root/html532/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFTP.html
https://root.cern/root/html532/TFumili.html:971,Availability,error,errors,971,". TFumili. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumili. class TFumili: public TVirtualFitter. FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. ; FUMILI minimization package; FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function.; Experimentally measured values $F_i$ are fitted with theoretical; functions $f_i({\vec x}_i,\vec\theta\,\,)$, where ${\vec x}_i$ are; coordinates, and $\vec\theta$ -- vector of parameters.; For better convergence Chi-square function has to be the following form; $$; {\chi^2\over2}={1\over2}\sum^n_{i=1}\left(f_i(\vec; x_i,\vec\theta\,\,)-F_i\over\sigma_i\right)^2 \eqno(1); $$; where $\sigma_i$ are errors of measured function.; The minimum condition is; $$; {\partial\chi^2\over\partial\theta_i}=\sum^n_{j=1}{1\over\sigma^2_j}\cdot; {\partial f_j\over\partial\theta_i}\left[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expressi",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:2200,Availability,down,down,2200,"ft[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expression is used when last term in (4) is discarded. It is often; done, not always wittingly, and sometimes causes troubles, for example,; if user wants to limit parameters with positive values by writing down; $\theta_i^2$ instead of $\theta_i$. FUMILI will fail if one tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:4794,Availability,error,error,4794,"; virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tEval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Double_tEvalTFN(Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExecuteSetCommand(Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ip",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:4878,Availability,error,error,4878,"(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tEval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Double_tEvalTFN(Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExecuteSetCommand(Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:15615,Availability,error,errors,15615,"ble_tfGTExpected function change in next iteration; Double_t*fGr[fMaxParam] Gradients of objective function; Int_tfINDFLG[5]internal flags;; Int_tfLastFixedLast fixed parameter number; Bool_tfLogLikeLogLikelihood flag; Int_tfMaxParam; Int_tfNED1Number of experimental vectors X=(x1,x2,...xK); Int_tfNED12fNED1+fNED2; Int_tfNED2K - Length of vector X plus 2 (for chi2); Int_tfNfcnNumber of FCN calls;; Int_tfNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; Int_tfNlog; Int_tfNmaxIterfNmaxIter - maximum number of iterations; Int_tfNparfNpar - number of parameters; Int_tfNstepDecfNstepDec - maximum number of step decreasing counter; Bool_tfNumericDerivatives; Double_t*fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixed; Double_t*fPL0[fMaxParam] Step initial bounds; Double_t*fParamError[fMaxParam] Parameter errors; Double_t*fR[fMaxParam] Correlation factors; Double_tfRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?; Double_tfSfS - objective function value (return); Double_t*fSumLog[fNlog]; Bool_tfWARNwarnings; Double_t*fZ[fMaxParam2] Invers fZ0 matrix - covariance matrix; Double_t*fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vec",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:16451,Availability,error,errors,16451,"ves; Double_t*fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixed; Double_t*fPL0[fMaxParam] Step initial bounds; Double_t*fParamError[fMaxParam] Parameter errors; Double_t*fR[fMaxParam] Correlation factors; Double_tfRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?; Double_tfSfS - objective function value (return); Double_t*fSumLog[fNlog]; Bool_tfWARNwarnings; Double_t*fZ[fMaxParam2] Invers fZ0 matrix - covariance matrix; Double_t*fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:18260,Availability,error,errors,18260,"; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar paramete",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:19051,Availability,error,error,19051," nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; us",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:19375,Availability,error,error,19375,": command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:19680,Availability,error,errors,19680," Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Opti",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:20936,Availability,error,error,20936,"ar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:21170,Availability,error,errors,21170,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:21215,Availability,error,errors,21215,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:21259,Availability,error,errors,21259,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:21324,Availability,error,errors,21324,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:21767,Availability,error,error,21767,"de data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization func",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:22347,Availability,error,error,22347,"- print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bi",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:22932,Availability,error,error,22932,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:23257,Availability,error,error,23257," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:23897,Availability,error,error,23897,"int the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // W",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:24483,Availability,error,error,24483,"idth of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id: TFumili.h 40814 2011-09-06 13:55:49Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:22484,Deployability,release,released,22484,"; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Li",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:24732,Integrability,wrap,wrapper,24732,"idth of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id: TFumili.h 40814 2011-09-06 13:55:49Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:16994,Modifiability,variab,variable,16994,"ance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:17043,Modifiability,variab,variable,17043,"ance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:19927,Modifiability,variab,variable,19927,"otalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following valu",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:20220,Modifiability,variab,variable,20220,"_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors a",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:13255,Performance,cache,cache,13255,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fA[fMaxParam] Fit parameter array; Double_tfAKAPPA; Double_t*fAMN[fMaxParam] Minimum param value; Double_t*fAMX[fMaxParam] Maximum param value; TString*fANames[fMaxParam] Parameter names; Double_t*fCmPar[fMaxParam] parameters of commands; TStringfCwordCommand st",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:17711,Performance,perform,performs,17711,"f theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer t",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:22869,Performance,cache,cache,22869,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:23191,Performance,cache,cache,23191," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:23834,Performance,cache,cache,23834,"int the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // W",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:24417,Performance,cache,cache,24417,"idth of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id: TFumili.h 40814 2011-09-06 13:55:49Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:23655,Safety,predict,predict,23655,"arded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:24261,Safety,predict,predict,24261,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id: TFumili.h 40814 2011-09-06 13:55:49Z moneta $ » Last generated: 2011",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:3423,Testability,log,logarithm,3423,"sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Dra",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:20023,Testability,log,log,20023,"(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void Prin",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:20045,Testability,log,log,20045,"(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void Prin",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:22138,Testability,log,loglikelihood,22138,"arameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:23727,Testability,log,logs,23727,"uble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:24333,Testability,log,logs,24333,"idth of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id: TFumili.h 40814 2011-09-06 13:55:49Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumili.html:3193,Usability,simpl,simple,3193,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual In",MatchSource.WIKI,root/html532/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumili.html
https://root.cern/root/html532/TFumiliMinimizer.html:4938,Availability,error,errors,4938,"ues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer(const TFumiliMinimizer&); TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is pri",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:7271,Availability,error,errors,7271," there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. dou",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:8100,Availability,error,error,8100," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:8110,Availability,error,error,8110," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:8180,Availability,error,errors,8180," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:8419,Availability,error,errors,8419," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:7220,Deployability,update,update,7220," there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. dou",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:387,Integrability,interface,interface,387,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsRO",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:5889,Integrability,interface,interface,5889,"r::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, cons",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:6139,Integrability,interface,interface,6139," doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. b",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:6223,Integrability,interface,interface,6223,"d by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:6414,Integrability,interface,interface,6414,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:460,Modifiability,plug-in,plug-in,460,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsRO",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:478,Modifiability,plug-in,plug-in,478,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsRO",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:6749,Modifiability,variab,variable,6749,"ivate). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of f",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:6880,Modifiability,variab,variable,6880,"passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is t",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:6965,Modifiability,variab,variable,6965,"ll be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:7037,Modifiability,variab,variable,7037," & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:7844,Modifiability,variab,variables,7844,"ep, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:7941,Modifiability,variab,variables,7941," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:8333,Modifiability,variab,variable,8333," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:8391,Modifiability,variab,variables,8391," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:7070,Performance,perform,perform,7070,"ulti-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and er",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFumiliMinimizer.html:4955,Security,validat,validated,4955,"ues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer(const TFumiliMinimizer&); TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is pri",MatchSource.WIKI,root/html532/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFumiliMinimizer.html
https://root.cern/root/html532/TFunction.html:1568,Availability,error,error,1568," TFunction(MethodInfo_t* info = 0); TFunction(const TFunction& orig); virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfMethodArgs(); virtual const char*GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tGetNargs() const; Int_tGetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual ",MatchSource.WIKI,root/html532/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunction.html
https://root.cern/root/html532/TFunction.html:1652,Availability,error,error,1652,"ion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfMethodArgs(); virtual const char*GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tGetNargs() const; Int_tGetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetPrototype() const; const char*GetReturnTypeName() const; const char*Ge",MatchSource.WIKI,root/html532/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunction.html
https://root.cern/root/html532/TFunction.html:7795,Availability,error,error,7795,"on arguments; TStringTNamed::fNameobject identifier; TStringfSignaturestring containing function signature; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunction(MethodInfo_t* info = 0); Default TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TFunction.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunction.html
https://root.cern/root/html532/TFunction.html:7910,Availability,error,error,7910,"on arguments; TStringTNamed::fNameobject identifier; TStringfSignaturestring containing function signature; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunction(MethodInfo_t* info = 0); Default TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TFunction.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunction.html
https://root.cern/root/html532/TFunction.html:7541,Integrability,interface,interface,7541,"on arguments; TStringTNamed::fNameobject identifier; TStringfSignaturestring containing function signature; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunction(MethodInfo_t* info = 0); Default TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TFunction.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunction.html
https://root.cern/root/html532/TFunction.html:484,Security,access,accessible,484,". TFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TFunction. class TFunction: public TDictionary. Global functions class (global functions are obtaine from CINT).; This class describes one single global function.; The TROOT class contains a list of all currently defined global; functions (accessible via TROOT::GetListOfGlobalFunctions()). Function Members (Methods); public:. TFunction(MethodInfo_t* info = 0); TFunction(const TFunction& orig); virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TDictionary*TDict",MatchSource.WIKI,root/html532/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunction.html
https://root.cern/root/html532/TFunctionParametersDialog.html:4777,Availability,error,error,4777,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:4861,Availability,error,error,4861,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:19598,Availability,mask,mask,19598,,MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:21460,Availability,error,errors,21460,::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKCancel button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParFixfix setting check buttons; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPvaloriginal patameters' values; Double_tfRXmaxoriginal max range; Double_tfRXminoriginal min range; Double_tfRangexmaxmax limits of patameters range; Double_tfRangexminmin limits of patameters range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateImmediate update check button; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y positi,MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:8265,Deployability,update,update,8265,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:20013,Deployability,update,updated,20013,"class name; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*fContFixcontainer of fix settings; TGCompositeFrame*fContMaxcontainer of max range values; TGCompositeFrame*fContMincontainer of min range values; TGCompositeFrame*fContNamcontainer of parameter names; TGCompositeFrame*fContSldcontainer of sliders; TGCompositeFrame*fContValcontainer of parameter values; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TVirtualPad*fFpadpad where the function is drawn; TF1*fFuncfunction passed to this dialog; Bool_tfHasChangeskTRUE if function was redrawn;; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfImmediateDrawkTRUE if function is updated on run-time; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawk",MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:21957,Deployability,update,update,21957,dow used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKCancel button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParFixfix setting check buttons; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPvaloriginal patameters' values; Double_tfRXmaxoriginal max range; Double_tfRXminoriginal min range; Double_tfRangexmaxmax limits of patameters range; Double_tfRangexminmin limits of patameters range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateImmediate update check button; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTG,MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:24444,Deployability,update,update,24444,"mitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax); Create the parameters' dialog of currently selected function 'func'. ~TFunctionParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoFix(Bool_t on); Slot related to the Fix check button. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void RedrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. » Author: Ilka Antcheva 08/05/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TFunctionParametersDialog.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TFunctionParametersDialog.html:24471,Integrability,depend,dependent,24471,"mitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax); Create the parameters' dialog of currently selected function 'func'. ~TFunctionParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoFix(Bool_t on); Slot related to the Fix check button. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void RedrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. » Author: Ilka Antcheva 08/05/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TFunctionParametersDialog.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TFunctionParametersDialog.html
https://root.cern/root/html532/TG16ColorSelector.html:784,Availability,down,down,784,". TG16ColorSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TG16ColorSelector. class TG16ColorSelector: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TG16ColorSelector(const TGWindow* p = 0); virtual~TG16ColorSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual",MatchSource.WIKI,root/html532/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TG16ColorSelector.html
https://root.cern/root/html532/TG16ColorSelector.html:4773,Availability,error,error,4773,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDef",MatchSource.WIKI,root/html532/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TG16ColorSelector.html
https://root.cern/root/html532/TG16ColorSelector.html:4857,Availability,error,error,4857,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFram",MatchSource.WIKI,root/html532/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TG16ColorSelector.html
https://root.cern/root/html532/TG16ColorSelector.html:17319,Availability,mask,mask,17319,,MatchSource.WIKI,root/html532/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TG16ColorSelector.html
https://root.cern/root/html532/TG16ColorSelector.html:18085,Integrability,message,messages,18085,"ame*fCe[16]matrix of color cells; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html532/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TG16ColorSelector.html
https://root.cern/root/html532/TG16ColorSelector.html:19798,Integrability,message,messages,19798,"w::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TG16ColorSelector(const TGWindow* p = 0); TG16ColorSelector constructor.; The TG16ColorSelector is a composite frame with 16 TGColorFrames. ~TG16ColorSelector(); TG16ColorSelector destructor. void SetActive(Int_t newat); Set active color frame. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TG16ColorSelector. TGColorFrame& operator=(const TG16ColorSelector& ). TG16ColorSelector(const TG16ColorSelector& ). Int_t GetActive(); { return fActive; }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGColorSelect.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TG16ColorSelector.html
https://root.cern/root/html532/TGApplication.html:3918,Availability,error,error,3918,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html532/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGApplication.html
https://root.cern/root/html532/TGApplication.html:4002,Availability,error,error,4002,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virt",MatchSource.WIKI,root/html532/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGApplication.html
https://root.cern/root/html532/TGApplication.html:4146,Availability,error,error,4146,"); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; v",MatchSource.WIKI,root/html532/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGApplication.html
https://root.cern/root/html532/TGApplication.html:8007,Availability,error,error,8007,"Libs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const c",MatchSource.WIKI,root/html532/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGApplication.html
https://root.cern/root/html532/TGApplication.html:8128,Availability,error,error,8128,"tual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTObject::SetObjectStat(Bool_t stat); voidTApplication::SetReturnFromRun(Bool_t ret); virtual vo",MatchSource.WIKI,root/html532/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGApplication.html
https://root.cern/root/html532/TGApplication.html:11168,Availability,error,error,11168,"t_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGApplication(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidLoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelet",MatchSource.WIKI,root/html532/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGApplication.html
https://root.cern/root/html532/TGApplication.html:12087,Availability,avail,available,12087,"; static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. ",MatchSource.WIKI,root/html532/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGApplication.html
https://root.cern/root/html532/TGaxis.html:3726,Availability,error,error,3726,"nst TObject* obj) const; virtual voidTLine::Copy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction() const; Float_tGetGridLength() const; virtual const char*TObject::GetIconName() const; Int_tGetLabelColor() const; Int_tGetLabelFont() const; Float_tGetLabelOffset() const; Float_tGetLabelSize() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; static Int_tGetMaxDigits(); virtual const char*GetName() const; Int_tGetNdiv() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual c",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:3810,Availability,error,error,3810,"Object::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction() const; Float_tGetGridLength() const; virtual const char*TObject::GetIconName() const; Int_tGetLabelColor() const; Int_tGetLabelFont() const; Float_tGetLabelOffset() const; Float_tGetLabelSize() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; static Int_tGetMaxDigits(); virtual const char*GetName() const; Int_tGetNdiv() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; virtual Short_tTAttText::GetTextAlign() const; virtual ",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:20770,Modifiability,inherit,inherited,20770,"tripped, and then the; label is correctly aligned. The dot, if last character of the string,; is also stripped, unless this option is specified.; One can disable the option by calling axis.SetDecimals(kTRUE).; Note the bit is set in fBits (as opposed to fBits2 in TAxis!). void SetFunction(const char* funcname = """"); Specify a function to map the axis values. void SetMaxDigits(Int_t maxd = 5); Static function to set fgMaxDigits for axis.; fgMaxDigits is the maximum number of digits permitted for the axis; labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis; call TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0. void SetName(const char* name); Change the name of the axis. void SetMoreLogLabels(Bool_t more = kTRUE); Set the kMoreLogLabels bit flag.; When this option is selected more labels are drawn when in log scale; and there is a small number of decades (<3).; Note that this option is automatically inherited from TAxis. void SetNoExponent(Bool_t noExponent = kTRUE); Set the NoExponent flag.; By default, an exponent of the form 10^N is used when the label values; are either all very small or very large.; One can disable the exponent by calling axis.SetNoExponent(kTRUE). void SetOption(Option_t* option = """"); To set axis options. void SetTitle(const char* title = """"); Change the title of the axis. void SetTimeFormat(const char* tformat); Change the format used for time plotting.; The format string for date and time use the same options as the one used; in the standard strftime C function, i.e. :; for date :; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century. for time :; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. void SetTimeOffset(Double_t toffset, Option_t* option = ""local""); Change the time offset.; If option =",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:18236,Performance,optimiz,optimization,18236,"k mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:18280,Performance,optimiz,optimized,18280,"tered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,WMAX .; nold : Old NDIV (primary d",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:18313,Performance,optimiz,optimization,18313,"divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,WMAX .; nold : Old NDIV (primary divisions); nbins : New NDIV . void LabelsLimits(const ",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:14033,Testability,log,logarithmic,14033,"axis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* funcname, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); TGaxis constructor with a TF1 to map axis values. See explanation of parameters in PaintAxis; Instead of the wmin,wmax arguments of the normal constructor, the; name of a TF1 function can be specified. This function will be used; by TGaxis::PaintAxis to map the user coordinates to the axis values; and ticks.; Examples:; void gaxis3a(); {; gStyle->SetOptStat(0);. TH2F *h2 = new TH2F(""h"",""Axes"",100,0,10,100,-2,2);; h2->Draw();. TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();. TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();. TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,""G"");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }. /*; ; */. TGaxis(const TGaxis& ); Copy constructor. TGaxis& operator=(const TGaxis& ); Assignement operator. ~TGaxis(); TGaxis default destructor. void CenterLabels(Bool_t center = kTRUE); If center = kTRUE axis labels are centered in the center of the bin.; The default is to center on the primary tick marks.; This option does not make sense if there are more bins than tick marks. void CenterTitle(Bool_t center = kTRUE); If center = kTRUE axis title will be centered.; The default is right adjusted. void DrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); Draw this axis with new attributes. Int_t GetMaxDigits(); Static function returning fgMaxDigits (See SetMaxDigits). void ImportAxisAttributes(TAxis* axis); Copy TAxis attributes to",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:18107,Testability,log,log,18107," adjusted on tick mark.; (default is centered); chopt='L': labels are Left adjusted on tick mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer valu",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGaxis.html:20674,Testability,log,log,20674,"etDecimals(Bool_t dot = kTRUE); Set the Decimals flag; By default, blank characters are stripped, and then the; label is correctly aligned. The dot, if last character of the string,; is also stripped, unless this option is specified.; One can disable the option by calling axis.SetDecimals(kTRUE).; Note the bit is set in fBits (as opposed to fBits2 in TAxis!). void SetFunction(const char* funcname = """"); Specify a function to map the axis values. void SetMaxDigits(Int_t maxd = 5); Static function to set fgMaxDigits for axis.; fgMaxDigits is the maximum number of digits permitted for the axis; labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis; call TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0. void SetName(const char* name); Change the name of the axis. void SetMoreLogLabels(Bool_t more = kTRUE); Set the kMoreLogLabels bit flag.; When this option is selected more labels are drawn when in log scale; and there is a small number of decades (<3).; Note that this option is automatically inherited from TAxis. void SetNoExponent(Bool_t noExponent = kTRUE); Set the NoExponent flag.; By default, an exponent of the form 10^N is used when the label values; are either all very small or very large.; One can disable the exponent by calling axis.SetNoExponent(kTRUE). void SetOption(Option_t* option = """"); To set axis options. void SetTitle(const char* title = """"); Change the title of the axis. void SetTimeFormat(const char* tformat); Change the format used for time plotting.; The format string for date and time use the same options as the one used; in the standard strftime C function, i.e. :; for date :; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century. for time :; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. void SetTimeO",MatchSource.WIKI,root/html532/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGaxis.html
https://root.cern/root/html532/TGButton.html:2205,Availability,avail,available,2205,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGButton(const TGWindow* p = 0, Int_t id = -1, GContext_t norm = GetDefaultGC()(), UInt_t option = kRaisedFrame|kDoubleBorder); virtual~TGButton(); voidTObject::AbstractMethod(const char* method) const; virtu",MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:6719,Availability,error,error,6719,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::Ge",MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:6803,Availability,error,error,6803,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:19353,Availability,mask,mask,19353,,MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:20401,Availability,down,down,20401,element; TGButtonGroup*fGroupbutton group this button belongs to; UInt_tTGFrame::fHeightframe height; Pixel_tfHighColorhighlight color; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStatefStatebutton state; Bool_tfStayDowntrue if button has to stay down; UInt_tfStylebutton style (modern or classic); UInt_tfTHeightbutton height; UInt_tfTWidthbutton width; TGToolTip*fTiptool tip associated with button; void*fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC,MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:21543,Deployability,release,released,21543,s from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStatefStatebutton state; Bool_tfStayDowntrue if button has to stay down; UInt_tfStylebutton style (modern or classic); UInt_tfTHeightbutton height; UInt_tfTWidthbutton width; TGToolTip*fTiptool tip associated with button; void*fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tfgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:1931,Integrability,message,message,1931,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:738,Performance,perform,perform,738,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:628,Security,access,access,628,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButton.html:1406,Testability,log,logical,1406," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html532/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButton.html
https://root.cern/root/html532/TGButtonGroup.html:2047,Availability,down,down,2047," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetD",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:7078,Availability,error,error,7078,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tGetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCom",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:7162,Availability,error,error,7162,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tGetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBack",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:16309,Availability,down,down,16309,"t(UInt_t emask); virtual voidTGGroupFrame::Rename(const char* title)MENU ; virtual voidTGFrame::ReparentWindow(const TGWindow* p, Int_t x = 0, Int_t y = 0); virtual voidTGWindow::RequestFocus(); voidTObject::ResetBit(UInt_t f); virtual voidTGFrame::Resize(TGDimension size); virtual voidTGFrame::Resize(UInt_t w = 0, UInt_t h = 0); virtual voidTGObject::SaveAs(const char* filename = """", Option_t* option = """") const; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidTGCompositeFrame::SavePrimitiveSubframes(ostream& out, Option_t* option = """"); voidTGFrame::SaveUserColor(ostream& out, Option_t*); virtual voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderDrawn(Bool_t enable = kTRUE); virtual voidSetButton(Int_t id, Bool_t down = kTRUE); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidSetExclusive(Bool_t flag = kTRUE); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidSetLayoutHints(TGLayoutHints* l, TGButton* button = 0); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWi",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:21098,Availability,mask,mask,21098,,MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:25759,Availability,down,down,25759,"yle"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as their parent widget. An exception is when you want custom; identifiers instead of the default 1, 2, 3 etc. The button is assigned the identifier id or an automatically; generated identifier. It works as follows: If id > 0, this; identifier is assigned. If id == -1 (default), the identifier is; equal to the number of buttons in the group+1. If id is any other; negative integer, for instance -2, a unique identifier (negative; integer <= -2) is generated. Inserting several buttons with id = -1 assigns the identifiers 1,; 2, 3, etc. void Remove(TGButton* button); Removes a button from the button group. TGButton * Find(Int_t id) const; Finds and returns a pointer to the button with the specifi",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:25807,Availability,down,down,25807,"yle"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as their parent widget. An exception is when you want custom; identifiers instead of the default 1, 2, 3 etc. The button is assigned the identifier id or an automatically; generated identifier. It works as follows: If id > 0, this; identifier is assigned. If id == -1 (default), the identifier is; equal to the number of buttons in the group+1. If id is any other; negative integer, for instance -2, a unique identifier (negative; integer <= -2) is generated. Inserting several buttons with id = -1 assigns the identifiers 1,; 2, 3, etc. void Remove(TGButton* button); Removes a button from the button group. TGButton * Find(Int_t id) const; Finds and returns a pointer to the button with the specifi",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:798,Deployability,toggle,toggle,798,". TGButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButtonGroup. class TGButtonGroup: public TGGroupFrame. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is e",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:2164,Deployability,release,released,2164,"parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TStrin",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:25120,Deployability,toggle,toggle,25120," column. TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); Constructor. Layout defined by TGMatrixLayout:; r = number of rows; c = number of columns; s = interval between frames; h = layout hints. void Init(); Default init. ~TGButtonGroup(); Destructor, we do not delete the buttons. void DoRedraw(); Redraw the group frame. Need special DoRedraw() since we need to; redraw with fBorderWidth=0. void DrawBorder(); Draw border of around the group frame. if frame is kRaisedFrame - a frame border is of ""wall style"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as the",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:1378,Modifiability,inherit,inherits,1378,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:2520,Modifiability,inherit,inherits,2520,"th id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendP",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGButtonGroup.html:2733,Modifiability,inherit,inherits,2733,"no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtua",MatchSource.WIKI,root/html532/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html
https://root.cern/root/html532/TGCanvas.html:5256,Availability,error,error,5256,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() ",MatchSource.WIKI,root/html532/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCanvas.html
https://root.cern/root/html532/TGCanvas.html:5340,Availability,error,error,5340,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDro",MatchSource.WIKI,root/html532/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCanvas.html
https://root.cern/root/html532/TGCanvas.html:16857,Availability,mask,mask,16857,,MatchSource.WIKI,root/html532/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCanvas.html
https://root.cern/root/html532/TGCanvas.html:19455,Integrability,message,message,19455,":fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCanvas(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); Create a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& )",MatchSource.WIKI,root/html532/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCanvas.html
https://root.cern/root/html532/TGCheckButton.html:2208,Availability,avail,available,2208,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGCheckButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGCheckButton(const TGWindow* p = 0, const c",MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:7188,Availability,error,error,7188,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const",MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:7272,Availability,error,error,7272,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDDa",MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:21629,Availability,mask,mask,21629,,MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:23368,Availability,down,down,23368,tButton::fMTopmargin top; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*fOffbutton OFF picture; const TGPicture*fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; EButtonStatefPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:24840,Deployability,release,released,24840, window; EButtonStatefPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:1934,Integrability,message,message,1934,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:741,Performance,perform,perform,741,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:631,Security,access,access,631,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGCheckButton.html:1409,Testability,log,logical,1409," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html532/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCheckButton.html
https://root.cern/root/html532/TGClient.html:3690,Availability,error,error,3690,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceRedraw(); voidFreeColor(Pixel_t color) const; voidFreeFont(const TGFont* font); voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); voidFreePicture(const TGPicture* pic); Bool_tGetColorByName(const char* name, Pixel_t& pixel) const; Colormap_tGetDefaultColormap() const; const TGWindow*GetDefaultRoot() const; UInt_tGetDisplayHeight() const; UInt_tGetDisplayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); FontStruct_tGetFontByName(const char* name, Bool_t fixedDefault = kTRUE",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:3774,Availability,error,error,3774,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceRedraw(); voidFreeColor(Pixel_t color) const; voidFreeFont(const TGFont* font); voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); voidFreePicture(const TGPicture* pic); Bool_tGetColorByName(const char* name, Pixel_t& pixel) const; Colormap_tGetDefaultColormap() const; const TGWindow*GetDefaultRoot() const; UInt_tGetDisplayHeight() const; UInt_tGetDisplayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); FontStruct_tGetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; TGFontPool*GetFontPool() const; TGGC*GetGC(GCValues_t* values, Bool_t rw = ",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:14590,Availability,error,error,14590," is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value o",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:15338,Availability,error,error,15338,"use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value of hilite color based on base_color. Pixel_t GetShadow(Pixel_t base_color) const; Return pixel value of shadow color based on base_color.; Shadow is 60% of base_color intensity. void FreeColor(Pixel_t color) const; Free color. void RegisterWindow(TGWindow* w); Add a TGWindow to the clients list of windows. void UnregisterWindow(TGWindow* w); Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHand",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:16927,Availability,down,down,16927," Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHandler(TGUnknownWindowHandler* h); Add handler for unknown (i.e. unregistered) windows. void RemoveUnknownWindowHandler(TGUnknownWindowHandler* h); Remove handler for unknown (i.e. unregistered) windows. void AddIdleHandler(TGIdleHandler* h); Add handler for idle events. void RemoveIdleHandler(TGIdleHandler* h); Remove handler for idle events. TGWindow * GetWindowById(Window_t sw) const; Find a TGWindow via its handle. If window is not found return 0. TGWindow * GetWindowByName(const char* name) const; Find a TGWindow via its name (unique name used in TGWindow::SavePrimitive).; If window is not found return 0. ~TGClient(); Closing down client: cleanup and close X connection. Bool_t ProcessOneEvent(); Process one event. This method should only be called when there is; a GUI event ready to be processed. If event has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the win",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:18277,Availability,mask,masked,18277," more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& opera",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:18410,Availability,mask,masked,18410,"s input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& operator=(const TGClient& ). Bool_t IsEditable() const; { return fRoot != fDefaultRoot; }. void ForceRedraw(); { fForce",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:18449,Availability,mask,masked,18449,"cessed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& operator=(const TGClient& ). Bool_t IsEditable() const; { return fRoot != fDefaultRoot; }. void ForceRedraw(); { fForceRedraw = kTRUE; }. EGEventType GetWaitForEvent() const; { return fWaitForEvent;}. W",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:12993,Integrability,message,message,12993,"odern or classic); TList*fUWHandlerslist of event handlers for unknown windows; EGEventTypefWaitForEventevent to wait for; Window_tfWaitForWindowwindow in which to wait for event; Pixel_tfWhitewhite color index; THashList*fWlistlist of frames; Int_tfXfdfile descriptor of connection to server; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGClient(const char* dpyName = 0); Create a connection with the display sever on host dpyName and setup; the complete GUI system, i.e., graphics contexts, fonts, etc. for all; widgets. const TGWindow * GetRoot() const; Returns current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. const TGWindow * GetDefaultRoot() const; Returns the root (i.e. desktop) window. Should only be used as parent; for frames that will never be embedded, like popups, message boxes,; etc. (like TGToolTips, TGMessageBox, etc.). void SetRoot(TGWindow* root = 0); Sets the current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. void SetStyle(const char* style); Set the button style (modern or classic). UInt_t GetDisplayWidth() const; Get display width. UInt_t GetDisplayHeight() const; Get display height. const TGPicture * GetPicture(const char* name); Get picture from the picture pool. Picture must be freed using; TGClient::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(G",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:14303,Integrability,interface,interface,14303,"nother window. void SetStyle(const char* style); Set the button style (modern or classic). UInt_t GetDisplayWidth() const; Get display width. UInt_t GetDisplayHeight() const; Get display height. const TGPicture * GetPicture(const char* name); Get picture from the picture pool. Picture must be freed using; TGClient::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not f",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:15350,Performance,load,loaded,15350," FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value of hilite color based on base_color. Pixel_t GetShadow(Pixel_t base_color) const; Return pixel value of shadow color based on base_color.; Shadow is 60% of base_color intensity. void FreeColor(Pixel_t color) const; Free color. void RegisterWindow(TGWindow* w); Add a TGWindow to the clients list of windows. void UnregisterWindow(TGWindow* w); Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHandler(TGUnknownWindowHandler* h); Add handler for unknown (i.e. unregistered) windows. v",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:18114,Performance,queue,queue,18114," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGClient.html:18138,Security,expose,expose,18138," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root/html532/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGClient.html
https://root.cern/root/html532/TGColorDialog.html:5115,Availability,error,error,5115,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); TGColorPalette*GetCustomPalette() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; st",MatchSource.WIKI,root/html532/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorDialog.html
https://root.cern/root/html532/TGColorDialog.html:5199,Availability,error,error,5199,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); TGColorPalette*GetCustomPalette() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeF",MatchSource.WIKI,root/html532/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorDialog.html
https://root.cern/root/html532/TGColorDialog.html:20093,Availability,mask,mask,20093,,MatchSource.WIKI,root/html532/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorDialog.html
https://root.cern/root/html532/TGColorDialog.html:24431,Integrability,message,messages,24431,"tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorDialog(const TGWindow* p = 0, const TGWindow* m = 0, Int_t* retc = 0, Pixel_t* color = 0, Bool_t wait = kTRUE); Color selection dialog constructor.; The TGColorDialog presents a full featured color selection dialog.; It uses 2 TGColorPalette's and the TGColorPick widgets. ~TGColorDialog(); TGColorDialog destructor. void SetCurrentColor(Pixel_t col); Change current color. void ColorSelected(Pixel_t ); Emit signal about selected color. void CloseWindow(); Called when window is closed via window manager. void UpdateRGBentries(Pixel_t* c); Update RGB text entries with RGB values of color c. void UpdateHLSentries(Pixel_t* c); Update HLS text entries with HLS values of color c. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for the color selection dialog. void SetColorInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Set the color info in RGB and HLS parts. void DoPreview(); Slot method called when Preview button is clicked. TGColorPalette& operator=(const TGColorDialog& ). TGColorDialog(const TGColorDialog& ). TGColorPalette * GetPalette() const; { return fPalette; }. TGColorPalette * GetCustomPalette() const; { return fCpalette; }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGColorDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorDialog.html
https://root.cern/root/html532/TGColorFrame.html:760,Availability,down,down,760,". TGColorFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorFrame. class TGColorFrame: public TGFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorFrame(const TGWindow* p = 0, Pixel_t c = 0, Int_t n = 1); virtual~TGColorFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connec",MatchSource.WIKI,root/html532/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorFrame.html
https://root.cern/root/html532/TGColorFrame.html:4563,Availability,error,error,4563,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragTyp",MatchSource.WIKI,root/html532/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorFrame.html
https://root.cern/root/html532/TGColorFrame.html:4647,Availability,error,error,4647,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::Ge",MatchSource.WIKI,root/html532/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorFrame.html
https://root.cern/root/html532/TGColorFrame.html:15854,Availability,mask,mask,15854,,MatchSource.WIKI,root/html532/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorFrame.html
https://root.cern/root/html532/TGColorFrame.html:16400,Integrability,message,messages,16400,,MatchSource.WIKI,root/html532/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorFrame.html
https://root.cern/root/html532/TGColorPalette.html:4704,Availability,error,error,4704,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColorByIndex(Int_t ix) const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPalette.html
https://root.cern/root/html532/TGColorPalette.html:4788,Availability,error,error,4788,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColorByIndex(Int_t ix) const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPalette.html
https://root.cern/root/html532/TGColorPalette.html:16766,Availability,mask,mask,16766,,MatchSource.WIKI,root/html532/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPalette.html
https://root.cern/root/html532/TGColorPick.html:4683,Availability,error,error,4683,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetD",MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPick.html:4767,Availability,error,error,4767,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject:",MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPick.html:16844,Availability,mask,mask,16844,,MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPick.html:19974,Availability,error,error,19974,". Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGColorDialog.h 23115 2008-04-10 13:35:37Z rd",MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPick.html:19655,Energy Efficiency,allocate,allocate,19655,"ton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pix",MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPick.html:19767,Energy Efficiency,allocate,allocated,19767,"UserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col",MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPick.html:19928,Energy Efficiency,reduce,reduced,19928,"ormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 199",MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPick.html:20026,Integrability,rout,routine,20026,"0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGColorDialog.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been ",MatchSource.WIKI,root/html532/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPick.html
https://root.cern/root/html532/TGColorPopup.html:769,Availability,down,down,769,". TGColorPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorPopup. class TGColorPopup: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorPopup(const TGWindow* p = 0, const TGWindow* m = 0, Pixel_t color = 0); virtual~TGColorPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_",MatchSource.WIKI,root/html532/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPopup.html
https://root.cern/root/html532/TGColorPopup.html:4806,Availability,error,error,4806,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPopup.html
https://root.cern/root/html532/TGColorPopup.html:4890,Availability,error,error,4890,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPopup.html
https://root.cern/root/html532/TGColorPopup.html:17362,Availability,mask,mask,17362,,MatchSource.WIKI,root/html532/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPopup.html
https://root.cern/root/html532/TGColorPopup.html:18184,Integrability,message,messages,18184,"orcurrently selected color value; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Int_tfLaunchDialogflag used for launching color dialog; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html532/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPopup.html
https://root.cern/root/html532/TGColorPopup.html:20171,Integrability,message,messages,20171,"ls; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPopup(const TGWindow* p = 0, const TGWindow* m = 0, Pixel_t color = 0); TGColorPopup constructor.; The TGColorPopup is a popup containing a TG16ColorSelector and a ""More...""; button which popups up a TGColorDialog allowing custom color selection. ~TGColorPopup(); TGColorPopup destructor. void EndPopup(); Ungrab pointer and unmap window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Popup TGColorPopup at x,y position. Bool_t HandleButton(Event_t* event); Handle mouse button events for TGColorPopup. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorPopup. void PreviewColor(Pixel_t color); Emit a signal to see preview. TGColorFrame& operator=(const TGColorPopup& ). TGColorPopup(const TGColorPopup& ). » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGColorSelect.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorPopup.html
https://root.cern/root/html532/TGColorSelect.html:769,Availability,down,down,769,". TGColorSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorSelect. class TGColorSelect: public TGCheckButton. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); virtual~TGColorSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ",MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColorSelect.html:4895,Availability,error,error,4895,"nal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelected",MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColorSelect.html:4979,Availability,error,error,4979,"ject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetD",MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColorSelect.html:19795,Availability,mask,mask,19795,,MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColorSelect.html:21638,Availability,down,down,21638, frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGPositionfPressPospsotion of frame on button press event; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColorSelect.html:23609,Availability,down,down,23609,"me::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); TGColorSelect constructor.; The TGColorSelect widget is like a checkbutton but instead of the check; mark there is color area with a little down arrow.; When clicked on the arrow the TGColorPopup pops up. ~TGColorSelect(); TGColorSelect destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorSelect. Bool_t HandleButton(Event_t* event); Handle button events for TGColorSelect. void Enable(Bool_t on = kTRUE); Set state of widget as enabled. void Disable(); Set state of widget as disabled. void DoRedraw(); Redraw TGColorSelect widget. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw triangle (arrow) on which user can click to open TGColorPopup. void SetColor(Pixel_t color, Bool_t emit = kTRUE); Set color. void SavePrimitive(ostream& out, Option_t* = """"); Save a color select widget as a C++ statement(s) on output stream out. TGColorFrame& operator=(const TGColorSelect& ). Pixel_t GetColor() const; { return fColor; }. TGColorSelect(const TGColorSelect& ). void SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); dummy methods j",MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColorSelect.html:23140,Deployability,release,released,23140,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColorSelect.html:23789,Integrability,message,messages,23789,"ound; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); TGColorSelect constructor.; The TGColorSelect widget is like a checkbutton but instead of the check; mark there is color area with a little down arrow.; When clicked on the arrow the TGColorPopup pops up. ~TGColorSelect(); TGColorSelect destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorSelect. Bool_t HandleButton(Event_t* event); Handle button events for TGColorSelect. void Enable(Bool_t on = kTRUE); Set state of widget as enabled. void Disable(); Set state of widget as disabled. void DoRedraw(); Redraw TGColorSelect widget. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw triangle (arrow) on which user can click to open TGColorPopup. void SetColor(Pixel_t color, Bool_t emit = kTRUE); Set color. void SavePrimitive(ostream& out, Option_t* = """"); Save a color select widget as a C++ statement(s) on output stream out. TGColorFrame& operator=(const TGColorSelect& ). Pixel_t GetColor() const; { return fColor; }. TGColorSelect(const TGColorSelect& ). void SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); dummy methods just to remove from context menu. { TGButton::SetDown(on, emit); }. void Rename(const char* title); { TGTextButton::SetTitle(title); }. void SetEnabled(Bool_t e = kTRUE); {TGButton::SetEnabled(e); }. TGDimensio",MatchSource.WIKI,root/html532/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColorSelect.html
https://root.cern/root/html532/TGColumnLayout.html:787,Availability,down,downward,787,". TGColumnLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColumnLayout. class TGColumnLayout: public TGRowLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGColumnLayout(const TGColumnLayout&); TGColumnLayout(TGCompositeFrame* main, Int_t s = 0); ~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(O",MatchSource.WIKI,root/html532/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColumnLayout.html
https://root.cern/root/html532/TGColumnLayout.html:2329,Availability,error,error,2329,"umnLayout&); TGColumnLayout(TGCompositeFrame* main, Int_t s = 0); ~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html532/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColumnLayout.html
https://root.cern/root/html532/TGColumnLayout.html:2413,Availability,error,error,2413," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html532/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGColumnLayout.html
https://root.cern/root/html532/TGComboBox.html:377,Availability,down,down,377,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:614,Availability,down,down,614,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:5231,Availability,error,error,5231,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefa",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:5315,Availability,error,error,5315,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TD",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:18950,Availability,down,down,18950,,MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:19105,Availability,mask,mask,19105,,MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:22453,Deployability,update,update,22453," static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a combo box widget. TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create an editable combo box widget. ~TGComboBox(); Delete a combo box widget. void Init(); Initiate the internal classes of a combo box. void DrawBorder(); Draw border of combo box widget. void EnableTextInput(Bool_t on); Switch text input or readonly mode of combobox (not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t wi",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:23271,Integrability,message,messages,23271,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBoxPopup& operator=(const TGComboBox& ). TGComboBox(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); ",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:23318,Integrability,message,messages,23318,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBoxPopup& operator=(const TGComboBox& ). TGComboBox(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); ",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBox.html:23343,Integrability,message,message,23343,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBoxPopup& operator=(const TGComboBox& ). TGComboBox(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); ",MatchSource.WIKI,root/html532/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBox.html
https://root.cern/root/html532/TGComboBoxPopup.html:375,Availability,down,down,375,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBoxPopup(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); ~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObj",MatchSource.WIKI,root/html532/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBoxPopup.html
https://root.cern/root/html532/TGComboBoxPopup.html:612,Availability,down,down,612,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBoxPopup(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); ~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObj",MatchSource.WIKI,root/html532/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBoxPopup.html
https://root.cern/root/html532/TGComboBoxPopup.html:4824,Availability,error,error,4824,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBoxPopup.html
https://root.cern/root/html532/TGComboBoxPopup.html:4908,Availability,error,error,4908,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBoxPopup.html
https://root.cern/root/html532/TGComboBoxPopup.html:17344,Availability,mask,mask,17344,,MatchSource.WIKI,root/html532/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGComboBoxPopup.html
https://root.cern/root/html532/TGCommandPlugin.html:4359,Availability,error,error,4359,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html532/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCommandPlugin.html
https://root.cern/root/html532/TGCommandPlugin.html:4443,Availability,error,error,4443,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html532/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCommandPlugin.html
https://root.cern/root/html532/TGCommandPlugin.html:18675,Availability,mask,mask,18675,,MatchSource.WIKI,root/html532/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCommandPlugin.html
https://root.cern/root/html532/TGCommandPlugin.html:20193,Deployability,update,update,20193,tions! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tfPidcurrent process id; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGTextView*fStatusoutput capture view; TTimer*fTimerfor local/remote update; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby;,MatchSource.WIKI,root/html532/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCommandPlugin.html
https://root.cern/root/html532/TGCompositeFrame.html:5277,Availability,error,error,5277,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html532/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html
https://root.cern/root/html532/TGCompositeFrame.html:5361,Availability,error,error,5361,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html532/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html
https://root.cern/root/html532/TGCompositeFrame.html:16882,Availability,mask,mask,16882,,MatchSource.WIKI,root/html532/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html
https://root.cern/root/html532/TGCompositeFrame.html:19820,Performance,load,load,19820,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root/html532/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html
https://root.cern/root/html532/TGCompositeFrame.html:1364,Testability,log,logically,1364,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); virtual voidChangeSubframesBackground(Pixel_t back); stat",MatchSource.WIKI,root/html532/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html
https://root.cern/root/html532/TGCompositeFrame.html:19802,Testability,test,test,19802,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root/html532/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html
https://root.cern/root/html532/TGCompositeFrame.html:566,Usability,simpl,simple,566,". TGCompositeFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCompositeFrame. class TGCompositeFrame: public TGFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSigna",MatchSource.WIKI,root/html532/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGCompositeFrame.html
https://root.cern/root/html532/TGContainer.html:6042,Availability,error,error,6042," signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); ",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:6126,Availability,error,error,6126,"TQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:12341,Availability,mask,mask,12341,"tual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual voidInvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidKeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLayout(); virtual voidLineDown(Bool_t select = kFALSE); virtual voidLineLeft(Bool_t select = kFALSE); virtual voidLineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual Int_tNumItems() const; virtual ",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:20342,Availability,mask,mask,20342,,MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:24210,Availability,mask,mask,24210,":fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicke",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:24320,Availability,mask,mask,24320,"tation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGFrame* f, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGFrame* f, Int_t btn, Int_t x",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:24340,Availability,mask,mask,24340,"tation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGFrame* f, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGFrame* f, Int_t btn, Int_t x",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:28526,Availability,down,down,28526,"The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); Find frame located int container at position x,y. void * FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE). TGHScrollBar * GetHScrollbar() const; returns pointer to hor. scroll bar. TGVScrollBar * GetVScrollbar() const; returns pointer to vert. scroll bar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetHsbPosition(Int_t newPos); set new hor. position. void AdjustPosition(); Move content to position of highlighted/activated frame. void LineLeft(Bool_t select = kFALSE); Move current position one column left. void LineRight(Bool_t select = kFALSE); Move current position one column right. void LineUp(Bool_t select = kFALSE); Make current position first line in window by scrolling up. void LineDown(Bool_t select = kFALSE); Move one line down. void PageUp(Bool_t select = kFALSE); Move position one page up. void PageDown(Bool_t select = kFALSE); Move position one page down. void Home(Bool_t select = kFALSE); Move to upper-left corner of container. void End(Bool_t select = kFALSE); Move to the bottom-right corner of container. const TGGC & GetLineGC(); Get graphics context for line drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas container as a C++ statement(s) on output stream out. TGContainer(const TGContainer& ). TGContainer& operator=(const TGContainer& ). void Associate(const TGWindow* w); { fMsgWindow = w; }. TGCanvas * GetCanvas() const; { return fCanvas; }. const TGWindow * GetMessageWindow() const; { return fMsgWindow; }. Int_t NumSelected() const; { return fSelected; }. Int_t NumItems() const; { return fTotal; }. TGFrame * GetLastActive() const; { return fLastActiveEl ? fLastActiveEl->fFrame : 0; }. Bool_t HandleDNDFinished(); { fBdown = kFALSE; return kTRU",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:28658,Availability,down,down,28658,"ment * FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); Find frame located int container at position x,y. void * FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE). TGHScrollBar * GetHScrollbar() const; returns pointer to hor. scroll bar. TGVScrollBar * GetVScrollbar() const; returns pointer to vert. scroll bar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetHsbPosition(Int_t newPos); set new hor. position. void AdjustPosition(); Move content to position of highlighted/activated frame. void LineLeft(Bool_t select = kFALSE); Move current position one column left. void LineRight(Bool_t select = kFALSE); Move current position one column right. void LineUp(Bool_t select = kFALSE); Make current position first line in window by scrolling up. void LineDown(Bool_t select = kFALSE); Move one line down. void PageUp(Bool_t select = kFALSE); Move position one page up. void PageDown(Bool_t select = kFALSE); Move position one page down. void Home(Bool_t select = kFALSE); Move to upper-left corner of container. void End(Bool_t select = kFALSE); Move to the bottom-right corner of container. const TGGC & GetLineGC(); Get graphics context for line drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas container as a C++ statement(s) on output stream out. TGContainer(const TGContainer& ). TGContainer& operator=(const TGContainer& ). void Associate(const TGWindow* w); { fMsgWindow = w; }. TGCanvas * GetCanvas() const; { return fCanvas; }. const TGWindow * GetMessageWindow() const; { return fMsgWindow; }. Int_t NumSelected() const; { return fSelected; }. Int_t NumItems() const; { return fTotal; }. TGFrame * GetLastActive() const; { return fLastActiveEl ? fLastActiveEl->fFrame : 0; }. Bool_t HandleDNDFinished(); { fBdown = kFALSE; return kTRUE; }. » Author: Fons Rademakers 11/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:21520,Integrability,message,messages,21520,; TStringfKeyInputkeyboard input (buffer); TTimer*fKeyTimerkeyboard timer; Bool_tfKeyTimerActivekTRUE - keyboard timer is active; TGFrameElement*fLastActiveEllast active item; Bool_tfLastCasecase sensetivity of last search; Bool_tfLastDirdirection of last search; TStringfLastNamethe name of object of last search; Bool_tfLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tfOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*fScrollTimerautoscroll timer; Bool_tfScrollingkTRUE - when scrolling is ON; Int_tfSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfTotaltotal items; TGViewPort*fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tfX0; Int_tfXDND; Int_tfXf; Int_tfXp; Int_tTGFrame::fYframe y position; Int_tfY0corner of rubber band box; Int_tfYDND; Int_tfYfother corner of rubber band box; Int_tfYpprevious pointer position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; stati,MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGContainer.html:26657,Security,expose,expose,26657,"emove all items from the container. void RemoveItem(TGFrame* item); Remove item from container. const TGFrame * GetNextSelected(void** current); Return next selected item. void ActivateItem(TGFrameElement* el); Activate item. void DeActivateItem(TGFrameElement* el); DeActivate item. TGPosition GetPagePosition() const; Returns page position. TGDimension GetPageDimension() const; Returns page dimension. void SetPagePosition(const TGPosition& pos); Set page position. void SetPagePosition(Int_t x, Int_t y); Set page position. void SetPageDimension(const TGDimension& dim); Set page dimension. void SetPageDimension(UInt_t w, UInt_t h); Set page dimension. void DoRedraw(); Redraw content of container in the viewport region. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw a region of container in viewport.; x, y, w, h are position and dimension of area to be; redrawn in viewport coordinates. void ClearViewPort(); Clear view port and redraw full content. Bool_t HandleExpose(Event_t* event); Handle expose events. Do not use double buffer. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. const TGPicture * GetObjPicture(TGFrame* f); Retrieve icons associated with class ""name"". Association is made; via the user's ~/.root.mimes file or via $ROOTSYS/etc/root.mimes. void SetDragPixmap(const TGPicture* pic); Set drag window pixmaps and hotpoint. Bool_t HandleDoubleClick(Event_t* event); Handle double click mouse event. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. TGFrame * FindFrameByName(const char* name); Find frame by name. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void OnAutoScroll(); Autoscroll while close to & beyond The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFr",MatchSource.WIKI,root/html532/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGContainer.html
https://root.cern/root/html532/TGDMLParse.html:1307,Availability,error,error,1307,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html532/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLParse.html
https://root.cern/root/html532/TGDMLParse.html:1391,Availability,error,error,1391,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html532/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLParse.html
https://root.cern/root/html532/TGDMLParse.html:10696,Integrability,depend,depending,10696,"nd the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. TString GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces it wi",MatchSource.WIKI,root/html532/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLParse.html
https://root.cern/root/html532/TGDMLParse.html:10680,Modifiability,variab,variable,10680,"nd the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. TString GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces it wi",MatchSource.WIKI,root/html532/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLParse.html
https://root.cern/root/html532/TGDMLParse.html:1717,Testability,test,test,1717,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html532/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLParse.html
https://root.cern/root/html532/TGDMLParse.html:10073,Testability,test,test,10073,"dium names and the TGeoMedium for it; TGDMMapHelper<TGeoMixture>fmixmap!Map containing mixture names and the TGeoMixture for it; TGDMMapHelper<TGeoTranslation>fposmap!Map containing position names and the TGeoTranslation for it; map<string,string>freflectmap!Map containing reflection names and the Solid name ir references to; TGDMMapHelper<TGDMLRefl>freflsolidmap!Map containing reflection names and the TGDMLRefl for it - containing refl matrix; map<string,string>freflvolmap!Map containing reflected volume names and the solid ref for it; TGDMMapHelper<TGeoRotation>frotmap!Map containing rotation names and the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePoin",MatchSource.WIKI,root/html532/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLParse.html
https://root.cern/root/html532/TGDMLParse.html:17192,Usability,simpl,simple,17192,"the original assembly using TGeoVolume->AddNode. XMLNodePointer_t TopProcess(TXMLEngine* gdml, XMLNodePointer_t node); In the setup section of the GDML file, the top volume need to be; declared. when the setup keyword is found, this function is called,; and the top volume ref is taken and 'world' is set. XMLNodePointer_t Box(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a box may be declared.; when the box keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Ellipsoid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an ellipsoid may be declared.; Unfortunately, the ellipsoid is not supported under ROOT so,; when the ellipsoid keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Paraboloid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a Paraboloid may be declared.; when the paraboloid keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoParaboloid and stored in fsolmap map using the name; as its key. XMLNodePointer_t Arb8(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an Arb8 may be declared.; when the arb8 keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoArb8 and stored in fsolmap map using the name; as its key. XMLNodePointer_t Tube(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrP",MatchSource.WIKI,root/html532/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLParse.html
https://root.cern/root/html532/TGDMLRefl.html:1368,Availability,error,error,1368,"LRefl(const char* name, const char* solid, TGeoMatrix* matrix); virtual~TGDMLRefl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(co",MatchSource.WIKI,root/html532/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLRefl.html
https://root.cern/root/html532/TGDMLRefl.html:1452,Availability,error,error,1452," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) co",MatchSource.WIKI,root/html532/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLRefl.html
https://root.cern/root/html532/TGDMLRefl.html:5540,Security,access,accessor,5540," voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TGeoMatrix*fMatrix!matrix of reflected solid; const char*fNameS!reflected solid name; const char*fSolid!solid name being reflected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix); this constructor method stores the values brought in as params. TGeoMatrix* GetMatrix(); this accessor method returns the matrix. TGDMLRefl(). virtual ~TGDMLRefl(); {}. TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix). » Last changed: Thu Nov 3 20:13:53 2011 » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLRefl.html
https://root.cern/root/html532/TGDMLWrite.html:1307,Availability,error,error,1307," TGDMLWrite(); TGDMLWrite(const TGDMLWrite&); virtual~TGDMLWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtu",MatchSource.WIKI,root/html532/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLWrite.html
https://root.cern/root/html532/TGDMLWrite.html:1391,Availability,error,error,1391," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLWrite.html
https://root.cern/root/html532/TGDMLWrite.html:8509,Availability,error,errors,8509,"MLNodePointer_tExtractMaterials(TList* materialsLst); voidExtractSolids(TObjArray* shapesLst); voidExtractVolumes(TGeoVolume* volume); TStringGenName(TString oldname); TStringGenName(TString oldname, TString objPointer); TStringGetPattAxis(Int_t divAxis, const char* pattName, TString& unit); TGDMLWrite::XyzGetXYZangles(const Double_t* rotationMatrix); Bool_tIsInList(TGDMLWrite::NameList list, TString name2check); XMLNodePointer_tStartAssemblyN(const char* name); XMLNodePointer_tStartVolumeN(const char* name, const char* solid, const char* material). Data Members; public:. enum ENamingType { kelegantButSlow; kwithoutSufixNotUniq; kfastButUglySufix; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TGDMLWrite::StructLst*fAccPattlist of accepted patterns for division; UInt_tfActNameErrcount of name errors; XMLNodePointer_tfDefineNodemain <define> node...; TGDMLWrite::StructLst*fElementListlist of elements; TXMLEngine*fGdmlE; XMLDocPointer_tfGdmlFile; TGDMLWrite::StructLst*fIsotopeListlist of isotopes; TGDMLWrite::StructLst*fMaterialListlist of materials; XMLNodePointer_tfMaterialsNodemain <materials> node...; TGDMLWrite::NameLst*fNameListlist of names (pointer mapped); Int_tfPhysVolCntcount of physical volumes; TGDMLWrite::StructLst*fRejShapelist of rejected shapes; TGDMLWrite::StructLst*fShapeListlist of solids; UInt_tfSolCntcount of name solids; XMLNodePointer_tfSolidsNodemain <solids> node...; XMLNodePointer_tfStructureNodemain <structure> node...; TStringfTopVolumeName; Int_tfVolCntcount of volumes; TGDMLWrite::StructLst*fVolumeListlist of volumes; Bool_tfgG4Compatibility; static TGDMLWrite*fgGDMLWritepointer to gdml writer; Int_tfgNamingSpeed; static const UInt_tfgkMaxNameErrmaximum number of errors for naming; static const UInt_tfgkProcBit14th bit is",MatchSource.WIKI,root/html532/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLWrite.html
https://root.cern/root/html532/TGDMLWrite.html:9426,Availability,error,errors,9426,"kWriteDelete; };. private:. TGDMLWrite::StructLst*fAccPattlist of accepted patterns for division; UInt_tfActNameErrcount of name errors; XMLNodePointer_tfDefineNodemain <define> node...; TGDMLWrite::StructLst*fElementListlist of elements; TXMLEngine*fGdmlE; XMLDocPointer_tfGdmlFile; TGDMLWrite::StructLst*fIsotopeListlist of isotopes; TGDMLWrite::StructLst*fMaterialListlist of materials; XMLNodePointer_tfMaterialsNodemain <materials> node...; TGDMLWrite::NameLst*fNameListlist of names (pointer mapped); Int_tfPhysVolCntcount of physical volumes; TGDMLWrite::StructLst*fRejShapelist of rejected shapes; TGDMLWrite::StructLst*fShapeListlist of solids; UInt_tfSolCntcount of name solids; XMLNodePointer_tfSolidsNodemain <solids> node...; XMLNodePointer_tfStructureNodemain <structure> node...; TStringfTopVolumeName; Int_tfVolCntcount of volumes; TGDMLWrite::StructLst*fVolumeListlist of volumes; Bool_tfgG4Compatibility; static TGDMLWrite*fgGDMLWritepointer to gdml writer; Int_tfgNamingSpeed; static const UInt_tfgkMaxNameErrmaximum number of errors for naming; static const UInt_tfgkProcBit14th bit is set when solid is processed; static const UInt_tfgkProcBitVol19th bit is set when volume is processed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLWrite(); Default constructor. ~TGDMLWrite(); Destructor. void SetNamingSpeed(TGDMLWrite::ENamingType naming). void WriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.gdml"", TString option = """"); Wrapper of all exporting methods; Creates blank GDML file and fills it with gGeoManager structure converted; to GDML structure xml nodes. XMLNodePointer_t ExtractMaterials(TList* materialsLst). void ExtractSolids(TObjArray* shapesLst). void ExtractVolumes(TGeoVolume* volume). XMLNodePointer_t CreateAtomN(Double_t atom, const char* unit = ""g/mole""); Creates ""atom"" node for GDML. XMLNodePointer_t CreateDN(Double_t density, const char* unit = ""g/cm3""); Creates ""D"" density node for G",MatchSource.WIKI,root/html532/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLWrite.html
https://root.cern/root/html532/TGDMLWrite.html:4804,Testability,test,test,4804,"bject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGDMLWrite&operator=(const TGDMLWrite&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetG4Compatibility(Bool_t G4Compatible); voidSetNamingSpeed(TGDMLWrite::ENamingType naming); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidWriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.",MatchSource.WIKI,root/html532/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLWrite.html
https://root.cern/root/html532/TGDMLWrite.html:9863,Testability,test,test,9863,"Write::NameLst*fNameListlist of names (pointer mapped); Int_tfPhysVolCntcount of physical volumes; TGDMLWrite::StructLst*fRejShapelist of rejected shapes; TGDMLWrite::StructLst*fShapeListlist of solids; UInt_tfSolCntcount of name solids; XMLNodePointer_tfSolidsNodemain <solids> node...; XMLNodePointer_tfStructureNodemain <structure> node...; TStringfTopVolumeName; Int_tfVolCntcount of volumes; TGDMLWrite::StructLst*fVolumeListlist of volumes; Bool_tfgG4Compatibility; static TGDMLWrite*fgGDMLWritepointer to gdml writer; Int_tfgNamingSpeed; static const UInt_tfgkMaxNameErrmaximum number of errors for naming; static const UInt_tfgkProcBit14th bit is set when solid is processed; static const UInt_tfgkProcBitVol19th bit is set when volume is processed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLWrite(); Default constructor. ~TGDMLWrite(); Destructor. void SetNamingSpeed(TGDMLWrite::ENamingType naming). void WriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.gdml"", TString option = """"); Wrapper of all exporting methods; Creates blank GDML file and fills it with gGeoManager structure converted; to GDML structure xml nodes. XMLNodePointer_t ExtractMaterials(TList* materialsLst). void ExtractSolids(TObjArray* shapesLst). void ExtractVolumes(TGeoVolume* volume). XMLNodePointer_t CreateAtomN(Double_t atom, const char* unit = ""g/mole""); Creates ""atom"" node for GDML. XMLNodePointer_t CreateDN(Double_t density, const char* unit = ""g/cm3""); Creates ""D"" density node for GDML. XMLNodePointer_t CreateFractionN(Double_t percentage, const char* refName); Creates ""fraction"" node for GDML. XMLNodePointer_t CreateIsotopN(TGeoIsotope* isotope, const char* name); Creates ""isotope"" node for GDML. XMLNodePointer_t CreateElementN(TGeoElement* element, XMLNodePointer_t materials, const char* name); Creates ""element"" node for GDML; element node and attribute. XMLNodePointer_t CreateMixtureN(TGeoMixture* mixture, XMLNodePointer",MatchSource.WIKI,root/html532/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDMLWrite.html
https://root.cern/root/html532/TGDNDManager.html:1477,Availability,error,error,1477,"ctMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDrag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Bool_tDrop(); virtual voidTObject::Dump() constMENU ; Bool_tEndDrag(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static Atom_tGetDNDActionAsk(); static Atom_tGetDNDActionCopy(); static Atom_tGetDNDActionDescrip(); static Atom_tGetDNDActionLink(); static Atom_tGetDNDActionList(); static Atom_tGetDNDActionMove(); static Atom_tGetDNDActionPrivate(); static Atom_tGetDNDAware(); static Atom_tGetDNDDrop(); static Atom_tGetDNDEnter(); static Atom_tGetDNDFinished(); static Atom_tGetDNDLeave(); static Atom_tGetDNDPosition(); static Atom_tGetDNDProxy(); static Atom_tGetDNDSelection(); static Atom_tGetDNDStatus(); static Atom_tGetDNDTypeList(); static Atom_tGetDNDVersion(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:1561,Availability,error,error,1561,"= """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDrag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Bool_tDrop(); virtual voidTObject::Dump() constMENU ; Bool_tEndDrag(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static Atom_tGetDNDActionAsk(); static Atom_tGetDNDActionCopy(); static Atom_tGetDNDActionDescrip(); static Atom_tGetDNDActionLink(); static Atom_tGetDNDActionList(); static Atom_tGetDNDActionMove(); static Atom_tGetDNDActionPrivate(); static Atom_tGetDNDAware(); static Atom_tGetDNDDrop(); static Atom_tGetDNDEnter(); static Atom_tGetDNDFinished(); static Atom_tGetDNDLeave(); static Atom_tGetDNDPosition(); static Atom_tGetDNDProxy(); static Atom_tGetDNDSelection(); static Atom_tGetDNDStatus(); static Atom_tGetDNDTypeList(); static Atom_tGetDNDVersion(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGFrame*GetMainFrame() const; v",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:4902,Availability,mask,mask,4902,"::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRemoveRootProxy(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMainFrame(TGFrame* main); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRootProxy(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Bool_tStartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:7529,Availability,mask,mask,7529,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:11562,Availability,mask,mask,11562," to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start dragging. Bool_t Drop(); Drop. Bool_t EndDrag(); End dragging. Bool_t Drag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); Process drag event. Bool_t SetRootProxy(); Set root window proxy. Bool_t RemoveRootProxy(); Remove root window proxy. TDNDData& operator=(const TGDNDManager& ). TGDNDManager(const TGDNDManager& ). Bool_t IsTopLevel(Window_t win). TGFrame * GetMainFrame() const; --- called by widgets. { return fMain; }. void SetMainFrame(TGFrame* main); { fMain = main; }. Bool_t IsDragging() const; { return fDragging; }. Window_t GetSource() const; { return fSource; }. Window_t GetTarget() const; { return fTarget; }. Atom_t * GetTypeList() const; { return fTypelist; }. » Author: Bertrand Bellenot 19/04/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDNDManager.h 23115 2008-04",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10248,Integrability,message,messages,10248,"gDNDStatus; }. Atom_t GetDNDDrop(); { return fgDNDDrop; }. Atom_t GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND s",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10361,Integrability,message,message,10361,"n(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target)",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10438,Integrability,message,message,10438,"nCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); H",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10568,Integrability,message,message,10568,"DNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void Set",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10662,Integrability,message,message,10662,"gDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t ",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10737,Integrability,message,message,10737,"DNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start ",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10817,Integrability,message,message,10817,"return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start dragging. Bool_t Drop(); Drop. Bool_t EndDrag(); End dragging. Bool_t Drag(In",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:7455,Safety,timeout,timeout,7455,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDNDManager.html:10301,Safety,timeout,timeout,10301,"GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp);",MatchSource.WIKI,root/html532/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDNDManager.html
https://root.cern/root/html532/TGDockableFrame.html:4760,Availability,error,error,4760,"am); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::",MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:4844,Availability,error,error,4844,"t char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; vir",MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:18112,Availability,mask,mask,18112,,MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:21236,Integrability,message,messages,21236,"efault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-20",MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:393,Usability,undo,undocked,393,". TGDockableFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockableFrame. class TGDockableFrame: public TGCompositeFrame, public TGWidget. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); virtual~TGDockableFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* hints); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::C",MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:18055,Usability,undo,undocked,18055,,MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:18212,Usability,undo,undocked,18212,,MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:21286,Usability,undo,undocking,21286,"lectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id:",MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockableFrame.html:21426,Usability,undo,undock,21426,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-11-03 20:13; This page has been automati",MatchSource.WIKI,root/html532/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html
https://root.cern/root/html532/TGDockButton.html:4384,Availability,error,error,4384,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html532/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockButton.html
https://root.cern/root/html532/TGDockButton.html:4468,Availability,error,error,4468,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Optio",MatchSource.WIKI,root/html532/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockButton.html
https://root.cern/root/html532/TGDockButton.html:17312,Availability,mask,mask,17312,,MatchSource.WIKI,root/html532/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockButton.html
https://root.cern/root/html532/TGDockButton.html:18532,Availability,down,down,18532,HighColorhighlight color; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Bool_tfMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tfNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static con,MatchSource.WIKI,root/html532/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockButton.html
https://root.cern/root/html532/TGDockButton.html:19754,Deployability,release,released,19754, frame width; Bool_tfMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tfNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockButton.html
https://root.cern/root/html532/TGDockButton.html:359,Usability,undo,undocked,359,". TGDockButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockButton. class TGDockButton: public TGButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockButton(const TGCompositeFrame* p = 0, Int_t id = 1); virtual~TGDockButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal,",MatchSource.WIKI,root/html532/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockButton.html
https://root.cern/root/html532/TGDockHideButton.html:4387,Availability,error,error,4387,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html532/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockHideButton.html
https://root.cern/root/html532/TGDockHideButton.html:4471,Availability,error,error,4471,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Optio",MatchSource.WIKI,root/html532/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockHideButton.html
https://root.cern/root/html532/TGDockHideButton.html:17411,Availability,mask,mask,17411,,MatchSource.WIKI,root/html532/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockHideButton.html
https://root.cern/root/html532/TGDockHideButton.html:18673,Availability,down,down,18673,ndle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Bool_tTGDockButton::fMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tTGDockButton::fNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static con,MatchSource.WIKI,root/html532/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockHideButton.html
https://root.cern/root/html532/TGDockHideButton.html:19895,Deployability,release,released,19895,tton::fMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tTGDockButton::fNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockHideButton.html
https://root.cern/root/html532/TGDockHideButton.html:375,Usability,undo,undocked,375,". TGDockHideButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockHideButton. class TGDockHideButton: public TGDockButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockHideButton(const TGCompositeFrame* p = 0); ~TGDockHideButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* sign",MatchSource.WIKI,root/html532/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDockHideButton.html
https://root.cern/root/html532/TGDoubleHSlider.html:5340,Availability,error,error,5340,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html532/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleHSlider.html
https://root.cern/root/html532/TGDoubleHSlider.html:5424,Availability,error,error,5424,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html532/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleHSlider.html
https://root.cern/root/html532/TGDoubleHSlider.html:17542,Availability,mask,mask,17542,,MatchSource.WIKI,root/html532/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleHSlider.html
https://root.cern/root/html532/TGDoubleHSlider.html:18942,Availability,down,downright,18942,"t_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGDoubleSlider::fMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tTGDoubleSlider::fPoslogical position between fVmin and fVmax; Int_tTGDoubleSlider::fPressPointmouse position at button press event; Float_tTGDoubleSlider::fPressSmaxlogical max position at button press event; Float_tTGDoubleSlider::fPressSminlogical min position at button press event; Int_tTGDoubleSlider::fRelPosslider position in pixel coordinates; Bool_tTGDoubleSlider::fReversedScalereverse which end is min and max; Int_tTGDoubleSlider::fScaletick mark scale; Int_tTGDoubleSlider::fScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*TGDoubleSlider::fSliderPicpicture to draw slider ends; Float_tTGDoubleSlider::fSmaxlogical position of max value of Slider; Float_tTGDoubleSlider::fSminlogical position of min value of Slider; Float_tTGDoubleSlider::fVmaxlogical upper limit of slider; Float_tTGDoubleSlider::fVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tfXphorizontal slider x position in pixel coordinates; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTG",MatchSource.WIKI,root/html532/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleHSlider.html
https://root.cern/root/html532/TGDoubleSlider.html:1681,Availability,avail,available,1681,"nge the max value press the mouse near to the right / top; edge of the slider.; To change both values simultaneously press the mouse near to the; center of the slider. TGDoubleSlider is an abstract base class. Use the concrete; TGDoubleVSlider and TGDoubleHSlider. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POS, slider id, 0 (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Use the functions GetMinPosition(), GetMaxPosition() and; GetPosition() to retrieve the position of the slider. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGDoubleSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQ",MatchSource.WIKI,root/html532/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleSlider.html
https://root.cern/root/html532/TGDoubleSlider.html:5259,Availability,error,error,5259,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html532/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleSlider.html
https://root.cern/root/html532/TGDoubleSlider.html:5343,Availability,error,error,5343,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html532/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleSlider.html
https://root.cern/root/html532/TGDoubleSlider.html:17272,Availability,mask,mask,17272,,MatchSource.WIKI,root/html532/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleSlider.html
https://root.cern/root/html532/TGDoubleSlider.html:18512,Availability,down,downright,18512,"ls! list of signals from this object; Bool_tfMarkEndslines marking where stretch zones begin; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tfMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tfPoslogical position between fVmin and fVmax; Int_tfPressPointmouse position at button press event; Float_tfPressSmaxlogical max position at button press event; Float_tfPressSminlogical min position at button press event; Int_tfRelPosslider position in pixel coordinates; Bool_tfReversedScalereverse which end is min and max; Int_tfScaletick mark scale; Int_tfScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*fSliderPicpicture to draw slider ends; Float_tfSmaxlogical position of max value of Slider; Float_tfSminlogical position of min value of Slider; Float_tfVmaxlogical upper limit of slider; Float_tfVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFram",MatchSource.WIKI,root/html532/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleSlider.html
https://root.cern/root/html532/TGDoubleSlider.html:20154,Integrability,depend,depending,20154," for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FixBounds(Float_t& min, Float_t& max); Avoid boundaries to be equal. TString GetSString() const; Returns the slider type as a string - used in SavePrimitive(). void ChangeCursor(Event_t* event); Change the cursor shape depending on the slider area. TGDoubleSlider& operator=(const TGDoubleSlider& ). virtual ~TGDoubleSlider(); { }. Bool_t HandleButton(Event_t* event). Bool_t HandleMotion(Event_t* event). void SetScale(Int_t scale); { fScale = scale; }. void SetRange(Float_t min, Float_t max). void SetPosition(Float_t min, Float_t max). Float_t GetMinPosition() const. Float_t GetMaxPosition() const. void GetPosition(Float_t& min, Float_t& max) const. void GetPosition(Float_t* min, Float_t* max) const. void MapSubwindows(); { TGWindow::MapSubwindows(); }. void PositionChanged(); { Emit(""PositionChanged()""); }. void Pressed(); { Emit(""Pressed()""); }. void Released(); { Emit(""Released()""); }. » Author: Reiner Rohlfs 30/09/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDoubleSlider.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root/html532/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleSlider.html
https://root.cern/root/html532/TGDoubleVSlider.html:5338,Availability,error,error,5338,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html532/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleVSlider.html
https://root.cern/root/html532/TGDoubleVSlider.html:5422,Availability,error,error,5422,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html532/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleVSlider.html
https://root.cern/root/html532/TGDoubleVSlider.html:17540,Availability,mask,mask,17540,,MatchSource.WIKI,root/html532/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleVSlider.html
https://root.cern/root/html532/TGDoubleVSlider.html:18940,Availability,down,downright,18940,"t_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGDoubleSlider::fMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tTGDoubleSlider::fPoslogical position between fVmin and fVmax; Int_tTGDoubleSlider::fPressPointmouse position at button press event; Float_tTGDoubleSlider::fPressSmaxlogical max position at button press event; Float_tTGDoubleSlider::fPressSminlogical min position at button press event; Int_tTGDoubleSlider::fRelPosslider position in pixel coordinates; Bool_tTGDoubleSlider::fReversedScalereverse which end is min and max; Int_tTGDoubleSlider::fScaletick mark scale; Int_tTGDoubleSlider::fScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*TGDoubleSlider::fSliderPicpicture to draw slider ends; Float_tTGDoubleSlider::fSmaxlogical position of max value of Slider; Float_tTGDoubleSlider::fSminlogical position of min value of Slider; Float_tTGDoubleSlider::fVmaxlogical upper limit of slider; Float_tTGDoubleSlider::fVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Int_tfYpvertical slider y position in pixel coordinates; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFr",MatchSource.WIKI,root/html532/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDoubleVSlider.html
https://root.cern/root/html532/TGDragWindow.html:459,Availability,mask,mask,459," TGDragWindow(const TGWindow* p, Pixmap_t pic, Pixmap_t mask, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); virtual~TGDragWindow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual",MatchSource.WIKI,root/html532/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDragWindow.html
https://root.cern/root/html532/TGDragWindow.html:4018,Availability,error,error,4018,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html532/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDragWindow.html
https://root.cern/root/html532/TGDragWindow.html:4102,Availability,error,error,4102,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static Long_tTO",MatchSource.WIKI,root/html532/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDragWindow.html
https://root.cern/root/html532/TGDragWindow.html:15127,Availability,mask,mask,15127,,MatchSource.WIKI,root/html532/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDragWindow.html
https://root.cern/root/html532/TGDragWindow.html:17064,Availability,mask,mask,17064,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Cursor_tfgDefaultCursorDefault Cursor; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDragWindow(const TGWindow* p, Pixmap_t pic, Pixmap_t mask, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); TGDragWindow constructor. ~TGDragWindow(); TGDragWindow destructor. void MapWindow(); Map TGDragWindow. void UnmapWindow(); Unmap TGDragWindow. void RaiseWindow(); Raise TGDragWindow. void LowerWindow(); Lower TGDragWindow. void MapRaised(); Map and Raise TGDragWindow. void Layout(); Layout TGDragWindow. void DoRedraw(); Redraw TGDragWindow. TGDimension GetDefaultSize() const; { return TGDimension(fPw, fPh); }. Window_t GetInputId() const; { return fInput; }. Bool_t HasWindow(Window_t w) const; { return (w == fId || w == fInput); }. » Author: Bertrand Bellenot 19/04/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDNDManager.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGDragWindow.html
https://root.cern/root/html532/TGedEditor.html:6571,Availability,error,error,6571,"ram); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtu",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:6655,Availability,error,error,6655," char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefau",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:22864,Availability,mask,mask,22864,,MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:23006,Availability,avail,available,23006,,MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:1394,Integrability,interface,interface,1394,"ts editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UI",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:26753,Integrability,depend,dependent,26753,"(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static TStringTVirtualPadEditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* ",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:1551,Performance,load,loaded,1551,"he; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:1595,Performance,cache,cached,1595," follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const ",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:9589,Performance,load,load,9589,"Name() const; const char*TGMainFrame::GetIconPixmap() const; Handle_tTGObject::GetId() const; virtual TGLayoutManager*TGCompositeFrame::GetLayoutManager() const; virtual TList*TGCompositeFrame::GetList() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const TGWindow*TGWindow::GetMainFrame() const; UInt_tTGFrame::GetMaxHeight() const; UInt_tTGFrame::GetMaxWidth() const; UInt_tTGFrame::GetMinHeight() const; UInt_tTGFrame::GetMinWidth() const; virtual TObject*GetModel() const; voidTGMainFrame::GetMWMHints(UInt_t& value, UInt_t& funcs, UInt_t& input) const; virtual const char*TGWindow::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; virtual TVirtualPad*GetPad() const; static TVirtualPadEditor*TVirtualPadEditor::GetPadEditor(Bool_t load = kTRUE); const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; TGTab*GetTab() const; TGCanvas*GetTGCanvas() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual voidGlobalClosed(); virtual voidGlobalSetModel(TVirtualPad*, TObject*, Int_t); virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual Bool_tTGMainFrame::H",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:617,Usability,simpl,simple,617,". TGedEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedEditor. class TGedEditor: public TVirtualPadEditor, public TGMainFrame. TGedEditor. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Member",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:950,Usability,simpl,simple,950,". TGedEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedEditor. class TGedEditor: public TVirtualPadEditor, public TGMainFrame. TGedEditor. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Member",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedEditor.html:26792,Usability,simpl,simply,26792,"ditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* obj, Int_t event); Activate object editors according to the selected object. void ",MatchSource.WIKI,root/html532/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedEditor.html
https://root.cern/root/html532/TGedFrame.html:491,Availability,avail,available,491,". TGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedFrame. class TGedFrame: public TGCompositeFrame. TGedFrame. Base frame for implementing GUI - a service class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidAddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root/html532/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedFrame.html
https://root.cern/root/html532/TGedFrame.html:4415,Availability,error,error,4415,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedFrame.html
https://root.cern/root/html532/TGedFrame.html:4499,Availability,error,error,4499,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedFrame.html
https://root.cern/root/html532/TGedFrame.html:17110,Availability,mask,mask,17110,,MatchSource.WIKI,root/html532/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedFrame.html
https://root.cern/root/html532/TGedMarkerPopup.html:494,Availability,down,down,494,". TGedMarkerPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerPopup. class TGedMarkerPopup: public TGedPopup. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); virtual~TGedMarkerPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, v",MatchSource.WIKI,root/html532/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerPopup.html
https://root.cern/root/html532/TGedMarkerPopup.html:4548,Availability,error,error,4548,"it(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerPopup.html
https://root.cern/root/html532/TGedMarkerPopup.html:4632,Availability,error,error,4632,"t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerPopup.html
https://root.cern/root/html532/TGedMarkerPopup.html:17016,Availability,mask,mask,17016,,MatchSource.WIKI,root/html532/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerPopup.html
https://root.cern/root/html532/TGedMarkerPopup.html:19363,Integrability,message,messages,19363,":fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); Create marker popup window. ~TGedMarkerPopup(); Destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the marker popup window. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TGedMarkerSelect.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerPopup.html
https://root.cern/root/html532/TGedMarkerSelect.html:498,Availability,down,down,498,". TGedMarkerSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerSelect. class TGedMarkerSelect: public TGedSelect. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); virtual~TGedMarkerSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html532/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html
https://root.cern/root/html532/TGedMarkerSelect.html:4585,Availability,error,error,4585,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html532/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html
https://root.cern/root/html532/TGedMarkerSelect.html:4669,Availability,error,error,4669,"); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virt",MatchSource.WIKI,root/html532/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html
https://root.cern/root/html532/TGedMarkerSelect.html:19480,Availability,mask,mask,19480,,MatchSource.WIKI,root/html532/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html
https://root.cern/root/html532/TGedMarkerSelect.html:21380,Availability,down,down,21380,ame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; const TGPicture*fPictureimage used for popup window; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html532/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html
https://root.cern/root/html532/TGedMarkerSelect.html:22882,Deployability,release,released,22882,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html
https://root.cern/root/html532/TGedMarkerSelect.html:23315,Integrability,message,messages,23315,"ndow_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); Create and show marker popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages according to the user input. void DoRedraw(); Draw selected marker type as current one. void SetMarkerStyle(Style_t pattern); Set marker. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. virtual ~TGedMarkerSelect(); { if(fPicture) gClient->FreePicture(fPicture);}. Style_t GetMarkerStyle() const; { return fMarkerStyle; }. void MarkerSelected(Style_t marker = 0); { Emit(""MarkerSelected(Style_t)"", marker ? marker : GetMarkerStyle()); }. TGDimension GetDefaultSize() const; { return TGDimension(38, 21); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TGedMarkerSelect.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html
https://root.cern/root/html532/TGedNameFrame.html:4461,Availability,error,error,4461,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedNameFrame.html
https://root.cern/root/html532/TGedNameFrame.html:4545,Availability,error,error,4545,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedNameFrame.html
https://root.cern/root/html532/TGedNameFrame.html:17367,Availability,mask,mask,17367,,MatchSource.WIKI,root/html532/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedNameFrame.html
https://root.cern/root/html532/TGedPatternFrame.html:710,Availability,down,down,710,". TGedPatternFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternFrame. class TGedPatternFrame: public TGFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternFrame(const TGWindow* p, Style_t pattern, Int_t width = 40, Int_t height = 20); virtual~TGedPatternFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls);",MatchSource.WIKI,root/html532/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternFrame.html
https://root.cern/root/html532/TGedPatternFrame.html:4643,Availability,error,error,4643,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html532/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternFrame.html
https://root.cern/root/html532/TGedPatternFrame.html:4727,Availability,error,error,4727,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static",MatchSource.WIKI,root/html532/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternFrame.html
https://root.cern/root/html532/TGedPatternFrame.html:15867,Availability,mask,mask,15867,,MatchSource.WIKI,root/html532/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternFrame.html
https://root.cern/root/html532/TGedPatternPopup.html:712,Availability,down,down,712,". TGedPatternPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternPopup. class TGedPatternPopup: public TGedPopup. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); virtual~TGedPatternPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Clea",MatchSource.WIKI,root/html532/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternPopup.html
https://root.cern/root/html532/TGedPatternPopup.html:4858,Availability,error,error,4858,"it(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternPopup.html
https://root.cern/root/html532/TGedPatternPopup.html:4942,Availability,error,error,4942,"t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternPopup.html
https://root.cern/root/html532/TGedPatternPopup.html:17304,Availability,mask,mask,17304,,MatchSource.WIKI,root/html532/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternPopup.html
https://root.cern/root/html532/TGedPatternPopup.html:19672,Integrability,message,messages,19672,"p mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); Pattern popup constructor. ~TGedPatternPopup(); Destructor of pattern popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by pattern popup window. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternPopup.html
https://root.cern/root/html532/TGedPatternSelect.html:716,Availability,down,down,716,". TGedPatternSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelect. class TGedPatternSelect: public TGedSelect. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); virtual~TGedPatternSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* =",MatchSource.WIKI,root/html532/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html
https://root.cern/root/html532/TGedPatternSelect.html:4895,Availability,error,error,4895,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html532/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html
https://root.cern/root/html532/TGedPatternSelect.html:4979,Availability,error,error,4979,"); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virt",MatchSource.WIKI,root/html532/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html
https://root.cern/root/html532/TGedPatternSelect.html:19805,Availability,mask,mask,19805,,MatchSource.WIKI,root/html532/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html
https://root.cern/root/html532/TGedPatternSelect.html:21636,Availability,down,down,21636,Widthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Style_tfPattern; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html532/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html
https://root.cern/root/html532/TGedPatternSelect.html:23138,Deployability,release,released,23138,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html
https://root.cern/root/html532/TGedPatternSelect.html:23572,Integrability,message,message,23572," windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); Create and pop up pattern select window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message according to the user input. void DoRedraw(); Draw selected pattern as current one. void SetPattern(Style_t pattern, Bool_t emit = kTRUE); Set pattern. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. Style_t GetPattern() const; { return fPattern; }. virtual ~TGedPatternSelect(); {}. TGDimension GetDefaultSize() const; { return TGDimension(55, 21); }. void PatternSelected(Style_t pattern = 0); { Emit(""PatternSelected(Style_t)"", pattern ? pattern : GetPattern()); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html
https://root.cern/root/html532/TGedPatternSelector.html:728,Availability,down,down,728,". TGedPatternSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelector. class TGedPatternSelector: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelector(const TGWindow* p); virtual~TGedPatternSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual",MatchSource.WIKI,root/html532/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelector.html
https://root.cern/root/html532/TGedPatternSelector.html:4817,Availability,error,error,4817,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::",MatchSource.WIKI,root/html532/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelector.html
https://root.cern/root/html532/TGedPatternSelector.html:4901,Availability,error,error,4901,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_t",MatchSource.WIKI,root/html532/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelector.html
https://root.cern/root/html532/TGedPatternSelector.html:17267,Availability,mask,mask,17267,,MatchSource.WIKI,root/html532/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelector.html
https://root.cern/root/html532/TGedPatternSelector.html:19650,Integrability,message,message,19650,"ed in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelector(const TGWindow* p); Create pattern popup window. ~TGedPatternSelector(); Delete pattern popup window. void SetActive(Int_t newat); Set selected the current style. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message generated by pattern popup window. Int_t GetActive() const; { return fActive; }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPatternSelector.html
https://root.cern/root/html532/TGedPopup.html:698,Availability,down,down,698,". TGedPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPopup. class TGedPopup: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGedPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root/html532/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPopup.html
https://root.cern/root/html532/TGedPopup.html:4886,Availability,error,error,4886,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPopup.html
https://root.cern/root/html532/TGedPopup.html:4970,Availability,error,error,4970,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPopup.html
https://root.cern/root/html532/TGedPopup.html:17286,Availability,mask,mask,17286,,MatchSource.WIKI,root/html532/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPopup.html
https://root.cern/root/html532/TGedPopup.html:19875,Integrability,message,messages,19875,"Object::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a popup frame. void EndPopup(); Ungrab pointer and unmap popup window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Place popup window at the specified place. Bool_t HandleButton(Event_t* event); Handle mouse button event in popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by popup window. virtual ~TGedPopup(); { }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedPopup.html
https://root.cern/root/html532/TGedSelect.html:698,Availability,down,down,698,". TGedSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedSelect. class TGedSelect: public TGCheckButton. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedSelect(const TGWindow* p, Int_t id); virtual~TGedSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; vir",MatchSource.WIKI,root/html532/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedSelect.html
https://root.cern/root/html532/TGedSelect.html:4822,Availability,error,error,4822,"t::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html532/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedSelect.html
https://root.cern/root/html532/TGedSelect.html:4906,Availability,error,error,4906,"Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCheckButton::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidt",MatchSource.WIKI,root/html532/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedSelect.html
https://root.cern/root/html532/TGedSelect.html:19576,Availability,mask,mask,19576,,MatchSource.WIKI,root/html532/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedSelect.html
https://root.cern/root/html532/TGedSelect.html:21378,Availability,down,down,21378,e height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGedPopup*fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html532/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedSelect.html
https://root.cern/root/html532/TGedSelect.html:22880,Deployability,release,released,22880,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html532/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGedSelect.html
https://root.cern/root/html532/TGenCollectionProxy.html:4226,Energy Efficiency,allocate,allocate,4226,"ect, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies;",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:9084,Energy Efficiency,allocate,allocated,9084,"of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void *dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:9580,Energy Efficiency,allocate,allocated,9580,"CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void *dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); typedef void (*DeleteIterator_t)(void *iter);; typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses,; Otherwise",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:3857,Performance,cache,cache,3857,"elete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:6386,Safety,avoid,avoid,6386,"L_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). TGenCollectionProxy* Initialize(Bool_t silent) const; Late initialization of collection proxy. TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void CheckFunctions() const; Allow to check function pointers. TGenCollectionProxy(). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TGenCollectionProxy(const TGenCollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'point",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:489,Security,access,access,489,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncr",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:3877,Security,access,accessors,3877,"elete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:4007,Security,access,accessors,4007,"elete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:4283,Security,access,accessors,4283,"ta Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGen",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:4415,Security,access,accessors,4415,"ta Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGen",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:4481,Security,access,accessors,4481,"ta Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGen",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:4729,Security,access,accessors,4729,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). T",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:5327,Security,access,accessors,5327,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). T",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:5430,Security,access,accessors,5430,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). T",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:629,Usability,clear,clear,629,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncr",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:3888,Usability,clear,clear,3888,"elete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy.html:7582,Usability,simpl,simple,7582,"CollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. void SetValueClass(TClass* newcl); Set pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void operator()(TBuffer& refBuffer, void* pObject); TClassStreamer I/O overload. void ReadBuffer(TBuffer& b, void* obj); Routine to read the content of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_",MatchSource.WIKI,root/html532/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html
https://root.cern/root/html532/TGenCollectionProxy__Method.html:481,Security,access,access,481,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method&). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. void* invoke(void* obj) const; { return (*call)(obj); }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Method.html
https://root.cern/root/html532/TGenCollectionProxy__Method.html:621,Usability,clear,clear,621,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method&). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. void* invoke(void* obj) const; { return (*call)(obj); }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Method.html
https://root.cern/root/html532/TGenCollectionProxy__Value.html:1057,Performance,cache,cache,1057,"arch. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const TGenCollectionProxy::Value& inside); Copy constructor. Value(const string& info, Bool_t silent); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Value.html
https://root.cern/root/html532/TGenCollectionProxy__Value.html:1109,Performance,cache,cache,1109,"arch. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const TGenCollectionProxy::Value& inside); Copy constructor. Value(const string& info, Bool_t silent); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Value.html
https://root.cern/root/html532/TGenCollectionProxy__Value.html:1154,Performance,cache,cache,1154,"arch. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const TGenCollectionProxy::Value& inside); Copy constructor. Value(const string& info, Bool_t silent); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Value.html
https://root.cern/root/html532/TGenCollectionProxy__Value.html:478,Security,access,access,478,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const TGenCollectionProxy::Value& inside); Copy constructor. Value(const string& info, Bool_t silent); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root/html532/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Value.html
https://root.cern/root/html532/TGenCollectionProxy__Value.html:618,Usability,clear,clear,618,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const TGenCollectionProxy::Value& inside); Copy constructor. Value(const string& info, Bool_t silent); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root/html532/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Value.html
https://root.cern/root/html532/TGenerator.html:4642,Availability,error,error,4642,,MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:4726,Availability,error,error,4726,"""); virtual~TGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerateEvent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjArray*GetListOfParticles() const; virtual const char*TNamed::GetName() const; Int_tGetNumberOfParticles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetParameter(const char*) const; virtual TParticle*GetParticle(Int_t i) const; virtual TObjArray*GetPrimaries(Option_t* option = """"); Float_tGetPtCut() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqu",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:341,Integrability,interface,interface,341,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various 	; event generators. Every event generator should inherit from 	; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #	; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:1753,Integrability,interface,interfaces,1753,"articles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #	; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerat",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:10230,Integrability,rout,routine,10230,"ts { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TObjArray*fParticles->static container of the primary particles; Float_tfPtCut!Pt cut. Do not show primaries below; Bool_tfShowNeutrons!display neutrons if true; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenerator(const char* name, const char* title = ""Generator class""); Event generator default constructor. ~TGenerator(); Event generator default destructor. void GenerateEvent(); must be implemented in concrete class (see eg TPythia6). TObjArray* ImportParticles(Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The default action is to store only the stable particles (ISTHEP =; 1) This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles. The default; action is to store only the stable particles (ISTHEP = 1) This can; be demanded explicitly by setting the option = ""Final"" If the; option = ""All"", all the particles are stored. void Browse(TBrowser* b); browse generator. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*Compute distance from point px,py to objects in event; *-* =============",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:10693,Integrability,rout,routine,10693,"eobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenerator(const char* name, const char* title = ""Generator class""); Event generator default constructor. ~TGenerator(); Event generator default destructor. void GenerateEvent(); must be implemented in concrete class (see eg TPythia6). TObjArray* ImportParticles(Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The default action is to store only the stable particles (ISTHEP =; 1) This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles. The default; action is to store only the stable particles (ISTHEP = 1) This can; be demanded explicitly by setting the option = ""Final"" If the; option = ""All"", all the particles are stored. void Browse(TBrowser* b); browse generator. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*Compute distance from point px,py to objects in event; *-* =====================================================; -. void Draw(Option_t* option = """"). Insert one event in the pad list. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================. Int_t GetNumberOfParticles() const; Return the number of particles in the stack. TParticle * GetParticle(Int_t i) const; Returns pointer to primary number i;. void Paint(Option_t* option = """"). ",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:420,Modifiability,inherit,inherit,420,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various 	; event generators. Every event generator should inherit from 	; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #	; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:2639,Performance,load,loaded,2639,"meter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially useful for example with TVirtualMC or similar. Function Members (Methods); public:. T",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:2598,Safety,safe,safe,2598,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenerator.html:2557,Security,access,accessing,2557,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html532/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenerator.html
https://root.cern/root/html532/TGenericTable.html:4959,Availability,error,error,4959,"ed) const; Int_tTTable::CopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorend(); TGenericTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:5043,Availability,error,error,5043,"stRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorend(); TGenericTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:16763,Energy Efficiency,allocate,allocated,16763,"st char*TTable::fgTypeName[13]. protected:. TTableDescriptor*fColDescriptors; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; Long_tTTable::fMaxIndexThe used capacity of this array; Int_tTTable::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:16998,Energy Efficiency,allocate,allocated,16998,"::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTab",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:17220,Energy Efficiency,allocate,allocated,17220,"f (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. T",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:17433,Energy Efficiency,allocate,allocated,17433,"ricTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < G",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:17664,Energy Efficiency,allocate,allocated,17664," Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator b",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:2088,Modifiability,variab,variable,2088,"the generic table for 1000 rows (it may grow then); ! TGenericTable *allStaff = new TGenericTable(""staff_t"",""Staff-data"",1000);; !; ! // Fill the memory resident table; ! while (fgets(&line,80,fp)) {; ! sscanf(&line[0] ,""%d%d%d%d"", &staff.cat,&staff.division,&staff.flag,&staff.age);; ! sscanf(&line[13],""%d%d%d%d"", &staff.service,&staff.children,&staff.grade,&staff.step);; ! sscanf(&line[24],""%d%d%d"", &staff.nation,&staff.hrweek,&staff.cost);; ! allStaff->AddAt(&staff);; ! }; ! fclose(fp);; ! // Delete unused space;; ! allStaff->Purge();; !; ! allStaff->Print(0,10);; !; !// Create ROOT file; ! TFile *f = new TFile(""aptuple.root"",""RECREATE"");; ! allStaff->Write();; ! f->Write();; !; ! // We should close TFile otherwise all histograms we create below; ! // may be written to the file too occasionaly; ! f->Close();; !; !// Create ROOT Browser; ! new TBrowser(""staff"",allStaff);; !; !// Create couple of the histograms; ! TCanvas *canva = new TCanvas(""Staff"",""CERN Population"",600,600);; ! canva->Divide(1,2);; !; !; !// one can use 2 meta variable:; !// n$ - the total number of the rows in the table; !// i$ - stands for the current row index i = [0 -> (n$-1)]; !; ! gStyle->SetHistFillColor(10);; ! gStyle->SetHistFillStyle(3013);; ! canva->cd(1);; ! allStaff->Draw(""age"");; ! canva->Update();; ! canva->cd(2);; ! allStaff->Draw(""cost"");; ! canva->Update();; !}. Function Members (Methods); public:. TGenericTable(); TGenericTable(const TGenericTable&); TGenericTable(const char* structName, const char* name); TGenericTable(const char* structName, Int_t n); TGenericTable(const TTableDescriptor& dsc, const char* name); TGenericTable(const TTableDescriptor& dsc, Int_t n); TGenericTable(const char* structName, const char* name, Int_t n); TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n); virtual~TGenericTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tTTable::AddAt(const void* c); virtual void",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:18372,Testability,assert,assert,18372,"e table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*this, *GetTable(0)):end();}. iterator end(); { return ((const TGenericTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*this, *GetTable(i)):iterator(*this);}. » Last changed: root/table:$Id: TGenericTable.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenericTable.html:18470,Testability,assert,assert,18470,"e table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*this, *GetTable(0)):end();}. iterator end(); { return ((const TGenericTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*this, *GetTable(i)):iterator(*this);}. » Last changed: root/table:$Id: TGenericTable.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenericTable.html
https://root.cern/root/html532/TGenPhaseSpace.html:1873,Availability,error,error,1873,"enPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGenerate(); TLorentzVector*GetDecay(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWtMax() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html532/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenPhaseSpace.html
https://root.cern/root/html532/TGenPhaseSpace.html:1957,Availability,error,error,1957," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGenerate(); TLorentzVector*GetDecay(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWtMax() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char",MatchSource.WIKI,root/html532/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenPhaseSpace.html
https://root.cern/root/html532/TGenPhaseSpace.html:400,Energy Efficiency,energy,energy,400,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. TGenPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEven",MatchSource.WIKI,root/html532/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenPhaseSpace.html
https://root.cern/root/html532/TGenPhaseSpace.html:6086,Energy Efficiency,energy,energy,6086,"od, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross se",MatchSource.WIKI,root/html532/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenPhaseSpace.html
https://root.cern/root/html532/TGenPhaseSpace.html:7016,Energy Efficiency,energy,energy,7016,"le_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section; ""Fermi"" -> Fermi energy dependece; return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics. TGenPhaseSpace(); {}. virtual ~TGenPhaseSpace(); {}. Int_t GetNt() const; { return fNt;}. Double_t GetWtMax() const; { return fWtMax;}. » Last changed: root/physics:$Id: TGenPhaseSpace.h 38051 2011-02-11 14:30:29Z brun $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenPhaseSpace.html
https://root.cern/root/html532/TGenPhaseSpace.html:407,Integrability,depend,dependence,407,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. TGenPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEven",MatchSource.WIKI,root/html532/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenPhaseSpace.html
https://root.cern/root/html532/TGenPhaseSpace.html:7023,Integrability,depend,dependece,7023,"le_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section; ""Fermi"" -> Fermi energy dependece; return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics. TGenPhaseSpace(); {}. virtual ~TGenPhaseSpace(); {}. Int_t GetNt() const; { return fNt;}. Double_t GetWtMax() const; { return fWtMax;}. » Last changed: root/physics:$Id: TGenPhaseSpace.h 38051 2011-02-11 14:30:29Z brun $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGenPhaseSpace.html
https://root.cern/root/html532/TGeoArb8.html:3616,Availability,error,error,3616,"* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const;",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoArb8.html:3700,Availability,error,error,3700,"virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoArb8.html:2686,Safety,safe,safe,2686,"r* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoArb8.html:2827,Safety,safe,safe,2827,"s*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, c",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoArb8.html:14608,Safety,safe,safe,14608,"if the vertices are defined; clockwise or anti-clockwise. Double_t GetTwist(Int_t iseg) const; Get twist for segment I in range [0,3]. Double_t GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t*",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoArb8.html:14803,Safety,safe,safe,14803,"t_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of inde",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoArb8.html:16376,Safety,safe,safety,16376,"at, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t InsidePolygon(Double_t x, Double_t y, Double_t* pts); Finds if a point in XY plane is inside the polygon defines by PTS. void InspectShape() const; Prints shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. Double_t SafetyToFace(Double_t* point, Int_t iseg, Bool_t in) const; Estimate safety to lateral plane defined by segment iseg in range [0,3]; Might be negative: plane seen only from inside. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPlaneVertices(Double_t zpl, Double_t* vertices) const; Computes intersection points between plane at zpl and non-horizontal edges. void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = x0; param[2] = y0. void SetPoints(Double_t* points) const; Creates arb8 mesh points. void SetPoints(Float_t* points) const; Creates arb8 mesh points. void SetVertex(Int_t vnum, Double_t x, Double_t y); Set values for a given vertex. void Sizeof3D() const; Fill size of this 3-D object. void Streamer(TBuffer& b); Stream an object of class TGeoManager. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoArb8.html:1761,Testability,test,testNo,1761," TGeoArb8(); TGeoArb8(Double_t dz, Double_t* vertices = 0); TGeoArb8(const char* name, Double_t dz, Double_t* vertices = 0); virtual~TGeoArb8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*",MatchSource.WIKI,root/html532/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoArb8.html
https://root.cern/root/html532/TGeoAtt.html:3124,Performance,optimiz,optimization,3124,"{ kUseBoundingBox; kUseVoxels; kUseGsord; };; enum EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. UInt_tfGeoAttoption flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoAtt(); Default constructor. TGeoAtt(Option_t* vis_opt, Option_t* activity_opt = """", Option_t* optimization_opt = """"); Constructor. ~TGeoAtt(); Destructor. void SetVisBranch(); Set branch type visibility. void SetVisContainers(Bool_t flag = kTRUE); Set branch type visibility. void SetVisLeaves(Bool_t flag = kTRUE); Set branch type visibility. void SetVisOnly(Bool_t flag = kTRUE); Set branch type visibility. void SetVisibility(Bool_t vis = kTRUE); Set visibility for this object. void SetVisDaughters(Bool_t vis = kTRUE); Set visibility for the daughters. void SetVisStreamed(Bool_t vis = kTRUE); Mark attributes as ""streamed to file"". void SetVisTouched(Bool_t vis = kTRUE); Mark visualization attributes as ""modified"". void SetOptimization(Option_t* option); Set optimization flags. TGeoAtt(); constructors. void SetAttBit(UInt_t f); methods. {fGeoAtt |= f & kBitMask;}. void SetAttBit(UInt_t f, Bool_t set); {(set)?SetAttBit(f):ResetAttBit(f);}. void ResetAttBit(UInt_t f); {fGeoAtt &= ~(f & kBitMask);}. Bool_t TestAttBit(UInt_t f) const; {return (Bool_t)((fGeoAtt & f) != 0);}. void SetVisRaytrace(Bool_t flag = kTRUE); {SetAttBit(kVisRaytrace, flag);}. void SetActivity(Bool_t flag = kTRUE); {SetAttBit(kActThis, flag);}. void SetActiveDaughters(Bool_t flag = kTRUE); {SetAttBit(kActDaughters,flag);}. Bool_t IsActive() const; {return TestAttBit(kActThis);}. Bool_t IsActiveDaughters() const; {return TestAttBit(kActDaughters);}. Bool_t IsVisRaytrace() const; {return TestAttBit(kVisRaytrace);}. Bool_t IsVisible() const; {return TestAttBit(kVisThis);}. Bool_t IsVisDaughters() const; {return TestAttBit(kVisDaughters);}. Bool_t IsVisBranch() const; {return TestAttBit(kVisBranch);}. Bool_t IsVisContainers() const; {return TestAttBit(kVisContain",MatchSource.WIKI,root/html532/TGeoAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoAtt.html
https://root.cern/root/html532/TGeoBatemanSol.html:1849,Availability,error,error,1849,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tConcentration(Double_t time) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindSolution(const TObjArray* array); voidGetCoeff(Int_t i, Double_t& cn, Double_t& lambda) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElementRN*GetElement() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMark",MatchSource.WIKI,root/html532/TGeoBatemanSol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBatemanSol.html
https://root.cern/root/html532/TGeoBatemanSol.html:1933,Availability,error,error,1933,"owser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tConcentration(Double_t time) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindSolution(const TObjArray* array); voidGetCoeff(Int_t i, Double_t& cn, Double_t& lambda) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElementRN*GetElement() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; Int_tGetNcoeff() const",MatchSource.WIKI,root/html532/TGeoBatemanSol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBatemanSol.html
https://root.cern/root/html532/TGeoBBox.html:4841,Availability,error,error,4841,"ble_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoM",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:4925,Availability,error,error,4925," TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObj",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:330,Modifiability,inherit,inherit,330,". TGeoBBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoBBox. class TGeoBBox: public TGeoShape. TGeoBBox - box class. All shape primitives inherit from this, their; constructor filling automatically the parameters of the box that bounds; the given shape. Defined by 6 parameters :; fDX, fDY, fDZ - half lengths on X, Y and Z axis; fOrigin[3] - position of box origin. --- Building boxes. Normally a box has to be build only with 3 parameters : dx, dy, dz; representing the half lengths on X, Y and Z axis. In this case, the origin; of the box will match the one of its reference frame. The translation of the; origin is used only by the constructors of all other shapes in order to; define their own bounding boxes. Users should be aware that building a; translated box that will represent a physical shape by itself will affect any; further positioning of other shapes inside. Therefore in order to build a; positioned box one should follow the recipe described in class TGeoNode. Creation of boxes; 1. TGeoBBox *box = new TGeoBBox(""BOX"", 20, 30, 40);. /*. */. 2. A volume having a box shape can be built in one step:; TGeoVolume *vbox = gGeoManager->MakeBox(""vbox"", ptrMed, 20,30,40);. Divisions of boxes. Volumes having box shape can be divided with equal-length slices on; X, Y or Z axis. The following options are supported:; a) Dividing the full range of one axis in N slices; TGeoVolume *divx = vbox->Divide(""SLICEX"", 1, N);; - here 1 stands for the division axis (1-X, 2-Y, 3-Z). /*. */. b) Dividing in a limited range - general case.; TGeoVolume *divy = vbox->Divide(""SLICEY"",2,N,start,step);; - start = starting offset within (-fDY, fDY); - step = slicing step. /*. */. Both cases are supported by all shapes.; See also class TGeoShape for utility methods provided by any particular; shape. Function ",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:3641,Safety,safe,safe,3641,"t_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() c",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:3957,Safety,safe,safe,3957,"are(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:14874,Safety,safe,safe,14874," Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const; Decides fast if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get ra",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:14959,Safety,safe,safe,14959,"ed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with th",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:15212,Safety,safe,safe,15212,"s box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - f",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:15345,Safety,safe,safe,15345,"e given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; F",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:15431,Safety,safe,safe,15431,"turns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided w",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:15686,Safety,safe,safe,15686,"le_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n ran",MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBox.html:2647,Testability,test,testNo,2647,,MatchSource.WIKI,root/html532/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBox.html
https://root.cern/root/html532/TGeoBBoxEditor.html:4607,Availability,error,error,4607,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBoxEditor.html
https://root.cern/root/html532/TGeoBBoxEditor.html:4691,Availability,error,error,4691,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBoxEditor.html
https://root.cern/root/html532/TGeoBBoxEditor.html:18018,Availability,mask,mask,18018,,MatchSource.WIKI,root/html532/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBoxEditor.html
https://root.cern/root/html532/TGeoBBoxEditor.html:21426,Usability,undo,undoing,21426,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBBoxEditor.html
https://root.cern/root/html532/TGeoBoolNode.html:1341,Availability,avail,available,1341,"n operations between two shapes. A Boolean node describes a Boolean operation between 'left' and 'right'; shapes positioned with respect to an ARBITRARY reference frame. The boolean; node is referenced by a mother composite shape and its shape components may; be primitive but also composite shapes. The later situation leads to a binary; tree hierarchy. When the parent composite shape is used to create a volume,; the reference frame of the volume is chosen to match the frame in which; node shape components were defined. The positioned shape components may or may not be disjoint. The specific; implementations for Boolean nodes are:. TGeoUnion - representing the Boolean union of two positioned shapes. TGeoSubtraction - representing the Boolean subtraction of two positioned; shapes. TGeoIntersection - representing the Boolean intersection of two positioned; shapes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t ",MatchSource.WIKI,root/html532/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html
https://root.cern/root/html532/TGeoBoolNode.html:2852,Availability,error,error,2852,"uble_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*GetRightMatrix() const; TGeoShape*GetRightShape() const; TGeoBoolNode::ThreadData_t&GetThreadData() const; virtual const char*TObject::GetTitle() co",MatchSource.WIKI,root/html532/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html
https://root.cern/root/html532/TGeoBoolNode.html:2936,Availability,error,error,2936,"nt, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*GetRightMatrix() const; TGeoShape*GetRightShape() const; TGeoBoolNode::ThreadData_t&GetThreadData() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(",MatchSource.WIKI,root/html532/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html
https://root.cern/root/html532/TGeoBoolNode.html:2354,Safety,safe,safe,2354," virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Dou",MatchSource.WIKI,root/html532/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html
https://root.cern/root/html532/TGeoBoolNode.html:2480,Safety,safe,safe,2480,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtua",MatchSource.WIKI,root/html532/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html
https://root.cern/root/html532/TGeoBoolNode.html:9049,Safety,safe,safe,9049,"anager class. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. ThreadData_t& GetThreadData() const. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html
https://root.cern/root/html532/TGeoBoolNode.html:9506,Safety,safe,safe,9506,"anager class. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. ThreadData_t& GetThreadData() const. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBoolNode.h 41234 2011-10-06 15:48:52Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBoolNode.html
https://root.cern/root/html532/TGeoBranchArray.html:1890,Availability,error,error,1890,"t; voidAddLevel(UShort_t dindex); virtual voidTObject::AppendPad(Option_t* option = """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UShort_t*GetArray() const; TObject*GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; UShort_tGetLevel() const; TGeoHMatrix*GetMatrix() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(UShort_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTim",MatchSource.WIKI,root/html532/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBranchArray.html
https://root.cern/root/html532/TGeoBranchArray.html:1974,Availability,error,error,1974,"""""); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UShort_t*GetArray() const; TObject*GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; UShort_tGetLevel() const; TGeoHMatrix*GetMatrix() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(UShort_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const ch",MatchSource.WIKI,root/html532/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBranchArray.html
https://root.cern/root/html532/TGeoBranchArray.html:5336,Availability,down,down,5336,"tr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(const TGeoBranchArray& other) const; Bool_toperator<(const TGeoBranchArray& other) const; Bool_toperator<=(const TGeoBranchArray& other) const; TGeoBranchArray&operator=(const TGeoBranchArray&); Bool_toperator==(const TGeoBranchArray& other) const; Bool_toperator>(const TGeoBranchArray& other) const; Bool_toperator>=(const TGeoBranchArray& other) const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClient(TObject* client); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); static voidSort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateNavigator(TGeoNavigator* nav) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBranchArray.html
https://root.cern/root/html532/TGeoBranchArray.html:7794,Availability,down,down,7794,"evel. ~TGeoBranchArray(); Destructor. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. void AddLevel(UShort_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. TGeoNode * GetNode(UShort_t level) const. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of branch array pointers. void UpdateNavigator(TGeoNavigator* nav) const; Update the navigator to reflect the branch. TGeoBranchArray(); {}. UShort_t * GetArray() const; {return fArray;}. TObject * GetClient() const; {return fClient;}. UShort_t GetLevel() const; {return fLevel;}. TGeoHMatrix * GetMatrix() const; {return fMatrix;}. Bool_t IsSortable() const; {return kTRUE;}. Bool_t Notify(); {return (fClient)?fClient->Notify():kFALSE;}. void SetClient(TObject* client); {fClient = client;}. » Author: Andrei Gheata 01/03/11 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoBranchArray.h 38636 2011-03-26 07:14:47Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBranchArray.html
https://root.cern/root/html532/TGeoBranchArray.html:620,Deployability,update,updated,620,". TGeoBranchArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoBranchArray. class TGeoBranchArray: public TObject. TGeoBranchArray - An array of daughter indices making a geometry path.; Can be used to backup/restore a state. To setup an object of this type,; one should use:; TGeoBranchArray *array = new TGeoBranchArray(level);; array->InitFromNavigator(nav); (To initialize from current navigator state); The navigator can be updated to reflect this path array:; array->UpdateNavigator();. Function Members (Methods); public:. TGeoBranchArray(); TGeoBranchArray(UShort_t level); TGeoBranchArray(const TGeoBranchArray&); virtual~TGeoBranchArray(); voidTObject::AbstractMethod(const char* method) const; voidAddLevel(UShort_t dindex); virtual voidTObject::AppendPad(Option_t* option = """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html532/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBranchArray.html
https://root.cern/root/html532/TGeoBranchArray.html:6948,Performance,perform,performed,6948,"dTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UShort_t*fArray[fLevel] Array of daughter indices; TObject*fClientClient object to notify; UShort_tfLevelBranch depth; TGeoHMatrix*fMatrixGlobal matrix (owned). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(UShort_t level); Constructor. Alocates the array with a size given by level. ~TGeoBranchArray(); Destructor. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. void AddLevel(UShort_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. TGeoNode * GetNode(UShort_t level) const. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of branch array pointers. void UpdateNavigator(TGeoNavigator* nav) const; Update the navigator to reflect the branch",MatchSource.WIKI,root/html532/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBranchArray.html
https://root.cern/root/html532/TGeoBuilder.html:1814,Availability,error,error,1814,"ject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:1898,Availability,error,error,1898,"atic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:17584,Deployability,continuous,continuous,17584,"Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY fl",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:17507,Energy Efficiency,energy,energy,17507,"erial * Mixture(const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation ",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:4428,Integrability,rout,rout,4428,"TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz); TGeoVolume*MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoVolume*MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoVolume*MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoVolume*MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); TGeoVolume*MakeGtra(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolume*MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoVolume*MakePara(const char* name, TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoVolume*MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); TGeoVolume*MakePcon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nz); TGeoVolume*MakePgon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoVolume*MakeSphere(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t themin = 0, Double_t themax = 180, Double_t phimin = 0, Double_t phimax = 360); TGeoVolume*MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoVolume*MakeTrap(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, ",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:12316,Integrability,rout,rout,12316,"hemax = 180, Double_t phimin = 0, Double_t phimax = 360); Make in one step a volume pointing to a sphere shape with given medium. TGeoVolume * MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); Make in one step a volume pointing to a torus shape with given medium. TGeoVolume * MakeTube(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeTubs(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Make in one step a volume pointing to a cone shape with given medium. TGeoVolume * MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a cone segment ",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:17708,Performance,perform,performed,17708," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:17756,Performance,perform,performed,17756," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoBuilder.html:17803,Performance,perform,performed,17803," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html532/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoBuilder.html
https://root.cern/root/html532/TGeoCacheState.html:1363,Availability,error,error,1363," TGeoCacheState(); TGeoCacheState(Int_t capacity); virtual~TGeoCacheState(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root/html532/TGeoCacheState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCacheState.html
https://root.cern/root/html532/TGeoCacheState.html:1447,Availability,error,error,1447," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetState(Int_t& level, Int_t& nmany, Double_t* point) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_",MatchSource.WIKI,root/html532/TGeoCacheState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCacheState.html
https://root.cern/root/html532/TGeoChecker.html:4304,Availability,error,error,4304," = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Double_tCheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:4388,Availability,error,error,4388,"pe* shape, Int_t testNo, Int_t nsamples, Option_t* option); Double_tCheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:11056,Availability,error,errors,11056,"of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking. Opional overlap checkings (by sampling and by mesh). Optional; boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mi",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:17111,Deployability,update,updated,17111,". Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double_t dirz, Double_t* array, Int_t& nelem, Int_t& dim, Double_t* enpoint = 0) const; Shoot one ray from start point with direction (dirx,diry,dirz). Fills input array; with points just after boundary crossings.; Int_t array_dimension = 3*dim;. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""v""); Estimate weight of top level volume with a precision SIGMA(W)/W; better than PRECISION. Option can be ""v"" - verbose (default). Double_t CheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); count voxel timing. Bool_t TestVoxels(TGeoVolume* vol, Int_t npoints = 1000000); Returns optimal voxelization type for volume vol.; kFALSE - cartesian; kTRUE -",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:446,Performance,perform,performed,446,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:1147,Safety,safe,safety,1147," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. T",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:10309,Safety,safe,safety,10309,"opagateInGeom(Double_t*, Double_t*); voidScore(TGeoVolume*, Int_t, Double_t); Double_tTimingPerVolume(TGeoVolume*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TBuffer3D*fBuff1Buffer containing mesh vertices for first volume; TBuffer3D*fBuff2Buffer containing mesh vertices for second volume; Bool_t*fFlags! Array of flags per volume.; Bool_tfFullCheckFull overlap checking; TGeoManager*fGeoManagerpointer to geometry manager; Int_tfNchecks! Number of checks for current volume; Int_tfNmeshPoints! Number of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t ch",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:14918,Safety,safe,safety,14918,"er of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:15050,Safety,safe,safety,15050,"""); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the n",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:15707,Safety,safe,safe,15707,"shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. ",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:15794,Safety,safe,safety,15794,"t with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly sho",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:15926,Safety,safe,safety,15926,"and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npo",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:16178,Safety,safe,safety,16178,"ions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:428,Testability,test,tests,428,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:3408,Testability,test,testNo,3408,,MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:14520,Testability,test,testNo,14520," Double_t ovlp); Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:14610,Testability,test,test,14610,"s overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void Sha",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoChecker.html:14866,Testability,test,test,14866,"ecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compu",MatchSource.WIKI,root/html532/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoChecker.html
https://root.cern/root/html532/TGeoCombiTrans.html:6234,Availability,error,error,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:8349,Availability,error,error,8349,"name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*GetRotation() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() con",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:8433,Availability,error,error,8433,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*GetRotation() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslati",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:3106,Integrability,interface,interface,3106," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:6240,Integrability,message,message,6240,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:6985,Modifiability,variab,variable,6985,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRotation& rot); TGeoCombiTrans(Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); TGeoCombiTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual ",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:490,Performance,optimiz,optimize,490,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:499,Performance,perform,performance,499,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:984,Performance,perform,performed,984,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:1710,Performance,perform,performed,1710,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:6217,Performance,perform,performed,6217,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTrans.html:1723,Usability,simpl,simple,1723,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html532/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTrans.html
https://root.cern/root/html532/TGeoCombiTransEditor.html:4726,Availability,error,error,4726,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTransEditor.html
https://root.cern/root/html532/TGeoCombiTransEditor.html:4810,Availability,error,error,4810,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTransEditor.html
https://root.cern/root/html532/TGeoCombiTransEditor.html:17976,Availability,mask,mask,17976,,MatchSource.WIKI,root/html532/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTransEditor.html
https://root.cern/root/html532/TGeoCombiTransEditor.html:22279,Usability,undo,undoing,22279,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCombiTransEditor.html
https://root.cern/root/html532/TGeoCompositeShape.html:1115,Availability,down,down,1115,"eader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent bas",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:6079,Availability,error,error,6079,"GeoTranslation *t2 = new TGeoTranslation(""T2"",0,0, 20);; TGeoRotation *r1 = new TGeoRotation(""R1""); // transformations need names; r1->SetAngles(90,30,90,120,0,0); // rotation with 30 degrees about Z; TGeoTube *a = new TGeoTube(0, 10,20);; a->SetName(""A""); // shapes need names too; TGeoTube *b = new TGeoTube(0, 20,20);; b->SetName(""B"");; TGeoBBox *c = new TGeoBBox(10,10,50);; c->SetName(""C"");; TGeoBBox *d = new TGeoBBox(50,10,10);; d->SetName(""D"");. TGeoCompositeShape *cs;; cs = new TGeoCompositeShape(""CS"", ""(A:t1+B:t2)\(C+D:r1)"");. The newly created composite looks like 2 cylinders of different radii sitting; one on top of the other and having 2 rectangular holes : a longitudinal one; along Z axis corresponding to C and an other one in the XY plane due to D.; One should have in mind that the same shape or matrix identifier can be; used many times in the same expression. For instance:. (A:t1-A:t2)*B:t1. is a valid expression. Expressions that cannot be parsed or identifiers that; cannot be substituted by existing objects generate error messages.; Composite shapes can be subsequently used for defining volumes. Moreover,; these volumes may have daughters but these have to obbey overlapping/extruding; rules (see TGeoVolume). Volumes created based on composite shapes cannot be; divided. Visualization of such volumes is currently not implemented. Function Members (Methods); public:. TGeoCompositeShape(); TGeoCompositeShape(const char* expression); TGeoCompositeShape(const char* name, const char* expression); TGeoCompositeShape(const char* name, TGeoBoolNode* node); virtual~TGeoCompositeShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t t",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:8765,Availability,error,error,8765,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; TGeoBoolNode*GetBoolNode() const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Doubl",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:8849,Availability,error,error,8849,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; TGeoBoolNode*GetBoolNode() const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingB",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:17895,Availability,error,error,17895,"Menu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. TGeoBoolNode*fNodetop boolean node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const; Needed just for cleanup. TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divi",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:2292,Integrability,interface,interface,2292,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression splitted:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:6085,Integrability,message,messages,6085,"GeoTranslation *t2 = new TGeoTranslation(""T2"",0,0, 20);; TGeoRotation *r1 = new TGeoRotation(""R1""); // transformations need names; r1->SetAngles(90,30,90,120,0,0); // rotation with 30 degrees about Z; TGeoTube *a = new TGeoTube(0, 10,20);; a->SetName(""A""); // shapes need names too; TGeoTube *b = new TGeoTube(0, 20,20);; b->SetName(""B"");; TGeoBBox *c = new TGeoBBox(10,10,50);; c->SetName(""C"");; TGeoBBox *d = new TGeoBBox(50,10,10);; d->SetName(""D"");. TGeoCompositeShape *cs;; cs = new TGeoCompositeShape(""CS"", ""(A:t1+B:t2)\(C+D:r1)"");. The newly created composite looks like 2 cylinders of different radii sitting; one on top of the other and having 2 rectangular holes : a longitudinal one; along Z axis corresponding to C and an other one in the XY plane due to D.; One should have in mind that the same shape or matrix identifier can be; used many times in the same expression. For instance:. (A:t1-A:t2)*B:t1. is a valid expression. Expressions that cannot be parsed or identifiers that; cannot be substituted by existing objects generate error messages.; Composite shapes can be subsequently used for defining volumes. Moreover,; these volumes may have daughters but these have to obbey overlapping/extruding; rules (see TGeoVolume). Volumes created based on composite shapes cannot be; divided. Visualization of such volumes is currently not implemented. Function Members (Methods); public:. TGeoCompositeShape(); TGeoCompositeShape(const char* expression); TGeoCompositeShape(const char* name, const char* expression); TGeoCompositeShape(const char* name, TGeoBoolNode* node); virtual~TGeoCompositeShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t t",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:944,Modifiability,extend,extend,944,". TGeoCompositeShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are n",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:1284,Performance,perform,performance,1284,"lass TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:7916,Safety,safe,safe,7916,"ig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:8057,Safety,safe,safe,8057,"000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:18380,Safety,safe,safe,18380,"eritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const; Needed just for cleanup. TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:18643,Safety,safe,safe,18643,"hape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t* option = """") const; Paint this composite shape into the current 3D viewer; Returns bool flag indicating if the caller should continue to; paint child objects. void RegisterYourself(); Register the shape and all components to TGeoManager class. Double_t Safety(Double",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:7032,Testability,test,testNo,7032,,MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCompositeShape.html:2335,Usability,simpl,simple,2335,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression splitted:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right",MatchSource.WIKI,root/html532/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCompositeShape.html
https://root.cern/root/html532/TGeoCone.html:3594,Availability,error,error,3594,"hape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:3678,Availability,error,error,3678,"int, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatr",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:2338,Safety,safe,safe,2338,"= """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:2620,Safety,safe,safe,2620,"obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObje",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:13957,Safety,safe,safe,13957,"cifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius an",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:14089,Safety,safe,safe,14089,"acity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, co",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:14174,Safety,safe,safe,14174,"acity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, co",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:14395,Safety,safe,safe,14395,"tructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns poi",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:14559,Safety,safe,safe,14559,"uble_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was d",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:14644,Safety,safe,safe,14644,"uble_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was d",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:1291,Testability,test,testNo,1291," TGeoCone(); TGeoCone(Double_t* params); TGeoCone(const TGeoCone&); TGeoCone(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Cop",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoCone.html:13710,Testability,test,test,13710,"mum and maximum radius. TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Default constructor specifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Do",MatchSource.WIKI,root/html532/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCone.html
https://root.cern/root/html532/TGeoConeEditor.html:4623,Availability,error,error,4623,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeEditor.html
https://root.cern/root/html532/TGeoConeEditor.html:4707,Availability,error,error,4707,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeEditor.html
https://root.cern/root/html532/TGeoConeEditor.html:18035,Availability,mask,mask,18035,,MatchSource.WIKI,root/html532/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeEditor.html
https://root.cern/root/html532/TGeoConeEditor.html:21579,Usability,undo,undoing,21579,"ol_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoConeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeEditor.html
https://root.cern/root/html532/TGeoConeSeg.html:4103,Availability,error,error,4103,", Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoCone::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoCone::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:4187,Availability,error,error,4187,"le_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoCone::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoCone::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:2510,Safety,safe,safe,2510,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Doub",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:2885,Safety,safe,safe,2885,"e_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:15594,Safety,safe,safe,15594," Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to create",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:16090,Safety,safe,safe,16090,"nd Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rma",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:16175,Safety,safe,safe,16175,"nd Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rma",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:1411,Testability,test,testNo,1411," TGeoConeSeg(); TGeoConeSeg(Double_t* params); TGeoConeSeg(const TGeoConeSeg&); TGeoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1,",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSeg.html:14825,Testability,test,test,14825,"Default constructor specifying minimum and maximum radius. TGeoConeSeg(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2; param[5] = phi1; param[6] = phi2. ~TGeoConeSeg(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c",MatchSource.WIKI,root/html532/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html
https://root.cern/root/html532/TGeoConeSegEditor.html:4796,Availability,error,error,4796,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSegEditor.html
https://root.cern/root/html532/TGeoConeSegEditor.html:4880,Availability,error,error,4880,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSegEditor.html
https://root.cern/root/html532/TGeoConeSegEditor.html:18471,Availability,mask,mask,18471,"t changes; Bool_tTGedFrame::fAvoidSignalflag for executing slots; TGCompositeFrame*TGeoConeEditor::fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoConeEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoConeEditor::fDelayedCheck button for delayed draw; Double_tTGeoConeEditor::fDziInitial box dz; TGNumberEntry*TGeoConeEditor::fEDzNumber entry for DZ; TGNumberEntry*fEPhi1Number entry for phi1; TGNumberEntry*fEPhi2Number entry for phi2 ; TGNumberEntry*TGeoConeEditor::fERmax1Number entry for rmax1; TGNumberEntry*TGeoConeEditor::fERmax2Number entry for rmax2; TGNumberEntry*TGeoConeEditor::fERmin1Number entry for rmin1; TGNumberEntry*TGeoConeEditor::fERmin2Number entry for rmin2; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoConeEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoConeEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfLockPhi lock; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UIn",MatchSource.WIKI,root/html532/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSegEditor.html
https://root.cern/root/html532/TGeoConeSegEditor.html:22243,Usability,undo,undoing,22243,"TabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoConeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cone segment editor. ~TGeoConeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for Phi1. void DoPhi2(); Slot for Phi2. void DoPhi(); Slot for Phi. void DoApply(); Slot for applying current parameters. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoConeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoConeSegEditor.html
https://root.cern/root/html532/TGeoCtub.html:4223,Availability,error,error,4223,"FromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tT",MatchSource.WIKI,root/html532/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtub.html
https://root.cern/root/html532/TGeoCtub.html:4307,Availability,error,error,4307,"dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(c",MatchSource.WIKI,root/html532/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtub.html
https://root.cern/root/html532/TGeoCtub.html:2823,Safety,safe,safe,2823,"char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); v",MatchSource.WIKI,root/html532/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtub.html
https://root.cern/root/html532/TGeoCtub.html:3177,Safety,safe,safe,3177,"* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(cons",MatchSource.WIKI,root/html532/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtub.html
https://root.cern/root/html532/TGeoCtub.html:15072,Safety,safe,safe,15072," char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); constructor. TGeoCtub(Double_t* params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz,",MatchSource.WIKI,root/html532/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtub.html
https://root.cern/root/html532/TGeoCtub.html:15269,Safety,safe,safe,15269,"params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); set dimensions of a cut tube. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void S",MatchSource.WIKI,root/html532/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtub.html
https://root.cern/root/html532/TGeoCtub.html:1732,Testability,test,testNo,1732," TGeoCtub(); TGeoCtub(Double_t* params); TGeoCtub(const TGeoCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* new",MatchSource.WIKI,root/html532/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtub.html
https://root.cern/root/html532/TGeoCtubEditor.html:4830,Availability,error,error,4830,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtubEditor.html
https://root.cern/root/html532/TGeoCtubEditor.html:4914,Availability,error,error,4914,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtubEditor.html
https://root.cern/root/html532/TGeoCtubEditor.html:18608,Availability,mask,mask,18608,"GeoTubeEditor::fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoTubeEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoTubeEditor::fDelayedCheck button for delayed draw; Double_tTGeoTubeEditor::fDziInitial box dz; TGNumberEntry*TGeoTubeEditor::fEDzNumber entry for DZ; TGNumberEntry*fEPhhiNumber entry for phhi; TGNumberEntry*TGeoTubeSegEditor::fEPhi1Number entry for phi1; TGNumberEntry*TGeoTubeSegEditor::fEPhi2Number entry for phi2 ; TGNumberEntry*fEPhloNumber entry for phlo; TGNumberEntry*TGeoTubeEditor::fERmaxNumber entry for rmax; TGNumberEntry*TGeoTubeEditor::fERminNumber entry for rmin; TGNumberEntry*fEThhiNumber entry for thhi; TGNumberEntry*fEThloNumber entry for thlo; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoTubeEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoTubeEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGeoTubeSegEditor::fLockPhi lock; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminima",MatchSource.WIKI,root/html532/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtubEditor.html
https://root.cern/root/html532/TGeoCtubEditor.html:22528,Usability,undo,undoing,22528," plane (0, 90); Double_tfThloTheta angle of the normal to the lower plane (90, 180); TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCtubEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cut tube editor. ~TGeoCtubEditor(); Destructor. void SetModel(TObject* obj); Connect to the selected object. void DoThlo(); Slot for phi1. void DoPhlo(); Slot for phi1. void DoThhi(); Slot for phi1. void DoPhhi(); Slot for phi1. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoCtubEditor.html
https://root.cern/root/html532/TGeoDecayChannel.html:1895,Availability,error,error,1895,"nst; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoElementRN*Daughter() const; UInt_tDecay() const; static voidDecayName(UInt_t decay, TString& name); virtual voidDecayShift(Int_t& dA, Int_t& dZ, Int_t& dI) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeltaIso() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* ",MatchSource.WIKI,root/html532/TGeoDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoDecayChannel.html
https://root.cern/root/html532/TGeoDecayChannel.html:1979,Availability,error,error,1979,"char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoElementRN*Daughter() const; UInt_tDecay() const; static voidDecayName(UInt_t decay, TString& name); virtual voidDecayShift(Int_t& dA, Int_t& dZ, Int_t& dI) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeltaIso() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtu",MatchSource.WIKI,root/html532/TGeoDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoDecayChannel.html
https://root.cern/root/html532/TGeoElement.html:1852,Availability,error,error,1852,"bstractMethod(const char* method) const; voidAddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Ha",MatchSource.WIKI,root/html532/TGeoElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElement.html
https://root.cern/root/html532/TGeoElement.html:1936,Availability,error,error,1936,"_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Bool_tHasIsotopes() c",MatchSource.WIKI,root/html532/TGeoElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElement.html
https://root.cern/root/html532/TGeoElementRN.html:2202,Availability,error,error,2202,"s); public:. TGeoElementRN(); TGeoElementRN(Int_t A, Int_t Z, Int_t iso, Double_t level, Double_t deltaM, Double_t halfLife, const char* JP, Double_t natAbun, Double_t th_f, Double_t tg_f, Double_t th_s, Double_t tg_s, Int_t status); virtual~TGeoElementRN(); Double_tTGeoElement::A() const; voidTObject::AbstractMethod(const char* method) const; voidAddDecay(TGeoDecayChannel* dc); voidAddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue); voidTGeoElement::AddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); voidAddRatio(TGeoBatemanSol& ratio); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAtomicNo() const; virtual voidTObject::Browse(TBrowser* b); Bool_tCheckDecays() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecayResult(TGeoDecayChannel* dc) const; TObjArray*Decays() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Int_tENDF(Int_t a, Int_t z, Int_t iso); virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillPopulation(TObjArray* population, Double_t precision = 0.001, Double_",MatchSource.WIKI,root/html532/TGeoElementRN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElementRN.html
https://root.cern/root/html532/TGeoElementRN.html:2286,Availability,error,error,2286,"s); public:. TGeoElementRN(); TGeoElementRN(Int_t A, Int_t Z, Int_t iso, Double_t level, Double_t deltaM, Double_t halfLife, const char* JP, Double_t natAbun, Double_t th_f, Double_t tg_f, Double_t th_s, Double_t tg_s, Int_t status); virtual~TGeoElementRN(); Double_tTGeoElement::A() const; voidTObject::AbstractMethod(const char* method) const; voidAddDecay(TGeoDecayChannel* dc); voidAddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue); voidTGeoElement::AddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); voidAddRatio(TGeoBatemanSol& ratio); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAtomicNo() const; virtual voidTObject::Browse(TBrowser* b); Bool_tCheckDecays() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecayResult(TGeoDecayChannel* dc) const; TObjArray*Decays() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Int_tENDF(Int_t a, Int_t z, Int_t iso); virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillPopulation(TObjArray* population, Double_t precision = 0.001, Double_",MatchSource.WIKI,root/html532/TGeoElementRN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElementRN.html
https://root.cern/root/html532/TGeoElementTable.html:1865,Availability,error,error,1865,"le_t a); voidAddElementRN(TGeoElementRN* elem); voidAddIsotope(TGeoIsotope* isotope); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildDefaultElements(); Bool_tCheckTable() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExportElementsRN(const char* filename = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoElement*FindElement(const char* name) const; TGeoIsotope*FindIsotope(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElement*GetElement(Int_t z); TGeoElementRN*GetElementRN(Int_t ENDFcode) const; TGeoElementRN*GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; TObjArray*GetElementsRN() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNelements() const; Int_tGetNelementsRN() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_",MatchSource.WIKI,root/html532/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElementTable.html
https://root.cern/root/html532/TGeoElementTable.html:1949,Availability,error,error,1949,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildDefaultElements(); Bool_tCheckTable() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExportElementsRN(const char* filename = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoElement*FindElement(const char* name) const; TGeoIsotope*FindIsotope(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElement*GetElement(Int_t z); TGeoElementRN*GetElementRN(Int_t ENDFcode) const; TGeoElementRN*GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; TObjArray*GetElementsRN() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNelements() const; Int_tGetNelementsRN() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual cons",MatchSource.WIKI,root/html532/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElementTable.html
https://root.cern/root/html532/TGeoElementTable.html:7680,Performance,optimiz,optimized,7680,"t_t nelements); constructor. TGeoElementTable(const TGeoElementTable& ); copy constructor. TGeoElementTable& operator=(const TGeoElementTable& ); assignment operator. ~TGeoElementTable(); destructor. void AddElement(const char* name, const char* title, Int_t z, Double_t a); Add an element to the table. Obsolete. void AddElement(const char* name, const char* title, Int_t z, Int_t n, Double_t a); Add an element to the table. void AddElementRN(TGeoElementRN* elem); Add a radionuclide to the table and map it. void AddIsotope(TGeoIsotope* isotope); Add isotope to the table. void BuildDefaultElements(); Creates the default element table. void ImportElementsRN(); Creates the list of radionuclides. Bool_t CheckTable() const; Checks status of element table. void ExportElementsRN(const char* filename = """"); Export radionuclides in a file. TGeoElement * FindElement(const char* name) const; Search an element by symbol or full name. TGeoIsotope * FindIsotope(const char* name) const; Find existing isotope by name. Not optimized for a big number of isotopes. TGeoElementRN * GetElementRN(Int_t ENDFcode) const; Retreive a radionuclide by ENDF code. TGeoElementRN * GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; Retreive a radionuclide by a, z, and isomeric state. TGeoElementRN * GetElement(); {return fElem;}. TObjArray * GetElementsRN() const; {return fListRN;}. Bool_t HasDefaultElements() const; {return TObject::TestBit(kETDefaultElements);}. Bool_t HasRNElements() const; {return TObject::TestBit(kETRNElements);}. Int_t GetNelements() const; {return fNelements;}. Int_t GetNelementsRN() const; {return fNelementsRN;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElementTable.html
https://root.cern/root/html532/TGeoElemIter.html:1974,Availability,down,down,1974,"TGeoElemIter&operator=(const TGeoElemIter& iter); virtual voidPrint(Option_t* option = """") const; voidSetLimitRatio(Double_t limit); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoElemIter(); TGeoElementRN*Down(Int_t ibranch); TGeoElementRN*Up(). Data Members; private:. TObjArray*fBranchCurrent branch; const TGeoElementRN*fElemCurrent element; Int_tfLevelCurrent level; Double_tfLimitRatioMinimum cumulative branching ratio; Double_tfRatioCurrent ratio; const TGeoElementRN*fTopTop element of the iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.e-4); Default constructor. TGeoElemIter(const TGeoElemIter& iter); Copy ctor. ~TGeoElemIter(); Destructor. TGeoElemIter & operator=(const TGeoElemIter& iter); Assignment. TGeoElementRN * operator()(); () operator. TGeoElementRN * Up(); Go upwards from the current location until the next branching, then down. TGeoElementRN * Down(Int_t ibranch); Go downwards from current level via ibranch as low in the tree as possible.; Return value flags if the operation was successful. TGeoElementRN * Next(); Return next element. void Print(Option_t* option = """") const; Print info about the current decay branch. TGeoElementRN * GetElement() const; {return fElem;}. TGeoElemIter(); {}. TObjArray * GetBranch() const; {return fBranch;}. const TGeoElementRN * GetTop() const; {return fTop;}. Int_t GetLevel() const; {return fLevel;}. Double_t GetRatio() const; {return fRatio;}. void SetLimitRatio(Double_t limit); {fLimitRatio = limit;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root/html532/TGeoElemIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElemIter.html
https://root.cern/root/html532/TGeoElemIter.html:2020,Availability,down,downwards,2020,"emIter& iter); virtual voidPrint(Option_t* option = """") const; voidSetLimitRatio(Double_t limit); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoElemIter(); TGeoElementRN*Down(Int_t ibranch); TGeoElementRN*Up(). Data Members; private:. TObjArray*fBranchCurrent branch; const TGeoElementRN*fElemCurrent element; Int_tfLevelCurrent level; Double_tfLimitRatioMinimum cumulative branching ratio; Double_tfRatioCurrent ratio; const TGeoElementRN*fTopTop element of the iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.e-4); Default constructor. TGeoElemIter(const TGeoElemIter& iter); Copy ctor. ~TGeoElemIter(); Destructor. TGeoElemIter & operator=(const TGeoElemIter& iter); Assignment. TGeoElementRN * operator()(); () operator. TGeoElementRN * Up(); Go upwards from the current location until the next branching, then down. TGeoElementRN * Down(Int_t ibranch); Go downwards from current level via ibranch as low in the tree as possible.; Return value flags if the operation was successful. TGeoElementRN * Next(); Return next element. void Print(Option_t* option = """") const; Print info about the current decay branch. TGeoElementRN * GetElement() const; {return fElem;}. TGeoElemIter(); {}. TObjArray * GetBranch() const; {return fBranch;}. const TGeoElementRN * GetTop() const; {return fTop;}. Int_t GetLevel() const; {return fLevel;}. Double_t GetRatio() const; {return fRatio;}. void SetLimitRatio(Double_t limit); {fLimitRatio = limit;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoElemIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoElemIter.html
https://root.cern/root/html532/TGeoEltu.html:3290,Availability,error,error,3290,"1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz(",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:3374,Availability,error,error,3374,"ube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacet",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:2082,Safety,safe,safe,2082,"10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:2340,Safety,safe,safe,2340,"st; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:13257,Safety,safe,safe,13257,"Inherited Members; Includes; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The ma",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:13450,Safety,safe,safe,13450,"Eltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, ",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:13530,Safety,safe,safe,13530,"Eltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, ",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:1059,Testability,test,testNo,1059," TGeoEltu(); TGeoEltu(Double_t* params); TGeoEltu(const TGeoEltu&); TGeoEltu(Double_t a, Double_t b, Double_t dz); TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); virtual~TGeoEltu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* p",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltu.html:12991,Testability,test,test,12991,"e_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has t",MatchSource.WIKI,root/html532/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltu.html
https://root.cern/root/html532/TGeoEltuEditor.html:4569,Availability,error,error,4569,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltuEditor.html
https://root.cern/root/html532/TGeoEltuEditor.html:4653,Availability,error,error,4653,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltuEditor.html
https://root.cern/root/html532/TGeoEltuEditor.html:17883,Availability,mask,mask,17883,,MatchSource.WIKI,root/html532/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltuEditor.html
https://root.cern/root/html532/TGeoEltuEditor.html:21243,Usability,undo,undoing,21243,"thframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoEltuEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoName(); Slot for name. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoA(); Slot for A. void DoB(); Slot for B. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoEltuEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoEltuEditor.html
https://root.cern/root/html532/TGeoGedFrame.html:497,Availability,avail,available,497,". TGeoGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoGedFrame. class TGeoGedFrame: public TGedFrame. TGeoGedFrame. Common base class for geombuilder editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGeoGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* r",MatchSource.WIKI,root/html532/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGedFrame.html
https://root.cern/root/html532/TGeoGedFrame.html:4461,Availability,error,error,4461,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html532/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGedFrame.html
https://root.cern/root/html532/TGeoGedFrame.html:4545,Availability,error,error,4545,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html532/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGedFrame.html
https://root.cern/root/html532/TGeoGedFrame.html:17336,Availability,mask,mask,17336,,MatchSource.WIKI,root/html532/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGedFrame.html
https://root.cern/root/html532/TGeoGenTrans.html:6232,Availability,error,error,6232,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:8296,Availability,error,error,8296,"e_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*TGeoCombiTrans::GetRotation() const; virtual const Double_t*TGeoCombiTrans::GetRotationMatrix() const; virtu",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:8380,Availability,error,error,8380,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*TGeoCombiTrans::GetRotation() const; virtual const Double_t*TGeoCombiTrans::GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; vir",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:3104,Integrability,interface,interface,3104," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:6238,Integrability,message,message,6238,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:6983,Modifiability,variab,variable,6983,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t p",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:488,Performance,optimiz,optimize,488,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:497,Performance,perform,performance,497,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:982,Performance,perform,performed,982,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:1708,Performance,perform,performed,1708,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:6215,Performance,perform,performed,6215,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
https://root.cern/root/html532/TGeoGenTrans.html:1721,Usability,simpl,simple,1721,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html532/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TGeoGenTrans.html
