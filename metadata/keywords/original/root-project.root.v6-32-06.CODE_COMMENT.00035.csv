id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:39,Testability,Test,Test,39,// Condition-code mask assignments for Test Data Class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:3,Availability,Mask,Mask,3,// Mask assignments for PFD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:3,Availability,Mask,Mask,3,// Mask assignments for TDC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:175,Deployability,update,update,175,"// MI is an instruction that accepts an optional alignment hint,; // and which was already lowered to LoweredMI. If the alignment; // of the original memory operand is known, update LoweredMI to; // an instruction with the corresponding hint set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:6,Performance,load,loads,6,// MI loads the high part of a vector from memory. Return an instruction; // that uses replicating vector load Opcode to do the same thing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:106,Performance,load,load,106,// MI loads the high part of a vector from memory. Return an instruction; // that uses replicating vector load Opcode to do the same thing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:11,Deployability,patch,patchpoint,11,"// Lower a patchpoint of the form:; // [<def>], <id>, <numBytes>, <target>, <numArgs>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:28,Testability,log,logic,28,"// Language Environment DLL logic requires function descriptors, for; // imported functions, that are placed in the ADA to be 8 byte aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:16,Availability,mask,mask,16,// Add emit FPR mask flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:15,Availability,mask,mask,15,// Add emit VR mask flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:25,Availability,mask,masks,25,// Get saved GPR/FPR/VPR masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:18,Availability,mask,mask,18,// Emit saved FPR mask and offset to FPR save area (0x20 of flags 3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:6,Availability,Mask,Mask,6,"// AR Mask, unused currently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:17,Availability,mask,mask,17,// Emit saved VR mask to VR save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:40,Integrability,Interface,Interfaces,40,"// See z/OS Language Environment Vendor Interfaces v2r5, p.23, for; // complete list. Only the C runtime is supported by this backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h:13,Availability,avail,available,13,/// The next available displacement value. Incremented when new entries into; /// the ADA are created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:108,Security,access,accessing,108,// This version of AnalyzeCallOperands in the base class is not usable; // since we must provide a means of accessing ISD::OutputArg::IsFixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:64,Usability,usab,usable,64,// This version of AnalyzeCallOperands in the base class is not usable; // since we must provide a means of accessing ISD::OutputArg::IsFixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:99,Usability,simpl,simple,99,"// Handle i128 argument types. These need to be passed by implicit; // reference. This could be as simple as the following .td line:; // CCIfType<[i128], CCPassIndirect<i64>>,; // except that i128 is not a legal type, and therefore gets split by; // common code into a pair of i64 arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:54,Energy Efficiency,Allocate,Allocate,54,"// OK, we've collected all parts in the pending list. Allocate; // the location (register or stack slot) for the indirect pointer.; // (This duplicates the usual i64 calling convention rules.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:28,Availability,avail,available,28,"// Shadow next two GPRs, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:206,Energy Efficiency,allocate,allocated,206,"// For any C or C++ program, this should always be; // false, since it is illegal to have a function; // where the first argument is variadic. Therefore; // the first fixed argument should already have; // allocated GPR1 either through shadowing it or; // using it for parameter passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:24,Availability,avail,available,24,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:87,Availability,avail,available,87,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:179,Energy Efficiency,allocate,allocate,179,"// If GPR2 and GPR3 are available, then we may pass vararg in R2Q.; // If only GPR3 is available, we need to set custom handling to copy; // hi bits into GPR3.; // Either way, we allocate on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h:174,Modifiability,variab,variables,174,"// end namespace SystemZCP; /// A SystemZ-specific constant pool value. At present, the only; /// defined constant pool values are module IDs or offsets of; /// thread-local variables (written x@TLSGD, x@TLSLDM, x@DTPOFF,; /// or x@NTPOFF).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h:3,Security,Access,Access,3,// Access SystemZ-specific fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZConstantPoolValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:28,Performance,load,load,28,// Return true if this is a load and test which can be optimized the; // same way as compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:55,Performance,optimiz,optimized,55,// Return true if this is a load and test which can be optimized the; // same way as compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:37,Testability,test,test,37,// Return true if this is a load and test which can be optimized the; // same way as compare instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:28,Performance,load,load-and-test,28,"// If we during isel used a load-and-test as a compare with 0, the; // def operand is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:37,Testability,test,test,37,"// If we during isel used a load-and-test as a compare with 0, the; // def operand is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:79,Testability,test,tested,79,"// Return the source register of Compare, which is the unknown value; // being tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:71,Performance,load,load,71,"// Compare compares the result of MI against zero. If MI is a suitable load; // instruction and if CCUsers is a single conditional trap on zero, eliminate; // the load and convert the branch to a load-and-trap. Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:163,Performance,load,load,163,"// Compare compares the result of MI against zero. If MI is a suitable load; // instruction and if CCUsers is a single conditional trap on zero, eliminate; // the load and convert the branch to a load-and-trap. Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:196,Performance,load,load-and-trap,196,"// Compare compares the result of MI against zero. If MI is a suitable load; // instruction and if CCUsers is a single conditional trap on zero, eliminate; // the load and convert the branch to a load-and-trap. Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:49,Performance,load,load-and-trap,49,// The transformation is OK. Rebuild Branch as a load-and-trap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:14,Performance,load,load,14,"// If MI is a load instruction, try to convert it into a LOAD AND TEST.; // Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:57,Performance,LOAD,LOAD,57,"// If MI is a load instruction, try to convert it into a LOAD AND TEST.; // Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:66,Testability,TEST,TEST,66,"// If MI is a load instruction, try to convert it into a LOAD AND TEST.; // Return true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:20,Availability,mask,masks,20,// Try to adjust CC masks for the LOAD AND TEST opcode that could replace MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:34,Performance,LOAD,LOAD,34,// Try to adjust CC masks for the LOAD AND TEST opcode that could replace MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:43,Testability,TEST,TEST,43,// Try to adjust CC masks for the LOAD AND TEST opcode that could replace MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:51,Testability,log,logical,51,"// See if MI is an instruction with an equivalent ""logical"" opcode that can; // be used and replace MI. This is useful for EQ/NE comparisons where the; // ""nsw"" flag is missing since the ""logical"" opcode always sets CC to reflect; // the result being zero or non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:188,Testability,log,logical,188,"// See if MI is an instruction with an equivalent ""logical"" opcode that can; // be used and replace MI. This is useful for EQ/NE comparisons where the; // ""nsw"" flag is missing since the ""logical"" opcode always sets CC to reflect; // the result being zero or non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:400,Availability,failure,failure,400,"// The CC users in CCUsers are testing the result of a comparison of some; // value X against zero and we know that any CC value produced by MI would; // also reflect the value of X. ConvOpc may be used to pass the transfomed; // opcode MI will have if this succeeds. Try to adjust CCUsers so that they; // test the result of MI directly, returning true on success. Leave; // everything unchanged on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:31,Testability,test,testing,31,"// The CC users in CCUsers are testing the result of a comparison of some; // value X against zero and we know that any CC value produced by MI would; // also reflect the value of X. ConvOpc may be used to pass the transfomed; // opcode MI will have if this succeeds. Try to adjust CCUsers so that they; // test the result of MI directly, returning true on success. Leave; // everything unchanged on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:307,Testability,test,test,307,"// The CC users in CCUsers are testing the result of a comparison of some; // value X against zero and we know that any CC value produced by MI would; // also reflect the value of X. ConvOpc may be used to pass the transfomed; // opcode MI will have if this succeeds. Try to adjust CCUsers so that they; // test the result of MI directly, returning true on success. Leave; // everything unchanged on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:53,Testability,test,test,53,"// If the caller will change MI to use ConvOpc, only test whether; // ConvOpc is suitable; it is on the caller to set the MI flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:40,Testability,test,test,40,"// If the caller will not change MI, we test the MI flag here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:47,Availability,avail,available,47,// See which compare-style condition codes are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:305,Safety,predict,predict,305,"// Signed addition of immediate. If adding a positive immediate; // overflows, the result must be less than zero. If adding a negative; // immediate overflows, the result must be larger than zero (except in; // the special case of adding the minimum value of the result range, in; // which case we cannot predict whether the result is larger than or; // equal to zero).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:32,Availability,mask,masks,32,// All users are OK. Adjust the masks for MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:34,Testability,log,logical,34,"// Translate the CCMask into its ""logical"" value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Testability,Log,Logical,3,// Logical subtracts never set CC=0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Usability,Clear,Clear,3,// Clear any intervening kills of CC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:10,Performance,optimiz,optimize,10,// Try to optimize cases where comparison instruction Compare is testing; // a value against zero. Return true on success and if Compare should be; // deleted as dead. CCUsers is the list of instructions that use the CC; // value produced by Compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:65,Testability,test,testing,65,// Try to optimize cases where comparison instruction Compare is testing; // a value against zero. Return true on success and if Compare should be; // deleted as dead. CCUsers is the list of instructions that use the CC; // value produced by Compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:81,Performance,load,load-and-trap,81,// Try to remove both MI and Compare by converting a branch to BRCT(G).; // or a load-and-trap instruction. We don't care in this case whether; // CC is modified between MI and Compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:122,Availability,redundant,redundant,122,// Try to fuse comparison instruction Compare into a later branch.; // Return true on success and if Compare is therefore redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:122,Safety,redund,redundant,122,// Try to fuse comparison instruction Compare into a later branch.; // Return true on success and if Compare is therefore redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:35,Availability,avail,available,35,"// Make sure that the operands are available at the branch.; // SrcReg2 is the register if the source operand is a register,; // 0 if the source operand is immediate, and the base register; // if the source operand is memory (index is not supported).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:19,Availability,mask,mask,19,"// Read the branch mask, target (if applicable), regmask (if applicable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Usability,Clear,Clear,3,// Clear out all current operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:3,Usability,Clear,Clear,3,// Clear any intervening kills of SrcReg and SrcReg2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:282,Modifiability,refactor,refactored,282,"// Sort all objects for short/paired displacements, which should be; // sufficient as it seems like all frame objects typically are within the; // long displacement range. Sorting works by computing the ""density"" as; // Count / ObjectSize. The comparisons of two such fractions are refactored; // by multiplying both sides with A.ObjectSize * B.ObjectSize, in order to; // eliminate the (fp) divisions. A higher density object needs to go after; // in the list in order for it to end up lower on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:23,Modifiability,variab,variable,23,// Put all invalid and variable sized objects at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:52,Safety,safe,safe,52,"// All invalid items are sorted at the end, so it's safe to stop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,"// The ELF ABI requires us to allocate 160 bytes of stack space for the; // callee, with any outgoing stack arguments being placed above that. It; // seems better to make that area a permanent feature of the frame even if; // we're using a frame pointer. Similarly, 64-bit XPLINK requires 96 bytes; // of stack space for the register save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:41,Energy Efficiency,allocate,allocated,41,// Get the size of our stack frame to be allocated ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:82,Security,access,access,82,// ... and the maximum offset we may need to reach into the; // caller's frame to access the save area or stack arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:101,Energy Efficiency,allocate,allocated,101,"// In GHC calling convention C stack space, including the ABI-defined; // 160-byte base area, is (de)allocated by GHC itself. This stack space may; // be used by LLVM as spill slots for the tail recursive GHC functions. Thus; // do not allocate stack space here, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:236,Energy Efficiency,allocate,allocate,236,"// In GHC calling convention C stack space, including the ABI-defined; // 160-byte base area, is (de)allocated by GHC itself. This stack space may; // be used by LLVM as spill slots for the tail recursive GHC functions. Thus; // do not allocate stack space here, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate the ABI-defined 160-byte base area whenever; // we allocate stack space for our own use and whenever we call another; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:74,Energy Efficiency,allocate,allocate,74,// We need to allocate the ABI-defined 160-byte base area whenever; // we allocate stack space for our own use and whenever we call another; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:9,Energy Efficiency,allocate,allocate,9,// Don't allocate the incoming reg save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate StackSize bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a block of Size bytes on the stack and probe it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:70,Integrability,rout,routine,70,// Checks if the function is a potential candidate for being a XPLeaf routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:83,Integrability,rout,routine,83,"// If function calls other functions including alloca, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:66,Integrability,rout,routine,66,"// If the function has var Sized Objects, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:62,Integrability,rout,routine,62,"// If the function adjusts the stack, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:80,Integrability,rout,routine,80,"// If function modifies the stack pointer register, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:66,Integrability,rout,routine,66,"// If function modifies the ADA register, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:81,Integrability,rout,routine,81,"// If function modifies the return address register, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:70,Integrability,rout,routine,70,"// If the backchain pointer should be stored, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:158,Energy Efficiency,allocate,allocated,158,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:69,Integrability,rout,routine,69,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:140,Modifiability,variab,variables,140,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate StackSize bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:117,Modifiability,extend,extender,117,"// If the requested stack size is larger than the guard page, then we need; // to check if we need to call the stack extender. This requires adding a; // conditional branch, but splitting the prologue block is not possible at; // this point since it would invalidate the SaveBlocks / RestoreBlocks sets; // of PEI in the single block function case. Build a pseudo to be handled; // later by inlineStackProbe().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:95,Modifiability,extend,extender,95,"// Emit a compare of the stack pointer against the stack floor, and a call to; // the LE stack extender if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:1221,Deployability,update,updated,1221,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:437,Energy Efficiency,schedul,scheduler,437,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:490,Energy Efficiency,schedul,scheduling,490,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:543,Energy Efficiency,schedul,scheduling,543,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:590,Energy Efficiency,schedul,scheduling,590,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:760,Energy Efficiency,schedul,scheduled,760,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:980,Energy Efficiency,schedul,scheduling,980,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:1082,Energy Efficiency,schedul,scheduling,1082,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:1171,Energy Efficiency,schedul,scheduling,1171,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:42,Safety,Hazard,Hazard,42,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:403,Safety,hazard,hazard,403,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:66,Energy Efficiency,schedul,scheduler,66,// This is the limit of processor resource usage at which the; // scheduler should try to look for other instructions (not using the; // critical resource).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:40,Energy Efficiency,schedul,schedule,40,// A cracked instruction only fits into schedule if the current; // group is empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:3,Usability,Clear,Clear,3,// Clear CriticalResourceIdx if it is now below the threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:3,Deployability,Update,Update,3,// Update state with SU as the next scheduled unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:36,Energy Efficiency,schedul,scheduled,36,// Update state with SU as the next scheduled unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:6,Energy Efficiency,schedul,scheduling,6,"// If scheduling an SU that must begin a new decoder group, move on; // to next group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:45,Energy Efficiency,schedul,scheduled,45,"// If this is the first FPd op, it should be scheduled high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:1222,Deployability,update,updated,1222,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:438,Energy Efficiency,schedul,scheduler,438,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:491,Energy Efficiency,schedul,scheduling,491,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:544,Energy Efficiency,schedul,scheduling,544,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:591,Energy Efficiency,schedul,scheduling,591,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:761,Energy Efficiency,schedul,scheduled,761,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:981,Energy Efficiency,schedul,scheduling,981,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:1083,Energy Efficiency,schedul,scheduling,1083,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:1172,Energy Efficiency,schedul,scheduling,1172,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:42,Safety,Hazard,Hazard,42,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:404,Safety,hazard,hazard,404,"//=-- SystemZHazardRecognizer.h - SystemZ Hazard Recognizer -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a hazard recognizer for the SystemZ scheduler.; //; // This class is used by the SystemZ scheduling strategy to maintain; // the state during scheduling, and provide cost functions for; // scheduling candidates. This includes:; //; // * Decoder grouping. A decoder group can maximally hold 3 uops, and; // instructions that always begin a new group should be scheduled when; // the current decoder group is empty.; // * Processor resources usage. It is beneficial to balance the use of; // resources.; //; // A goal is to consider all instructions, also those outside of any; // scheduling region. Such instructions are ""advanced"" past and include; // single instructions before a scheduling region, branches etc.; //; // A block that has only one predecessor continues scheduling with the state; // of it (which may be updated by emitting branches).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:67,Energy Efficiency,schedul,scheduling,67,/// SystemZHazardRecognizer maintains the state for one MBB during scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:60,Energy Efficiency,schedul,scheduled,60,/// True if an instruction with four reg operands have been scheduled into; /// the current decoder group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:286,Energy Efficiency,schedul,scheduled,286,"/// The tracking of resources here are quite similar to the common; /// code use of a critical resource. However, z13 differs in the way; /// that it has two processor sides which may be interesting to; /// model in the future (a work in progress).; /// Counters for the number of uops scheduled per processor; /// resource.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:65,Energy Efficiency,schedul,scheduler,65,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:43,Performance,queue,queue,43,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:84,Safety,avoid,avoid,84,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:105,Energy Efficiency,schedul,scheduled,105,/// LastFPdOpCycleIdx stores the numbeer returned by getCurrCycleIdx(); /// when a stalling operation is scheduled (which uses the FPd resource).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:32,Energy Efficiency,schedul,scheduled,32,/// A counter of decoder groups scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:4,Usability,Clear,Clear,4,/// Clear all counters for processor resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:110,Energy Efficiency,schedul,schedule,110,"/// With the goal of alternating processor sides for stalling (FPd); /// ops, return true if it seems good to schedule an FPd op next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:34,Energy Efficiency,schedul,scheduling,34,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:17,Performance,cache,cache,17,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:15,Energy Efficiency,schedul,scheduled,15,/// Wrap a non-scheduled instruction in an SU and emit it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:4,Integrability,Wrap,Wrap,4,/// Wrap a non-scheduled instruction in an SU and emit it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:212,Energy Efficiency,schedul,schedule,212,"// Cost functions used by SystemZPostRASchedStrategy while; // evaluating candidates.; /// Return the cost of decoder grouping for SU. If SU must start a; /// new decoder group, this is negative if this fits the schedule or; /// positive if it would mean ending a group prematurely. For normal; /// instructions this returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:185,Energy Efficiency,schedul,schedule,185,"/// Return the cost of SU in regards to processor resources usage.; /// A positive value means it would be better to wait with SU, while; /// a negative value means it would be good to schedule SU next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrBuilder.h:393,Security,expose,exposes,393,"//===-- SystemZInstrBuilder.h - Functions to aid building insts -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to handle SystemZ'isms in a clean way.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:12,Availability,mask,mask,12,// Return a mask with Count low bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:19,Performance,load,load,19,"// MI is a 128-bit load or store. Split it into two 64-bit loads or stores,; // each having the opcode given by NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:59,Performance,load,loads,59,"// MI is a 128-bit load or store. Split it into two 64-bit loads or stores,; // each having the opcode given by NewOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:11,Performance,load,load,11,// Get two load or store instructions. Use the original instruction for; // one of them and create a clone for the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:3,Usability,Clear,Clear,3,// Clear the kill flags on the address registers in the first instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:185,Integrability,depend,depending,185,"// MI is a three-operand RIE-style pseudo instruction. Replace it with; // LowOpcodeK if the registers are both low GR32s, otherwise use a move; // followed by HighOpcode or LowOpcode, depending on whether the target; // is a high or low GR32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:11,Performance,load,load-on-condition,11,// MI is a load-on-condition pseudo instruction with a single register; // (source or destination) operand. Replace it with LowOpcode if the; // register is a low GR32 and HighOpcode if the register is a high GR32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:50,Modifiability,extend,extends,50,"// MI is an RR-style pseudo instruction that zero-extends the low Size bits; // of one GRX32 into another. Replace it with LowOpcode if both operands; // are low registers, otherwise use RISB[LH]G.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:16,Performance,load,load,16,"// EAR can only load the low subregister so us a shift for %a0 to produce; // the GR containing %a0 and %a1.; // ear <reg>, %a0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:15,Modifiability,extend,extending,15,"// Emit a zero-extending move from 32-bit GPR SrcReg to 32-bit GPR; // DestReg before MBBI in MBB. Use LowLowOpcode when both DestReg and SrcReg; // are low registers, otherwise use RISB[LH]G. Size is the number of bits; // taken from the low end of SrcReg (8 for LLCR, 16 for LLHR and 32 for LR).; // KillSrc is true if this move is the last use of SrcReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:21,Performance,load,load,21,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:82,Performance,load,loads,82,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:209,Performance,load,loads,209,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:14,Usability,simpl,simple,14,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:191,Usability,Simpl,SimpleBDXLoad,191,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:219,Usability,Simpl,SimpleBDXStore,219,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:149,Deployability,pipeline,pipeline,149,"// In this function we output 32-bit branches, which should always; // have enough range. They can be shortened and relaxed by later code; // in the pipeline, if desired.; // Shouldn't be a fall through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:3,Safety,Avoid,Avoid,3,"// Avoid using conditional returns at the end of a loop (since then; // we'd need to emit an unconditional branch to the beginning anyway,; // making the loop body longer). This doesn't apply for low-probability; // loops (eg. compare-and-swap retry), so just decide based on branch; // probability instead of looping structure.; // However, since Compare and Trap instructions cost the same as a regular; // Compare instruction, we should allow the if conversion to convert this; // into a Conditional Compare regardless of the branch probability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:11,Safety,avoid,avoid,11,// For now avoid converting mutually-exclusive cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:60,Integrability,depend,dependencies,60,// For z13 we prefer LDR over LER to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:37,Safety,avoid,avoid,37,// For z13 we prefer LDR over LER to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:33,Performance,load,load,33,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:118,Performance,load,loads,118,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:26,Usability,simpl,simple,26,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:100,Usability,Simpl,SimpleBDXLoad,100,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:128,Usability,Simpl,SimpleBDXStore,128,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:20,Availability,avail,available,20,"// Prefer RISBGN if available, since it does not clobber CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:52,Performance,load,load,52,"// If we're spilling the source of an LDGR or LGDR, load the; // destination register instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:753,Availability,redundant,redundant,753,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:88,Performance,load,load,88,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:288,Performance,load,load,288,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:507,Performance,perform,performance,507,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:544,Safety,avoid,avoid,544,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:753,Safety,redund,redundant,753,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:217,Testability,log,logically,217,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:40,Usability,simpl,simple,40,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:81,Usability,simpl,simple,81,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:24,Performance,load,loads,24,// Handle conversion of loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:35,Usability,usab,usable,35,// Check if all other vregs have a usable allocation in the case of vector; // to FP conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:77,Energy Efficiency,allocate,allocated,77,// Constrain the register classes if converted from a vector opcode. The; // allocated regs are in an FP reg-class per previous check above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:171,Performance,load,load-and-test,171,"// On zEC12 we prefer to use RISBGN. But if there is a chance to; // actually use the condition code, we may turn it back into RISGB.; // Note that RISBG is not really a ""load-and-test"" instruction,; // but sets the same condition code values, so is OK to use here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:180,Testability,test,test,180,"// On zEC12 we prefer to use RISBGN. But if there is a chance to; // actually use the condition code, we may turn it back into RISGB.; // Note that RISBG is not really a ""load-and-test"" instruction,; // but sets the same condition code values, so is OK to use here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:27,Availability,mask,masks,27,// Reject trivial all-zero masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:14,Integrability,wrap,wrap-around,14,// Handle the wrap-around 1+0+1+ cases. Start then specifies the msb; // of the low 1s and End specifies the lsb of the high 1s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:3,Deployability,Update,Update,3,// Update all CC users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:3,Availability,Mask,Masks,3,// Masks out the bits for the access model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:30,Security,access,access,30,// Masks out the bits for the access model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:53,Security,access,accesses,53,"// z/OS XPLink specific: classifies the types of; // accesses to the ADA (Associated Data Area).; // These enums contains values that overlap with the above MO_ enums,; // but that's fine since the above enums are used with ELF,; // while these values are used with z/OS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:37,Availability,mask,mask,37,// Return a version of comparison CC mask CCMask in which the LT and GT; // actions are swapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:104,Availability,mask,mask,104,"// Return true if MI is a conditional or unconditional branch.; // When returning true, set Cond to the mask of condition-code; // values on which the instruction will branch, and set Target; // to the operand that contains the branch target. This target; // can be a register or a basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:11,Performance,load,load,11,// Get the load and store opcodes for a given register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:99,Performance,perform,perform,99,"// Opcode is the opcode of an instruction that has an address operand,; // and the caller wants to perform that instruction's operation on an; // address that has displacement Offset. Return the opcode of a suitable; // instruction (which might be Opcode itself) or 0 if no such instruction; // exists. MI may be passed in order to allow examination of physical; // register operands (i.e. if a VR32/64 reg ended up as an FP or Vector reg).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:18,Performance,load,load,18,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:46,Performance,LOAD,LOAD,46,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:55,Testability,TEST,TEST,55,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:96,Testability,test,testing,96,"// If Opcode is a load instruction that has a LOAD AND TEST form,; // return the opcode for the testing form, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:78,Availability,Mask,Mask,78,"// Return true if ROTATE AND ... SELECTED BITS can be used to select bits; // Mask of the R2 operand, given that only the low BitSize bits of Mask are; // significant. Set Start and End to the I3 and I4 operands if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:142,Availability,Mask,Mask,142,"// Return true if ROTATE AND ... SELECTED BITS can be used to select bits; // Mask of the R2 operand, given that only the low BitSize bits of Mask are; // significant. Set Start and End to the I3 and I4 operands if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:66,Deployability,update,update,66,// Try to find all CC users of the compare instruction (MBBI) and update; // all of them to maintain equivalent behavior after swapping the compare; // operands. Return false if not all users can be conclusively found and; // handled. The compare instruction is *not* changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:18,Performance,LOAD,LOAD,18,"// If Opcode is a LOAD opcode for with an associated LOAD AND TRAP; // operation exists, returh the opcode for the latter, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:53,Performance,LOAD,LOAD,53,"// If Opcode is a LOAD opcode for with an associated LOAD AND TRAP; // operation exists, returh the opcode for the latter, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:3,Performance,Perform,Perform,3,// Perform target specific instruction verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:105,Security,access,access,105,"// Sometimes, it is possible for the target to tell, even without; // aliasing information, that two MIs access different memory; // addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:182,Security,access,access,182,"// Sometimes, it is possible for the target to tell, even without; // aliasing information, that two MIs access different memory; // addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:31,Performance,load,load,31,// base+displacement+index for load and store operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:31,Performance,load,load,31,// base+displacement+index for load address operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:12,Availability,mask,mask,12,// Return a mask with Count low bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:247,Availability,Mask,Mask,247,"// Represents operands 2 to 5 of the ROTATE AND ... SELECTED BITS operation; // given by Opcode. The operands are: Input (R2), Start (I3), End (I4) and; // Rotate (I5). The combined operand value is effectively:; //; // (or (rotl Input, Rotate), ~Mask); //; // for RNSBG and:; //; // (and (rotl Input, Rotate), Mask); //; // otherwise. The output value has BitSize bits, although Input may be; // narrower (in which case the upper bits are don't care), or wider (in which; // case the result will be truncated as part of the operation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:311,Availability,Mask,Mask,311,"// Represents operands 2 to 5 of the ROTATE AND ... SELECTED BITS operation; // given by Opcode. The operands are: Input (R2), Start (I3), End (I4) and; // Rotate (I5). The combined operand value is effectively:; //; // (or (rotl Input, Rotate), ~Mask); //; // for RNSBG and:; //; // (and (rotl Input, Rotate), Mask); //; // otherwise. The output value has BitSize bits, although Input may be; // narrower (in which case the upper bits are don't care), or wider (in which; // case the result will be truncated as part of the operation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:32,Integrability,rout,routines,32,// PC-relative address matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:15,Integrability,rout,routines,15,// BD matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,Integrability,rout,routines,16,// MVI matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,Integrability,rout,routines,16,// BDX matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:63,Availability,Mask,Mask,63,// Try to update RxSBG so that only the bits of RxSBG.Input in Mask are used.; // Return true on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:10,Deployability,update,update,10,// Try to update RxSBG so that only the bits of RxSBG.Input in Mask are used.; // Return true on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:55,Performance,load,loaded,55,"// If Op0 is null, then Node is a constant that can be loaded using:; //; // (Opcode UpperVal LowerVal); //; // If Op0 is nonnull, then Node can be implemented using:; //; // (Opcode (Opcode Op0 UpperVal) LowerVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Performance,load,load,22,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:64,Usability,simpl,simple,64,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:18,Performance,Load,Load,18,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:37,Performance,load,loads,37,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:380,Safety,avoid,avoid,380,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:276,Testability,log,logically,276,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:18,Performance,load,load,18,"// N is a (store (load Y), X) pattern. Return true if it can use an MVC; // from Y to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Performance,load,load,22,"// N is a (store (op (load A[0]), (load A[1])), X) pattern. Return true; // if A[1 - I] == X and if N can use a block operation like NC from A[I]; // to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:35,Performance,load,load,35,"// N is a (store (op (load A[0]), (load A[1])), X) pattern. Return true; // if A[1 - I] == X and if N can use a block operation like NC from A[I]; // to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:23,Performance,load,load,23,// Return true if N (a load or a store) fullfills the alignment; // requirements for a PC-relative access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:99,Security,access,access,99,// Return true if N (a load or a store) fullfills the alignment; // requirements for a PC-relative access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:126,Performance,tune,tuned,126,"// We could consider forcing the displacement into a register and; // using it as an index, but it would need to be carefully tuned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:48,Performance,perform,performed,48,// Return true if Base + Disp + Index should be performed by LA(Y).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:115,Safety,avoid,avoids,115,// Always use LA if the displacement is small enough. It should always; // be no worse than AGHI (and better if it avoids a move).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:51,Modifiability,extend,extended,51,"// Prefer addition if the second operation is sign-extended, in the; // hope of using AGF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:90,Modifiability,extend,extend,90,"// Start out assuming that the address will need to be loaded separately,; // then try to extend it as much as we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:55,Performance,load,loaded,55,"// Start out assuming that the address will need to be loaded separately,; // then try to extend it as much as we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:250,Integrability,depend,depend,250,"// Insert a node into the DAG at least before Pos. This will reposition; // the node as needed, and will assign it a node ID that is <= Pos's ID.; // Note that this does *not* preserve the uniqueness of node IDs!; // The selection DAG must no longer depend on their uniqueness when this; // function is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:78,Security,access,access,78,// We can't tell here whether the index vector has the right type; // for the access; the caller needs to do that instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Availability,mask,mask,22,// We need a constant mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:56,Availability,mask,masks,56,// It's not an insertion of Op.getOperand(0) if the two masks overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:45,Availability,Mask,Mask,45,// Return true if any bits of (RxSBG.Input & Mask) are significant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,Availability,mask,mask,14,// Rotate the mask in the same way as RxSBG.Input is rotated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:97,Availability,mask,mask,97,"// If some bits of Input are already known zeros, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:144,Availability,mask,mask,144,"// If some bits of Input are already known zeros, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:96,Availability,mask,mask,96,"// If some bits of Input are already known ones, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:143,Availability,mask,mask,143,"// If some bits of Input are already known ones, those bits will have; // been removed from the mask. See if adding them back in makes the; // mask suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:18,Modifiability,extend,extended,18,// Bits above the extended operand are don't-care.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,Availability,mask,mask,16,// Restrict the mask to the extended operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:28,Modifiability,extend,extended,28,// Restrict the mask to the extended operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:58,Availability,mask,masked,58,// Check that the extension bits are don't-care (i.e. are masked out; // by the final mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:86,Availability,mask,mask,86,// Check that the extension bits are don't-care (i.e. are masked out; // by the final mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:25,Availability,mask,mask,25,"// Treat (srl X, count), mask) as (and (rotl X, size-count), ~0>>count),; // which is similar to SLL above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:168,Testability,log,logical,168,// The widening or narrowing is expected to be free.; // Counting widening or narrowing as a saved operation will result in; // preferring an R*SBG over a simple shift/logical instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:155,Usability,simpl,simple,155,// The widening or narrowing is expected to be free.; // Counting widening or narrowing as a saved operation will result in; // preferring an R*SBG over a simple shift/logical instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:20,Availability,avail,available,20,"// Prefer RISBGN if available, since it does not clobber CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:97,Integrability,wrap,wrapping,97,"// We can only use the 32-bit instructions if all source bits are; // in the low 32 bits without wrapping, both after rotation (because; // of the smaller range for Start and End) and before rotation; // (because the input value is truncated).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:350,Testability,log,logical,350,"// In cases of multiple users it seems better to keep the simple; // instruction as they are one cycle faster, and it also helps in cases; // where both inputs share a common node.; // The widening or narrowing is expected to be free. Counting widening; // or narrowing as a saved operation will result in preferring an R*SBG; // over a simple shift/logical instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:58,Usability,simpl,simple,58,"// In cases of multiple users it seems better to keep the simple; // instruction as they are one cycle faster, and it also helps in cases; // where both inputs share a common node.; // The widening or narrowing is expected to be free. Counting widening; // or narrowing as a saved operation will result in preferring an R*SBG; // over a simple shift/logical instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:337,Usability,simpl,simple,337,"// In cases of multiple users it seems better to keep the simple; // instruction as they are one cycle faster, and it also helps in cases; // where both inputs share a common node.; // The widening or narrowing is expected to be free. Counting widening; // or narrowing as a saved operation will result in preferring an R*SBG; // over a simple shift/logical instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Safety,avoid,avoid,22,// See whether we can avoid an AND in the first operand by converting; // ROSBG to RISBG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:20,Availability,avail,available,20,"// Prefer RISBGN if available, since it does not clobber CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:455,Safety,avoid,avoid,455,"// When we haven't passed in Op0, Upper will be a constant. In order to; // prevent folding back to the large immediate in `Or = getNode(...)` we run; // SelectCode first and end up with an opaque machine node. This means that; // we need to use a handle to keep track of Upper in case it gets CSE'd by; // SelectCode.; //; // Note that in the case where Op0 is passed in we could just call; // SelectCode(Upper) later, along with the SelectCode(Or), and avoid needing; // the handle at all, but it's fine to do it here.; //; // TODO: This is a pretty hacky way to do this. Can we do something that; // doesn't require a two paragraph explanation?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:85,Performance,load,load,85,// Check whether or not the chain ending in StoreNode is suitable for doing; // the {load; op; store} to modify transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:31,Performance,load,loaded,31,// Are there other uses of the loaded value than the operation?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:20,Modifiability,extend,extending,20,// Is the store non-extending and non-indexed?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:29,Modifiability,extend,extending,29,// Is the stored value a non-extending and non-indexed load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:55,Performance,load,load,55,// Is the stored value a non-extending and non-indexed load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:10,Performance,Load,LoadNode,10,// Return LoadNode by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:33,Performance,load,loaded,33,// Is store the only read of the loaded value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:47,Performance,load,load,47,// Is the address of the store the same as the load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:41,Performance,load,load,41,// Check if the chain is produced by the load or is a TokenFactor with; // the load output chain as an operand. Return InputChain by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:79,Performance,load,load,79,// Check if the chain is produced by the load or is a TokenFactor with; // the load output chain as an operand. Return InputChain by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:8,Performance,Load,Load,8,"// Drop Load, but keep its chain. No cycle check necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:12,Performance,Load,Load,12,// Check if Load is reachable from any of the nodes in the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:77,Performance,load,load,77,// Make a new TokenFactor with all the other input chains except; // for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:348,Integrability,rout,routine,348,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the CC on the original operation are used.; //; // See the equivalent routine in X86ISelDAGToDAG for further comments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,Performance,load,load,22,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the CC on the original operation are used.; //; // See the equivalent routine in X86ISelDAGToDAG for further comments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:64,Usability,simpl,simple,64,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the CC on the original operation are used.; //; // See the equivalent routine in X86ISelDAGToDAG for further comments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:23,Security,access,access,23,// Volatility stops an access from being decomposed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:39,Performance,load,load,39,// There's no chance of overlap if the load is invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,Security,access,access,14,// The memory access must have a proper alignment and no index register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:6,Security,access,access,6,// An access to GOT or the Constant Pool is aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:186,Performance,optimiz,optimize,186,"// If this is a 64-bit operation in which both 32-bit halves are nonzero,; // split the operation into two. If both operands here happen to be; // constant, leave this to common code to optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:69,Testability,log,logical,69,// Don't split the operation if we can match one of the combined; // logical operations provided by miscellaneous-extensions-3.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:21,Performance,load,load,21,"// Prefer to put any load first, so that it can be matched as a; // conditional load. Likewise for constants in range for LOCHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:80,Performance,load,load,80,"// Prefer to put any load first, so that it can be matched as a; // conditional load. Likewise for constants in range for LOCHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:30,Performance,LOAD,LOAD,30,// We want to avoid folding a LOAD into an ICMP node if as a result; // we would be forced to spill the condition code into a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,Safety,avoid,avoid,14,// We want to avoid folding a LOAD into an ICMP node if as a result; // we would be forced to spill the condition code into a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:140,Performance,load,load,140,"// If the actual instruction is a branch, the only thing that remains to be; // checked is whether the CCUser chain is a predecessor of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:127,Performance,load,load,127,"// Otherwise, the instruction may have multiple operands, and we need to; // verify that none of them are a predecessor of the load. This is exactly; // the same check that would be done by common code if the CC setter were; // glued to the CC user, so simply invoke that check here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:253,Usability,simpl,simply,253,"// Otherwise, the instruction may have multiple operands, and we need to; // verify that none of them are a predecessor of the load. This is exactly; // the same check that would be done by common code if the CC setter were; // glued to the CC user, so simply invoke that check here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:251,Testability,test,tests,251,"// Deal with cases where we can add a value to force the sign bit; // to contain the right value. Putting the bit in 31 means we can; // use SRL rather than RISBG(L), and also makes it easier to get a; // 0/-1 value, so it has priority over the other tests below.; //; // These sequences rely on the fact that the upper two bits of the; // IPM result are zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:36,Testability,test,testing,36,"// Next try inverting the value and testing a bit. 0/1 could be; // handled this way too, but we dealt with that case above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:35,Performance,optimiz,optimized,35,// The SHR/AND sequence should get optimized to an RISBG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:8,Modifiability,extend,extend,8,// Sign-extend from IPM.Bit using a pair of shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:36,Performance,load,loads,36,"// If we have conditional immediate loads, we always prefer; // using those over an IPM sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Availability,mask,mask,7,// The mask of CC values that Opcode can produce.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Availability,mask,mask,7,// The mask of CC values for which the original condition is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,Safety,safe,safely,50,// Return a version of MachineOperand that can be safely used before the; // final use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:57,Energy Efficiency,schedul,scheduling,57,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:113,Energy Efficiency,schedul,scheduler,113,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:230,Energy Efficiency,schedul,scheduler,230,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:40,Performance,latency,latency-oriented,40,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:96,Performance,latency,latency-oriented,96,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Performance,perform,performance,7,// For performance reasons we prefer 16-byte alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:59,Performance,load,loads,59,"// Lower ATOMIC_LOAD and ATOMIC_STORE into normal volatile loads and; // stores, putting a serialization instruction after the stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:70,Availability,avail,available,70,"// Lower ATOMIC_LOAD_SUB into ATOMIC_LOAD_ADD if LAA and LAAG are; // available, or if the operand is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Modifiability,extend,extending,38,// Likewise all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,load,loads,48,// Likewise all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect shifts/rotates by a scalar amount and convert them into; // V*_BY_SCALAR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Modifiability,extend,extended,18,// We can use the extended form of FI for other rounding operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Modifiability,enhance,enhancements,14,// The vector enhancements facility 1 has instructions for these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:85,Modifiability,extend,extend,85,// Needed so that we don't try to implement f128 constant loads using; // a load-and-extend of a f80 constant (in cases where the constant; // would fit in an f80).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:58,Performance,load,loads,58,// Needed so that we don't try to implement f128 constant loads using; // a load-and-extend of a f80 constant (in cases where the constant; // would fit in an f80).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:76,Performance,load,load-and-extend,76,// Needed so that we don't try to implement f128 constant loads using; // a load-and-extend of a f80 constant (in cases where the constant; // would fit in an f80).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Modifiability,extend,extending,17,// We don't have extending load instruction on vector registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:27,Performance,load,load,27,// We don't have extending load instruction on vector registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:30,Performance,perform,perform,30,// Codes for which we want to perform some z-specific combinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:53,Performance,load,load,53,// We want to use MVC in preference to even a single load/store pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:210,Modifiability,variab,variable,210,"// The main memset sequence is a byte store followed by an MVC.; // Two STC or MV..I stores win over that, but the kind of fused stores; // generated by target-independent code don't when the byte value is; // variable. E.g. ""STC <reg>;MHI <reg>,257;STH <reg>"" is not better; // than ""STC;MVC"". Handle the choice in target-specific code instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:34,Availability,MASK,MASK,34,// Try using VECTOR GENERATE BYTE MASK. This is the architecturally-; // preferred way of creating all-zero and all-one vectors so give it; // priority over other methods below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Availability,MASK,MASK,23,// Try VECTOR GENERATE MASK,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:248,Availability,mask,mask,248,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:272,Availability,MASK,MASK,272,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:237,Integrability,wrap,wraparound,237,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:175,Modifiability,extend,extended,175,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:158,Availability,mask,mask,158,// Now try assuming that any undefined bits between the first and; // last defined set bits are set. This increases the chances of; // using a non-wraparound mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:147,Integrability,wrap,wraparound,147,// Now try assuming that any undefined bits between the first and; // last defined set bits are set. This increases the chances of; // using a non-wraparound mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Performance,load,load,10,// We can load zero using LZ?R and negative zero using LZ?R;LC?BR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:49,Availability,avail,available,49,// Don't expand if there is a target instruction available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:13,Security,access,accesses,13,// Unaligned accesses should never be slower than the expanded version.; // We check specifically for aligned accesses in the few cases where; // they are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:110,Security,access,accesses,110,// Unaligned accesses should never be slower than the expanded version.; // We check specifically for aligned accesses in the few cases where; // they are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,Security,access,access,54,// Information about the addressing mode for a memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Performance,Load,Load,44,// Return the desired addressing mode for a Load which has only one use (in; // the same block) which is a Store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:25,Performance,Load,Load,25,// With vector support a Load->Store combination may be combined to either; // an MVC or vector operations and it seems to work best to allow the; // vector addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load->Store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load->Store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:69,Integrability,depend,dependencies,69,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:194,Performance,load,load,194,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:42,Safety,avoid,avoid,42,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:5,Performance,load,load,5,// A load which gets inserted into a vector element will be combined into a; // VLE type instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:31,Performance,load,loads,31,// Don't expand Op into scalar loads/stores in these cases:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:101,Integrability,depend,depends,101,"// We need to override the default register parsing for GPRs and FPRs; // because the interpretation depends on VT. The internal names of; // the registers are also different from the external names; // (F0D and F0S instead of F0, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:165,Performance,load,loads,165,"// Value is a value that has been passed to us in the location described by VA; // (and so has type VA.getLocVT()). Convert Value to VA.getValVT(), chaining; // any loads onto Chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:72,Testability,assert,assertion,72,"// If the argument has been promoted from a smaller type, insert an; // assertion to capture this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:65,Modifiability,extend,extend,65,"// If this is a short vector argument loaded from the stack,; // extend from i64 to full vector size and then bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Performance,load,loaded,38,"// If this is a short vector argument loaded from the stack,; // extend from i64 to full vector size and then bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:52,Performance,load,load,52,// Create the SelectionDAG nodes corresponding to a load; // from this parameter. Unpromoted ints and floats are; // passed as right-justified 8-byte values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:66,Performance,load,load,66,"// If the original argument was split (e.g. i128), we need; // to load all parts of it here (using the same address).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:47,Energy Efficiency,allocate,allocated,47,// ...and a similar frame index for the caller-allocated save area; // that will be used to store the incoming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Security,access,access,7,"// ADA access using Global value; // Note: for functions, address of descriptor is returned",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,Safety,detect,detected,62,"// We don't support GuaranteedTailCallOpt, only automatically-detected; // sibling calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the full stack space for a promoted (and split) argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Queue,Queue,3,// Queue up the argument copies and emit them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Safety,detect,detect,38,// Special case that we cannot easily detect in RetCC_SystemZ since; // i128 may not be a legal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain and glue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:166,Availability,mask,mask,166,// Return true if Op is an intrinsic node with chain that returns the CC value; // as its only (other) argument. Provide the associated SystemZISD opcode and; // the mask of valid CC values if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:162,Availability,mask,mask,162,// Return true if Op is an intrinsic node without chain that returns the; // CC value as its final argument. Provide the associated SystemZISD; // opcode and the mask of valid CC values if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:124,Availability,mask,mask,124,"// CC is a comparison that will be implemented using an integer or; // floating-point comparison. Return the condition code mask for; // a branch on true. In the integer case, CCMASK_CMP_UO is set for; // unsigned comparisons and clear for signed ones. In the floating-point; // case, CCMASK_CMP_UO has its normal mask meaning (unordered).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:314,Availability,mask,mask,314,"// CC is a comparison that will be implemented using an integer or; // floating-point comparison. Return the condition code mask for; // a branch on true. In the integer case, CCMASK_CMP_UO is set for; // unsigned comparisons and clear for signed ones. In the floating-point; // case, CCMASK_CMP_UO has its normal mask meaning (unordered).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:230,Usability,clear,clear,230,"// CC is a comparison that will be implemented using an integer or; // floating-point comparison. Return the condition code mask for; // a branch on true. In the integer case, CCMASK_CMP_UO is set for; // unsigned comparisons and clear for signed ones. In the floating-point; // case, CCMASK_CMP_UO has its normal mask meaning (unordered).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:77,Performance,load,load,77,"// For us to make any changes, it must a comparison between a single-use; // load and a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:32,Performance,load,load,32,// We must have an 8- or 16-bit load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Modifiability,extend,extending,23,// The load must be an extending one and the constant must be within the; // range of the unextended value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Performance,load,load,7,// The load must be an extending one and the constant must be within the; // range of the unextended value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:40,Modifiability,extend,extended,40,// Unsigned comparison between two sign-extended values is equivalent; // to unsigned comparison between two zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:114,Modifiability,extend,extended,114,// Unsigned comparison between two sign-extended values is equivalent; // to unsigned comparison between two zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Testability,Test,Test,3,// Test whether the high bit of the byte is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Testability,Test,Test,3,// Test whether the high bit of the byte is clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Usability,clear,clear,44,// Test whether the high bit of the byte is clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update the chain uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Performance,load,load,45,"// Return true if Op is either an unextended load, or a load suitable; // for integer register-memory comparisons of type ICmpType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:56,Performance,load,load,56,"// Return true if Op is either an unextended load, or a load suitable; // for integer register-memory comparisons of type ICmpType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:89,Performance,LOAD,LOAD,89,"// Always keep a floating-point constant second, since comparisons with; // zero can use LOAD TEST and comparisons with other constants make a; // natural memory operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:94,Testability,TEST,TEST,94,"// Always keep a floating-point constant second, since comparisons with; // zero can use LOAD TEST and comparisons with other constants make a; // natural memory operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:65,Performance,optimiz,optimize,65,// Never swap comparisons with zero since there are many ways to optimize; // those later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:51,Performance,load,loaded,51,// Also keep natural memory operands second if the loaded value is; // only used here. Several comparisons have memory forms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Performance,load,load,45,// Look for cases where Cmp0 is a single-use load and Cmp1 isn't.; // In that case we generally prefer the memory to be second.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:19,Testability,test,tests,19,// Check whether C tests for equality between X and Y and whether X - Y; // or Y - X is also computed. In that case it's better to compare the; // result of the subtraction against zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:188,Performance,LOAD,LOAD,188,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:210,Performance,LOAD,LOAD,210,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:170,Safety,avoid,avoiding,170,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:197,Testability,TEST,TEST,197,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:8,Performance,optimiz,optimization,8,"// This optimization is invalid for strict comparisons, since FNEG; // does not raise any exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:78,Modifiability,extend,extended,78,"// Check whether C compares (shl X, 32) with 0 and whether X is; // also sign-extended. In that case it is better to test the result; // of the sign extension using LTGFR.; //; // This case is important because InstCombine transforms a comparison; // with (sext (trunc X)) into a comparison with (shl X, 32).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:117,Testability,test,test,117,"// Check whether C compares (shl X, 32) with 0 and whether X is; // also sign-extended. In that case it is better to test the result; // of the sign extension using LTGFR.; //; // This case is important because InstCombine transforms a comparison; // with (sext (trunc X)) into a comparison with (shl X, 32).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Modifiability,extend,extending,38,"// If C compares the truncation of an extending load, try to compare; // the untruncated value instead. This exposes more opportunities to; // reuse CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,load,load,48,"// If C compares the truncation of an extending load, try to compare; // the untruncated value instead. This exposes more opportunities to; // reuse CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:109,Security,expose,exposes,109,"// If C compares the truncation of an extending load, try to compare; // the untruncated value instead. This exposes more opportunities to; // reuse CC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,Availability,Mask,Mask,29,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:63,Availability,MASK,MASK,63,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:333,Availability,MASK,MASK,333,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:383,Availability,mask,mask,383,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:52,Testability,TEST,TEST,52,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:257,Testability,test,tested,257,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:322,Testability,TEST,TEST,322,"// Check whether an AND with Mask is suitable for a TEST UNDER MASK; // instruction and whether the CC value is descriptive enough to handle; // a comparison of type Opcode between the AND result and CmpVal.; // CCMask says which comparison result is being tested and BitSize is; // the number of bits in the operands. If TEST UNDER MASK can be used,; // return the corresponding CC mask, otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Availability,mask,mask,21,"// Check whether the mask is suitable for TMHH, TMHL, TMLH or TMLL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:16,Availability,mask,masks,16,// Work out the masks for the lowest and highest bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:43,Availability,mask,mask,43,"// Check for equality comparisons with the mask, or the equivalent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:52,Availability,MASK,MASK,52,// See whether C can be implemented as a TEST UNDER MASK instruction.; // Update the arguments with the TM version if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:74,Deployability,Update,Update,74,// See whether C can be implemented as a TEST UNDER MASK instruction.; // Update the arguments with the TM version if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:41,Testability,TEST,TEST,41,// See whether C can be implemented as a TEST UNDER MASK instruction.; // Update the arguments with the TM version if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:25,Availability,MASK,MASK,25,// Use VECTOR TEST UNDER MASK for i128 operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Testability,TEST,TEST,14,// Use VECTOR TEST UNDER MASK for i128 operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:65,Availability,mask,mask,65,// Check whether the nonconstant input is an AND with a constant mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:75,Availability,mask,masked,75,// If the low N bits of Op1 are zero than the low N bits of Op0 can; // be masked off without changing the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:36,Availability,mask,mask,36,"// Check whether the combination of mask, comparison value and comparison; // type are suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,Availability,redundant,redundant,50,// See whether the comparison argument contains a redundant AND; // and remove it if so. This sometimes happens due to the generic; // BRCOND expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,Safety,redund,redundant,50,// See whether the comparison argument contains a redundant AND; // and remove it if so. This sometimes happens due to the generic; // BRCOND expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Testability,test,tests,28,// Return a Comparison that tests the condition-code result of intrinsic; // node Call against constant integer CC using comparison code Cond.; // Opcode is the opcode of the SystemZISD operation for the intrinsic; // and CCValid is the set of possible condition-code results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:58,Testability,test,tests,58,// Choose the type of comparison. Equality and inequality tests can; // use either signed or unsigned comparisons. The choice also doesn't; // matter if both sign bits are known to be clear. In those cases we; // want to give the main isel code the freedom to choose whichever; // form fits best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:184,Usability,clear,clear,184,// Choose the type of comparison. Equality and inequality tests can; // use either signed or unsigned comparisons. The choice also doesn't; // matter if both sign bits are known to be clear. In those cases we; // want to give the main isel code the freedom to choose whichever; // form fits best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Modifiability,extend,extending,45,// Implement a 32-bit *MUL_LOHI operation by extending both operands to; // 64 bits. Extend is the extension type to use. Store the high part; // in Hi and the low part in Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:85,Modifiability,Extend,Extend,85,// Implement a 32-bit *MUL_LOHI operation by extending both operands to; // 64 bits. Extend is the extension type to use. Store the high part; // in Hi and the low part in Lo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:161,Performance,perform,performs,161,"// Lower a binary operation that produces two VT results, one in each; // half of a GR128 pair. Op0 and Op1 are the VT operands to the operation,; // and Opcode performs the GR128 operation. Store the even register result; // in Even and the odd register result in Odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:81,Availability,mask,mask,81,"// Return an i32 value that is 1 if the CC value produced by CCReg is; // in the mask CCMask and 0 otherwise. CC is known to have a value; // in CCValid, so other values can be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:36,Modifiability,extend,extended,36,"// Return a v2f64 that contains the extended form of elements Start and Start+1; // of v4f32 value Op. If Chain is nonnull, return the strict form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:73,Modifiability,enhance,enhancements,73,"// There is no hardware support for v4f32 (unless we have the vector; // enhancements facility 1), so extend the vector into two v2f64s; // and compare those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:102,Modifiability,extend,extend,102,"// There is no hardware support for v4f32 (unless we have the vector; // enhancements facility 1), so extend the vector into two v2f64s; // and compare those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:92,Availability,mask,mask,92,"// Lower a vector comparison of type CC between CmpOp0 and CmpOp1, producing; // an integer mask of type VT. If Chain is nonnull, we have a strict; // floating-point comparison. If in addition IsSignaling is true, we have; // a strict signaling floating-point comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Testability,test,tests,10,// Handle tests for order using (or (ogt y x) (oge x y)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:13,Testability,test,tests,13,// Handle <> tests using (or (ogt y x) (ogt x y)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:111,Modifiability,extend,extended,111,"// Check for absolute and negative-absolute selections, including those; // where the comparison value is sign-extended (for LPGFR and LNGFR).; // This check supplements the one in DAGCombiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Performance,load,load,18,// Conservatively load a constant offset greater than 32 bits into a; // register below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Security,access,access,45,// The high part of the thread pointer is in access register 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Security,access,access,44,// The low part of the thread pointer is in access register 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load the GOT offset of the tls_index (module ID / per-symbol offset).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load the GOT offset of the module ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:46,Availability,redundant,redundant,46,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:46,Safety,redund,redundant,46,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:140,Security,access,accesses,140,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Load,Load,3,// Load the offset from the GOT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:47,Performance,load,load,47,// Force the offset into the constant pool and load it from there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Performance,load,load,15,// Use LARL to load the address of the table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Performance,load,load,15,// Use LARL to load the address of the constant pool entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,Safety,detect,detect,29,// FIXME The frontend should detect this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,Safety,detect,detect,29,// FIXME The frontend should detect this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:11,Performance,load,loads,11,"// Convert loads directly. This is normally done by DAGCombiner,; // but we need this case for bitcasts that are created during lowering; // and which are then lowered themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update the chain uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform a CopyFromReg from %GPR4 (stack pointer register). Chain and Glue; // to end of call in order to ensure it isn't broken up from the call; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,Energy Efficiency,allocate,allocated,7,"// The allocated data lives above the 160 bytes allocated for the standard; // frame, plus any outgoing stack arguments. We don't know how much that; // amounts to yet, so emit a special ADJDYNALLOC placeholder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Energy Efficiency,allocate,allocated,48,"// The allocated data lives above the 160 bytes allocated for the standard; // frame, plus any outgoing stack arguments. We don't know how much that; // amounts to yet, so emit a special ADJDYNALLOC placeholder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:174,Performance,perform,performance,174,"// We use DSGF for 32-bit division. This means the first operand must; // always be 64-bit, and the second operand should be 32-bit whenever; // that is possible, to improve performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Availability,mask,masks,22,// Get the known-zero masks for each operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:91,Availability,mask,masks,91,// Check whether the high part is an AND that doesn't change the; // high 32 bits and just masks out low bits. We can skip it if so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Availability,mask,mask,22,// Get the known-zero mask for the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:19,Performance,load,load,19,// Op is an atomic load. Lower it into a normal volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:57,Performance,load,load,57,// Op is an atomic load. Lower it into a normal volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,perform,performing,48,// We have to enforce sequential consistency by performing a; // serialization operation after the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Extend,Extend,3,"// Extend the source operand to 32 bits and prepare it for the inner loop.; // ATOMIC_SWAPW uses RISBG to rotate the field left, but all other; // operations require the source to be shifted in advance. (This shift; // can be folded if the source is constant.) For AND and NAND, the lower; // bits must be set, while for other opcodes they should be left clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:355,Usability,clear,clear,355,"// Extend the source operand to 32 bits and prepare it for the inner loop.; // ATOMIC_SWAPW uses RISBG to rotate the field left, but all other; // operations require the source to be shifted in advance. (This shift; // can be folded if the source is constant.) For AND and NAND, the lower; // bits must be set, while for other opcodes they should be left clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:34,Modifiability,extend,extend,34,// emitAtomicCmpSwapW() will zero extend the result (original value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:186,Deployability,update,updated,186,"// Because of how we convert atomic_load and atomic_store to normal loads and; // stores in the DAG, we need to ensure that the MMOs are marked volatile; // since DAGCombine hasn't been updated to account for atomic, but non; // volatile loads. (See D57601)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:68,Performance,load,loads,68,"// Because of how we convert atomic_load and atomic_store to normal loads and; // stores in the DAG, we need to ensure that the MMOs are marked volatile; // since DAGCombine hasn't been updated to account for atomic, but non; // volatile loads. (See D57601)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:238,Performance,load,loads,238,"// Because of how we convert atomic_load and atomic_store to normal loads and; // stores in the DAG, we need to ensure that the MMOs are marked volatile; // since DAGCombine hasn't been updated to account for atomic, but non; // volatile loads. (See D57601)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:56,Performance,perform,perform,56,"// Says that SystemZISD operation Opcode can be used to perform the equivalent; // of a VPERM with permute vector Bytes. If Opcode takes three operands,; // Operand is the constant third operand, otherwise it is the number of; // bytes in each element of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Availability,mask,mask,15,"// Convert the mask of the given shuffle op into a byte-level mask,; // as if it had type vNi8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,Availability,mask,mask,62,"// Convert the mask of the given shuffle op into a byte-level mask,; // as if it had type vNi8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:114,Performance,perform,performed,114,"// Bytes is a VPERM-like permute vector, except that -1 is used for; // undefined bytes. Return true if it can be performed using VSLDB.; // When returning true, set StartIndex to the shift amount and OpNo0; // and OpNo1 to the VPERM operands that should be used as the first; // and second shift operand respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Performance,perform,performs,22,"// Create a node that performs P on operands Op0 and Op1, casting the; // operands to the appropriate type. The type of the result is determined by P.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:34,Availability,mask,mask,34,"// If the first byte is zero, use mask as first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:6,Availability,mask,mask,6,"// If mask contains a zero, use it by placing that vector first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:414,Modifiability,extend,extended,414,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:449,Performance,optimiz,optimized,449,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:251,Safety,Abort,Aborts,251,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:12,Availability,mask,mask,12,// Create a mask for just these two operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,Safety,avoid,avoid,54,// See if it would be better to reorganize NewMask to avoid using VPERM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,Energy Efficiency,reduce,reduces,44,"// Only do this if removing the zero vector reduces the depth, otherwise; // the critical path will increase with the final unpack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend GPR scalars Op0 and Op1 to doublewords and return a v2i64; // vector for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:87,Safety,avoid,avoid,87,"// If one of the two inputs is undefined then replicate the other one,; // in order to avoid using another register unnecessarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:74,Performance,load,loaded,74,"// There are three cases here:; //; // - if the only defined element is a loaded one, the best sequence; // is a replicating load.; //; // - otherwise, if the only defined element is an i64 value, we will; // end up with the same VLVGP sequence regardless of whether we short-cut; // for replication or fall through to the later code.; //; // - otherwise, if the only defined element is an i32 or smaller value,; // we would need 2 instructions to replicate it: VLVGP followed by VREPx.; // This is only a win if the single defined element is used more than once.; // In other cases we're better off using a single VLVGx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:125,Performance,load,load,125,"// There are three cases here:; //; // - if the only defined element is a loaded one, the best sequence; // is a replicating load.; //; // - otherwise, if the only defined element is an i64 value, we will; // end up with the same VLVGP sequence regardless of whether we short-cut; // for replication or fall through to the later code.; //; // - otherwise, if the only defined element is an i32 or smaller value,; // we would need 2 instructions to replicate it: VLVGP followed by VREPx.; // This is only a win if the single defined element is used more than once.; // In other cases we're better off using a single VLVGx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Performance,load,loads,23,"// If all elements are loads, use VLREP/VLEs (below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid unnecessary undefs by reusing the other operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:91,Integrability,depend,dependency,91,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:200,Performance,load,load,200,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:237,Performance,load,load,237,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:77,Safety,avoid,avoid,77,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:16,Performance,load,loading,16,// Fall back to loading it from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Detect,Detect,3,// Detect SCALAR_TO_VECTOR conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:53,Availability,avail,available,53,// See whether the value we're splatting is directly available as a scalar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:13,Modifiability,variab,variable,13,// Check for variable splats.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:111,Availability,avail,available,111,"// See whether the shift vector is a splat represented as SHUFFLE_VECTOR,; // and the shift amount is directly available in a GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:48,Performance,perform,performing,48,// We have to enforce sequential consistency by performing a; // serialization operation after the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Usability,simpl,simplify,10,// Try to simplify an EXTRACT_VECTOR_ELT from a vector of type VecVT; // producing a result of type ResVT. Op is a possibly bitcast version; // of the input vector and Index is the index (based on type VecVT) that; // should be extracted. Return the new extraction if a simplification; // was possible or if Force is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:270,Usability,simpl,simplification,270,// Try to simplify an EXTRACT_VECTOR_ELT from a vector of type VecVT; // producing a result of type ResVT. Op is a possibly bitcast version; // of the input vector and Index is the index (based on type VecVT) that; // should be extracted. Return the new extraction if a simplification; // was possible or if Force is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Availability,mask,mask,28,// Get a VPERM-like permute mask and see whether the bytes covered; // by the extracted element are a contiguous sequence from one; // source operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Performance,optimiz,optimize,15,// We can only optimize this case if the BUILD_VECTOR elements are; // at least as wide as the extracted value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize vector operations in scalar value Op on the basis that Op; // is truncated to TruncVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:90,Performance,optimiz,optimize,90,"// Defer the creation of the bitcast from X to combineExtract,; // which might be able to optimize the extraction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:19,Performance,load,load,19,// Replace an i128 load that is used solely to move its value into GPRs; // by separate loads of both halves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:88,Performance,load,loads,88,// Replace an i128 load that is used solely to move its value into GPRs; // by separate loads of both halves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each extraction as an independent load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Performance,load,load,45,// Rewrite each extraction as an independent load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Performance,load,load,22,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:174,Performance,load,load,174,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:308,Performance,load,loads,308,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:242,Safety,Avoid,Avoid,242,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update uses of the loaded Value while preserving old chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:22,Performance,load,loaded,22,// Update uses of the loaded Value while preserving old chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the store with the new form of stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:194,Modifiability,extend,extend,194,"// Replicate a reg or immediate with VREP instead of scalar multiply or; // immediate load. It seems best to do this during the first DAGCombine as; // it is straight-forward to handle the zero-extend node in the initial; // DAG, and also not worry about the keeping the new MemVT legal (e.g. when; // extracting an i16 element from a v16i8 vector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:86,Performance,load,load,86,"// Replicate a reg or immediate with VREP instead of scalar multiply or; // immediate load. It seems best to do this during the first DAGCombine as; // it is straight-forward to handle the zero-extend node in the initial; // DAG, and also not worry about the keeping the new MemVT legal (e.g. when; // extracting an i16 element from a v16i8 vector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:15,Modifiability,extend,extended,15,// Find a zero extended value and its type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:25,Performance,LOAD,LOAD,25,// Combine element-swap (LOAD) into VLER,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:31,Performance,load,load,31,// Create the element-swapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:84,Performance,load,load,84,"// First, combine the VECTOR_SHUFFLE away. This makes the value produced; // by the load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Performance,load,load,21,"// Next, combine the load away, we give it a bogus result value but a real; // chain result. The result value is dead because the shuffle is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Usability,simpl,simplify,10,// Try to simplify a vector extraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:51,Safety,avoid,avoid,51,"// Insert an extension before type-legalization to avoid scalarization, e.g.:; // v2f64 = uint_to_fp v2i16; // =>; // v2f64 = uint_to_fp (v2i64 zero_extend v2i16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:18,Performance,LOAD,LOAD,18,// Combine BSWAP (LOAD) into LRVH/LRV/LRVG/VLBR,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Performance,load,load,28,// Create the byte-swapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Performance,load,load,21,"// If this is an i16 load, insert the truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:75,Performance,load,load,75,"// First, combine the bswap away. This makes the value produced by the; // load dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:21,Performance,load,load,21,"// Next, combine the load away, we give it a bogus result value but a real; // chain result. The result value is dead because the bswap is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:64,Usability,simpl,simplifies,64,// Push BSWAP into a vector insertion if at least one side then simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,Usability,simpl,simplifies,62,// Push BSWAP into a vector shuffle if at least one side then simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:129,Availability,mask,masks,129,"// We have a SELECT_CCMASK or BR_CCMASK comparing the condition code; // set by the CCReg instruction using the CCValid / CCMask masks,; // If the CCReg instruction is itself a ICMP testing the condition; // code set by some other instruction, see whether we can directly; // use that condition code.; // Verify that we have an ICMP against some constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:182,Testability,test,testing,182,"// We have a SELECT_CCMASK or BR_CCMASK comparing the condition code; // set by the CCReg instruction using the CCValid / CCMask masks,; // If the CCReg instruction is itself a ICMP testing the condition; // code set by some other instruction, see whether we can directly; // use that condition code.; // Verify that we have an ICMP against some constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the case where CompareLHS is a SELECT_CCMASK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,Availability,mask,mask,38,// Verify that we have an appropriate mask for a EQ or NE comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Availability,mask,mask,28,// Compute the effective CC mask for the new branch or select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Deployability,update,updated,14,// Return the updated CCReg link.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the case where CompareRHS is (SRA (SHL (IPM))).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid introducing CC spills (because SRA would clobber CC).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:28,Availability,mask,mask,28,// Compute the effective CC mask for the new branch or select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Deployability,update,updated,14,// Return the updated CCReg link.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,Availability,mask,masks,54,// Optimize away GET_CCMASK (SELECT_CCMASK) if the CC masks are compatible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Optimiz,Optimize,3,// Optimize away GET_CCMASK (SELECT_CCMASK) if the CC masks are compatible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,Performance,LOAD,LOAD,10,// VECTOR LOAD (RIGHTMOST) WITH LENGTH with a length operand of 15; // or larger is simply a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:100,Performance,load,load,100,// VECTOR LOAD (RIGHTMOST) WITH LENGTH with a length operand of 15; // or larger is simply a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:84,Usability,simpl,simply,84,// VECTOR LOAD (RIGHTMOST) WITH LENGTH with a length operand of 15; // or larger is simply a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Modifiability,extend,extends,17,// VECTOR UNPACK extends half the elements of the source vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL HIGH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL LOW,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Availability,mask,mask,45,"// Demand input element 0 or 1, given by the mask bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL HIGH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:17,Testability,LOG,LOGICAL,17,// VECTOR UNPACK LOGICAL LOW,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:14,Modifiability,extend,extends,14,// VREPI sign extends the immedate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:9,Availability,down,down,9,// Round down to the stack alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:27,Deployability,update,update,27,// Should have kill-flag - update below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:23,Modifiability,rewrite,rewrite,23,// Add this PHI to the rewrite table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:244,Availability,avail,available,244,"// Implement EmitInstrWithCustomInserter for pseudo CondStore* instruction MI.; // StoreOpcode is the store to use and Invert says whether the store should; // happen when the condition is false rather than true. If a STORE ON; // CONDITION is available, STOCOpcode is its opcode, otherwise it is 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:37,Performance,load,load,37,"// ISel pattern matching also adds a load memory operand of the same; // address, so take special care to find the storing memory operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:128,Performance,perform,performance,128,"// Use STOCOpcode if possible. We could use different store patterns in; // order to avoid matching the index register, but the performance trade-offs; // might be more complicated in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:85,Safety,avoid,avoid,85,"// Use STOCOpcode if possible. We could use different store patterns in; // order to avoid matching the index register, but the performance trade-offs; // might be more complicated in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:49,Testability,LOG,LOGICAL,49,"// StartMBB:; //; // Use VECTOR ELEMENT COMPARE [LOGICAL] to compare the high parts.; // Swap the inputs to get:; // CC 1 if high(Op0) > high(Op1); // CC 2 if high(Op0) < high(Op1); // CC 0 if high(Op0) == high(Op1); //; // If CC != 0, we'd done, so jump over the next instruction.; //; // VEC[L]G Op1, Op0; // JNE JoinMBB; // # fallthrough to HiEqMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:144,Integrability,depend,depend,144,"// HiEqMBB:; //; // Otherwise, use VECTOR COMPARE HIGH LOGICAL.; // Since we already know the high parts are equal, the CC; // result will only depend on the low parts:; // CC 1 if low(Op0) > low(Op1); // CC 3 if low(Op0) <= low(Op1); //; // VCHLGS Tmp, Op0, Op1; // # fallthrough to JoinMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:55,Testability,LOG,LOGICAL,55,"// HiEqMBB:; //; // Otherwise, use VECTOR COMPARE HIGH LOGICAL.; // Since we already know the high parts are equal, the CC; // result will only depend on the low parts:; // CC 1 if low(Op0) > low(Op1); // CC 3 if low(Op0) <= low(Op1); //; // VCHLGS Tmp, Op0, Op1; // # fallthrough to JoinMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:145,Performance,perform,performs,145,"// Implement EmitInstrWithCustomInserter for subword pseudo ATOMIC_LOADW_* or; // ATOMIC_SWAPW instruction MI. BinOpcode is the instruction that performs; // the binary operation elided by ""*"", or 0 for ATOMIC_SWAPW. Invert says; // whether the field should be inverted after performing BinOpcode (e.g. for; // NAND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:276,Performance,perform,performing,276,"// Implement EmitInstrWithCustomInserter for subword pseudo ATOMIC_LOADW_* or; // ATOMIC_SWAPW instruction MI. BinOpcode is the instruction that performs; // the binary operation elided by ""*"", or 0 for ATOMIC_SWAPW. Invert says; // whether the field should be inverted after performing BinOpcode (e.g. for; // NAND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the operation normally and then invert every bit of the field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:5,Usability,simpl,simply,5,// A simply binary operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:270,Availability,mask,mask,270,"// Implement EmitInstrWithCustomInserter for subword pseudo; // ATOMIC_LOADW_{,U}{MIN,MAX} instruction MI. CompareOpcode is the; // instruction that should be used to compare the current field with the; // minimum or maximum value. KeepOldMask is the BRC condition-code mask; // for when the current field should be kept.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:63,Deployability,Update,UpdateMBB,63,"// LoopMBB:; // %OldVal = phi [ %OrigVal, StartMBB ], [ %Dest, UpdateMBB ]; // %RotatedOldVal = RLL %OldVal, 0(%BitShift); // CompareOpcode %RotatedOldVal, %Src2; // BRC KeepOldMask, UpdateMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:183,Deployability,Update,UpdateMBB,183,"// LoopMBB:; // %OldVal = phi [ %OrigVal, StartMBB ], [ %Dest, UpdateMBB ]; // %RotatedOldVal = RLL %OldVal, 0(%BitShift); // CompareOpcode %RotatedOldVal, %Src2; // BRC KeepOldMask, UpdateMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:106,Deployability,Update,UpdateMBB,106,"// UseAltMBB:; // %RotatedAltVal = RISBG %RotatedOldVal, %Src2, 32, 31 + BitSize, 0; // # fall through to UpdateMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,UpdateMBB,3,"// UpdateMBB:; // %RotatedNewVal = PHI [ %RotatedOldVal, LoopMBB ],; // [ %RotatedAltVal, UseAltMBB ]; // %NewVal = RLL %RotatedNewVal, 0(%NegBitShift); // %Dest = CS %OldVal, %NewVal, Disp(%Base); // JNE LoopMBB; // # fall through to DoneMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:415,Performance,load,loaded,415,"// LoopMBB:; // %OldVal = phi [ %OrigOldVal, EntryBB ], [ %RetryOldVal, SetMBB ]; // %SwapVal = phi [ %OrigSwapVal, EntryBB ], [ %RetrySwapVal, SetMBB ]; // %OldValRot = RLL %OldVal, BitSize(%BitShift); // ^^ The low BitSize bits contain the field; // of interest.; // %RetrySwapVal = RISBG32 %SwapVal, %OldValRot, 32, 63-BitSize, 0; // ^^ Replace the upper 32-BitSize bits of the; // swap value with those that we loaded and rotated.; // %Dest = LL[CH] %OldValRot; // CR %Dest, %CmpVal; // JNE DoneMBB; // # Fall through to SetMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,Usability,Clear,ClearEven,45,"// Emit an extension from a GR64 to a GR128. ClearEven is true; // if the high register of the GR128 value must be cleared or false if; // it's ""don't care"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:115,Usability,clear,cleared,115,"// Emit an extension from a GR64 to a GR128. ClearEven is true; // if the high register of the GR128 value must be cleared or false if; // it's ""don't care"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:353,Performance,optimiz,optimize,353,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:426,Safety,avoid,avoid,426,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:446,Safety,predict,prediction,446,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:27,Usability,clear,clear,27,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:71,Performance,perform,performs,71,// Decompose string pseudo-instruction MI into a loop that continually performs; // Opcode until CC != 3.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:287,Performance,load,load,287,"// LoopMBB:; // %This1Reg = phi [ %Start1Reg, StartMBB ], [ %End1Reg, LoopMBB ]; // %This2Reg = phi [ %Start2Reg, StartMBB ], [ %End2Reg, LoopMBB ]; // R0L = %CharReg; // %End1Reg, %End2Reg = CLST %This1Reg, %This2Reg -- uses R0L; // JO LoopMBB; // # fall through to DoneMBB; //; // The load of R0L can be hoisted by post-RA LICM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update TBEGIN instruction with final opcode and register clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Deployability,Update,Update,3,// Update opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:32,Performance,load,load-and-test,32,// Replace pseudo with a normal load-and-test that models the def as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:41,Testability,test,test,41,// Replace pseudo with a normal load-and-test that models the def as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:16,Energy Efficiency,Allocate,Allocate,16,// LoopBodyMBB: Allocate and probe by means of a volatile compare.; // J LoopTestMBB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:33,Energy Efficiency,schedul,schedulers,33,"// This is only used by the isel schedulers, and is needed only to prevent; // compiler from crashing when list-ilp is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:53,Integrability,interface,interface,53,"//===-- SystemZISelLowering.h - SystemZ DAG lowering interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SystemZ uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- SystemZISelLowering.h - SystemZ DAG lowering interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that SystemZ uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Integrability,Wrap,Wraps,3,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:46,Performance,load,loaded,46,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:75,Security,access,accesses,75,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:14,Availability,mask,mask,14,// Test under mask. The first operand is ANDed with the second operand; // and the condition codes are set on the result. The third operand is; // a boolean that is true if the condition codes need to distinguish; // between CCMASK_TM_MIXED_MSB_0 and CCMASK_TM_MIXED_MSB_1 (which the; // register forms do but the memory forms don't).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Testability,Test,Test,3,// Test under mask. The first operand is ANDed with the second operand; // and the condition codes are set on the result. The third operand is; // a boolean that is true if the condition codes need to distinguish; // between CCMASK_TM_MIXED_MSB_0 and CCMASK_TM_MIXED_MSB_1 (which the; // register forms do but the memory forms don't).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:110,Availability,mask,mask,110,"// Branches if a condition is true. Operand 0 is the chain operand;; // operand 1 is the 4-bit condition-code mask, with bit N in; // big-endian order meaning ""branch if CC=N""; operand 2 is the; // target block and operand 3 is the flag operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:65,Availability,mask,mask,65,// Selects between operand 0 and operand 1. Operand 2 is the; // mask of condition-code values for which operand 0 should be; // chosen over operand 1; it has the same form as BR_CCMASK.; // Operand 3 is the flag operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:82,Performance,perform,performed,82,"// For allocating stack space when using stack clash protector.; // Allocation is performed by block, and each block is probed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Integrability,Wrap,Wrappers,3,"// Wrappers around the ISD opcodes of the same name. The output is GR128.; // Input operands may be GR64 or GR32, depending on the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:114,Integrability,depend,depending,114,"// Wrappers around the ISD opcodes of the same name. The output is GR128.; // Input operands may be GR64 or GR32, depending on the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:80,Availability,mask,mask,80,"// Set the condition code from a boolean value in operand 0.; // Operand 1 is a mask of all condition-code values that may result of this; // operation, operand 2 is a mask of condition-code values that may result; // if the boolean is true.; // Note that this operation is always optimized away, we will never; // generate any code for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:168,Availability,mask,mask,168,"// Set the condition code from a boolean value in operand 0.; // Operand 1 is a mask of all condition-code values that may result of this; // operation, operand 2 is a mask of condition-code values that may result; // if the boolean is true.; // Note that this operation is always optimized away, we will never; // generate any code for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:281,Performance,optimiz,optimized,281,"// Set the condition code from a boolean value in operand 0.; // Operand 1 is a mask of all condition-code values that may result of this; // operation, operand 2 is a mask of condition-code values that may result; // if the boolean is true.; // Note that this operation is always optimized away, we will never; // generate any code for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:27,Testability,log,logic,27,"// Similar to MVC, but for logic operations (AND, OR, XOR).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:215,Availability,failure,failure,215,"// Use an SRST-based sequence to search a block of memory. The first; // operand is the end address, the second is the start, and the third; // is the character to search for. CC is set to 1 on success and 2; // on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:72,Availability,mask,mask,72,// Create a vector constant by replicating an element-sized RISBG-style mask.; // The first operand specifies the starting set bit and the second operand; // specifies the ending set bit. Both operands count from the MSB of the; // element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:189,Availability,mask,mask,189,"// Perform a general vector permute on vector operands 0 and 1.; // Each byte of operand 2 controls the corresponding byte of the result,; // in the same way as a byte-level VECTOR_SHUFFLE mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Performance,Perform,Perform,3,"// Perform a general vector permute on vector operands 0 and 1.; // Each byte of operand 2 controls the corresponding byte of the result,; // in the same way as a byte-level VECTOR_SHUFFLE mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:94,Modifiability,extend,extends,94,// Unpack the first half of vector operand 0 into double-sized elements.; // UNPACK_HIGH sign-extends and UNPACKL_HIGH zero-extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:124,Modifiability,extend,extends,124,// Unpack the first half of vector operand 0 into double-sized elements.; // UNPACK_HIGH sign-extends and UNPACKL_HIGH zero-extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Testability,Test,Test,3,// Test floating-point data class for vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Modifiability,Extend,Extend,3,// Extend the even f32 elements of vector operand 0 to produce a vector; // of f64 elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:80,Availability,mask,mask,80,// Test Data Class.; //; // Operand 0: the value to test; // Operand 1: the bit mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Testability,Test,Test,3,// Test Data Class.; //; // Operand 0: the value to test; // Operand 1: the bit mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:52,Testability,test,test,52,// Test Data Class.; //; // Operand 0: the value to test; // Operand 1: the bit mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:29,Integrability,Wrap,Wraps,29,// z/OS XPLINK ADA Entry; // Wraps a TargetGlobalAddress that should be loaded from a function's; // AssociatedData Area (ADA). Tha ADA is passed to the function by the; // caller in the XPLink ABI defined register R5.; // Operand 0: the GlobalValue/External Symbol; // Operand 1: the ADA register; // Operand 2: the offset (0 for the first and 8 for the second element in the; // function descriptor),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:72,Performance,load,loaded,72,// z/OS XPLINK ADA Entry; // Wraps a TargetGlobalAddress that should be loaded from a function's; // AssociatedData Area (ADA). Tha ADA is passed to the function by the; // caller in the XPLink ABI defined register R5.; // Operand 0: the GlobalValue/External Symbol; // Operand 1: the ADA register; // Operand 2: the offset (0 for the first and 8 for the second element in the; // function descriptor),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:3,Integrability,Wrap,Wrappers,3,"// Wrappers around the inner loop of an 8- or 16-bit ATOMIC_SWAP or; // ATOMIC_LOAD_<op>.; //; // Operand 0: the address of the containing 32-bit-aligned field; // Operand 1: the second operand of <op>, in the high bits of an i32; // for everything except ATOMIC_SWAPW; // Operand 2: how many bits to rotate the i32 left to bring the first; // operand into the high bits; // Operand 3: the negative of operand 2, for rotating the other way; // Operand 4: the width of the field in bits (8 or 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:5,Integrability,wrap,wrapper,5,"// A wrapper around the inner loop of an ATOMIC_CMP_SWAP.; //; // Operand 0: the address of the containing 32-bit-aligned field; // Operand 1: the compare value, in the low bits of an i32; // Operand 2: the swap value, in the low bits of an i32; // Operand 3: how many bits to rotate the i32 left to bring the first; // operand into the high bits; // Operand 4: the negative of operand 2, for rotating the other way; // Operand 5: the width of the field in bits (8 or 16)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:18,Performance,load,load,18,"// 128-bit atomic load.; // Val, OUTCHAIN = ATOMIC_LOAD_128(INCHAIN, ptr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:17,Performance,load,load,17,// Byte swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:54,Performance,load,load,54,// Byte swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:20,Performance,load,load,20,// Element swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:57,Performance,load,load,57,// Element swapping load/store. Same operands as regular load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:111,Performance,load,load,111,// Prefetch from the second operand using the 4-bit control code in; // the first operand. The code is 1 for a load prefetch and 2 for; // a store prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:364,Energy Efficiency,efficient,efficient,364,"// Widen subvectors to the full width rather than promoting integer; // elements. This is better because:; //; // (a) it means that we can handle the ABI for passing and returning; // sub-128 vectors without having to handle them as legal types.; //; // (b) we don't have instructions to extend on load and truncate on store,; // so promoting the integers is less efficient.; //; // (c) there are no multiplication instructions for the widest integer; // type (v2i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:288,Modifiability,extend,extend,288,"// Widen subvectors to the full width rather than promoting integer; // elements. This is better because:; //; // (a) it means that we can handle the ABI for passing and returning; // sub-128 vectors without having to handle them as legal types.; //; // (b) we don't have instructions to extend on load and truncate on store,; // so promoting the integers is less efficient.; //; // (c) there are no multiplication instructions for the widest integer; // type (v2i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:298,Performance,load,load,298,"// Widen subvectors to the full width rather than promoting integer; // elements. This is better because:; //; // (a) it means that we can handle the ABI for passing and returning; // sub-128 vectors without having to handle them as legal types.; //; // (b) we don't have instructions to extend on load and truncate on store,; // so promoting the integers is less efficient.; //; // (c) there are no multiplication instructions for the widest integer; // type (v2i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:47,Performance,load,loading,47,/// Override to support customized stack guard loading.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:45,Availability,Mask,Mask,45,/// Determine which of the bits specified in Mask are known to be either; /// zero or one and return them in the KnownZero/KnownOne bitsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:441,Modifiability,variab,variables,441,"//===-- SystemZLDCleanup.cpp - Clean up local-dynamic TLS accesses --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines multiple accesses to local-dynamic TLS variables so that; // the TLS base address for the module is only fetched once per execution path; // through the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:58,Security,access,accesses,58,"//===-- SystemZLDCleanup.cpp - Clean up local-dynamic TLS accesses --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines multiple accesses to local-dynamic TLS variables so that; // the TLS base address for the module is only fetched once per execution path; // through the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:411,Security,access,accesses,411,"//===-- SystemZLDCleanup.cpp - Clean up local-dynamic TLS accesses --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass combines multiple accesses to local-dynamic TLS variables so that; // the TLS base address for the module is only fetched once per execution path; // through the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp:20,Security,access,accesses,20,// No point folding accesses if there isn't at least two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLDCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:674,Usability,simpl,simple,674,"//===-- SystemZLongBranch.cpp - Branch lengthening for SystemZ ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass makes sure that all branches are in range. There are several ways; // in which this could be done. One aggressive approach is to assume that all; // branches are in range and successively replace those that turn out not; // to be in range with a longer form (branch relaxation). A simple; // implementation is to continually walk through the function relaxing; // branches until no more changes are needed and a fixed point is reached.; // However, in the pathological worst case, this implementation is; // quadratic in the number of blocks; relaxing branch N can make branch N-1; // go out of range, which in turn can make branch N-2 go out of range,; // and so on.; //; // An alternative approach is to assume that all branches must be; // converted to their long forms, then reinstate the short forms of; // branches that, even under this pessimistic assumption, turn out to be; // in range (branch shortening). This too can be implemented as a function; // walk that is repeated until a fixed point is reached. In general,; // the result of shortening is not as good as that of relaxation, and; // shortening is also quadratic in the worst case; shortening branch N; // can bring branch N-1 in range of the short form, which in turn can do; // the same for branch N-2, and so on. The main advantage of shortening; // is that each walk through the function produces valid code, so it is; // possible to stop at any point after the first walk. The quadraticness; // could therefore be handled with a maximum pass count, although the; // question then becomes: what maximum count should be used?; //; // On",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:58,Deployability,Update,Update,58,// Position describes the state immediately before Block. Update Block; // accordingly and move Position to the end of the block's non-terminator; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:67,Deployability,Update,Update,67,// Position describes the state immediately before Terminator.; // Update Terminator accordingly and move Position past it.; // Assume that Terminator will be relaxed if AssumeRelaxed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:35,Security,access,access,35,"// Record the alignment, for quick access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineFunctionInfo.h:50,Modifiability,variab,variable,50,// Get and set the number of fixed (as opposed to variable) arguments; // that are passed in GPRs to this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:581,Availability,Avail,Available,581,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:43,Energy Efficiency,Schedul,Scheduler,43,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:418,Energy Efficiency,schedul,scheduling,418,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:497,Energy Efficiency,schedul,scheduling,497,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:728,Energy Efficiency,Schedul,Scheduler,728,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:53,Integrability,Interface,Interface,53,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:652,Performance,optimiz,optimize,652,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:821,Usability,learn,learn,821,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:74,Energy Efficiency,schedul,scheduler,74,// Try to find a single predecessor that would be interesting for the; // scheduler in the top-most region of MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:13,Safety,Hazard,HazardRec,13,"/// Create a HazardRec for MBB, save it in SchedStates and set HazardRec to; /// point to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:63,Safety,Hazard,HazardRec,63,"/// Create a HazardRec for MBB, save it in SchedStates and set HazardRec to; /// point to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:76,Energy Efficiency,schedul,scheduled,76,"// Try to take over the state from a single predecessor, if it has been; // scheduled. If this is not possible, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:73,Safety,predict,prediction,73,"// Emit incoming terminator(s). Be optimistic and assume that branch; // prediction will generally do ""the right thing"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:80,Integrability,depend,dependent,80,// Advance to first terminator. The successor block will handle terminators; // dependent on CFG layout (T/NT branch etc).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:10,Safety,hazard,hazard,10,// Delete hazard recognizers kept around for each MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:25,Energy Efficiency,schedul,schedule,25,// Pick the next node to schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:23,Availability,down,down,23,// Only scheduling top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:8,Energy Efficiency,schedul,scheduling,8,// Only scheduling top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:61,Availability,Avail,Available,61,// All nodes that are possible to schedule are stored in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:34,Energy Efficiency,schedul,schedule,34,// All nodes that are possible to schedule are stored in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:171,Energy Efficiency,schedul,schedule,171,"// Check the grouping cost. For a node that must begin / end a; // group, it is positive if it would do so prematurely, or negative; // if it would fit naturally into the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:18,Availability,Avail,Available,18,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:36,Deployability,update,update,36,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:43,Safety,Hazard,HazardRec,43,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:31,Availability,Avail,Available,31,// Put all released SUs in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:11,Deployability,release,released,11,// Put all released SUs in the Available set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:581,Availability,Avail,Available,581,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:42,Energy Efficiency,Schedul,Scheduler,42,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:418,Energy Efficiency,schedul,scheduling,418,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:497,Energy Efficiency,schedul,scheduling,497,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:728,Energy Efficiency,Schedul,Scheduler,728,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:52,Integrability,Interface,Interface,52,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:652,Performance,optimiz,optimize,652,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:821,Usability,learn,learn,821,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:62,Energy Efficiency,schedul,scheduling,62,/// A MachineSchedStrategy implementation for SystemZ post RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:79,Energy Efficiency,schedul,scheduled,79,"// A SchedModel is needed before any DAG is built while advancing past; // non-scheduled instructions, so it would not always be possible to call; // DAG->getSchedClass(SU).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:20,Availability,Avail,Available,20,// A sorter for the Available set that makes sure that SUs are considered; // in the best order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:15,Availability,avail,available,15,/// The set of available SUs to schedule next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:32,Energy Efficiency,schedul,schedule,32,/// The set of available SUs to schedule next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:60,Energy Efficiency,schedul,scheduler,60,"/// Maintain hazard recognizers for all blocks, so that the scheduler state; /// can be maintained past BB boundaries when appropariate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:13,Safety,hazard,hazard,13,"/// Maintain hazard recognizers for all blocks, so that the scheduler state; /// can be maintained past BB boundaries when appropariate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:52,Energy Efficiency,schedul,scheduler,52,/// Pointer to the HazardRecognizer that tracks the scheduler state for; /// the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:19,Safety,Hazard,HazardRecognizer,19,/// Pointer to the HazardRecognizer that tracks the scheduler state for; /// the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:4,Deployability,Update,Update,4,"/// Update the scheduler state by emitting (non-scheduled) instructions; /// up to, but not including, NextBegin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:15,Energy Efficiency,schedul,scheduler,15,"/// Update the scheduler state by emitting (non-scheduled) instructions; /// up to, but not including, NextBegin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:48,Energy Efficiency,schedul,scheduled,48,"/// Update the scheduler state by emitting (non-scheduled) instructions; /// up to, but not including, NextBegin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:31,Energy Efficiency,schedul,scheduling,31,/// Called for a region before scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:11,Energy Efficiency,schedul,scheduling,11,/// PostRA scheduling does not track pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:34,Availability,down,down,34,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:11,Energy Efficiency,schedul,scheduling,11,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:47,Energy Efficiency,schedul,scheduler,47,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:93,Energy Efficiency,schedul,scheduling,93,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:26,Energy Efficiency,schedul,schedule,26,"/// Pick the next node to schedule, or return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:4,Energy Efficiency,Schedul,ScheduleDAGMI,4,/// ScheduleDAGMI has scheduled an instruction - tell HazardRec; /// about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:22,Energy Efficiency,schedul,scheduled,22,/// ScheduleDAGMI has scheduled an instruction - tell HazardRec; /// about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:54,Safety,Hazard,HazardRec,54,/// ScheduleDAGMI has scheduled an instruction - tell HazardRec; /// about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:71,Availability,Avail,Available,71,/// SU has had all predecessor dependencies resolved. Put it into; /// Available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:31,Integrability,depend,dependencies,31,/// SU has had all predecessor dependencies resolved. Put it into; /// Available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:34,Availability,down,down,34,"/// Currently only scheduling top-down, so this method is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:19,Energy Efficiency,schedul,scheduling,19,"/// Currently only scheduling top-down, so this method is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:36,Modifiability,Rewrite,Rewrite,36,/// Returns an instance of the Post Rewrite pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:11,Performance,load,load-register-on-condition,11,"// MI is a load-register-on-condition pseudo instruction. Replace it with; // LowOpcode if source and destination are both low GR32s and HighOpcode if; // source and destination are both high GR32s. Otherwise, a branch sequence; // is created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:80,Usability,simpl,simplify,80,"// If sources and destination aren't all high or all low, we may be able to; // simplify the operation by moving one of the sources to the destination; // first. But only if this doesn't clobber the other source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:13,Usability,simpl,simplification,13,"// Given the simplification above, we must already have a two-operand case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:42,Performance,perform,performs,42,// Replace MBBI by a branch sequence that performs a conditional move of; // operand 2 to the destination register. Operand 1 is expected to be the; // same register as the destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:49,Availability,avail,available,49,"// Return true to make these hints the only regs available to; // RA. This may mean extra spilling but since the alternative is; // a jump sequence expansion of the LOCRMux, it is preferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:89,Performance,load,load,89,// Create an anchor point that is in range. Start at 0xffff so that; // can use LLILH to load the immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:3,Performance,Load,Load,3,// Load the offset into the scratch register and use it as an index.; // The scratch register then dies here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:3,Performance,Load,Load,3,// Load the anchor address into a scratch register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:3,Performance,Load,Load,3,// Load the high offset into the scratch register and use it as; // an index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:29,Safety,safe,safe,29,// Check if coalescing seems safe by finding the set of clobbered physreg; // pairs in the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h:17,Availability,mask,mask,17,/// \returns the mask of all the call preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:3,Modifiability,Variab,Variable,3,// Variable length,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:32,Modifiability,variab,variable,32,// Handle the special case of a variable length memset of 0 with XC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:224,Usability,clear,clears,224,"// Convert the current CC value into an integer that is 0 if CC == 0,; // greater than zero if CC == 1 and less than zero if CC >= 2.; // The sequence starts with IPM, which puts CC into bits 29 and 28; // of an integer and clears bits 30 and 31.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:36,Integrability,depend,depending,36,"// Now select between End and null, depending on whether the character; // was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:6,Performance,load,loads,6,// MI loads one word of a GPR using an IIxF instruction and LLIxL and LLIxH; // are the halfword immediate loads for the same word. Try to use one of them; // instead of IIxF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:107,Performance,load,loads,107,// MI loads one word of a GPR using an IIxF instruction and LLIxL and LLIxH; // are the halfword immediate loads for the same word. Try to use one of them; // instead of IIxF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:23,Usability,clear,clear,23,"// The new opcode will clear the other half of the GR64 reg, so; // cancel if that is live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:59,Integrability,depend,dependencies,59,// For z13 we prefer LDE over LE to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:36,Safety,avoid,avoid,36,// For z13 we prefer LDE over LE to avoid partial register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:9,Modifiability,variab,variable,9,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:56,Modifiability,variab,variable,56,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:171,Modifiability,variab,variable,171,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:223,Modifiability,variab,variable,223,"// A R/O variable is placed in code section. If the R/O variable has as; // least two byte alignment, then generated code can use relative; // instructions to address the variable. Otherwise, use the ADA to address; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:9,Availability,Avail,AvailableExternallyLinkage,9,// check AvailableExternallyLinkage here as getKindForGlobal() asserts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:63,Testability,assert,asserts,63,// check AvailableExternallyLinkage here as getKindForGlobal() asserts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:7,Modifiability,variab,variable,7,// R/O variable with multiple of 2 byte alignment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:11,Security,access,accesses,11,// PC32DBL accesses require the low bit to be clear.; //; // FIXME: Explicitly check for functions: the datalayout is currently; // missing information about function pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:46,Usability,clear,clear,46,// PC32DBL accesses require the low bit to be clear.; //; // FIXME: Explicitly check for functions: the datalayout is currently; // missing information about function pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:169,Safety,detect,detect,169,"// For Medium and above, assume that the symbol is not within the 4GB range.; // Taking the address of locally-defined text would be OK, but that; // case isn't easy to detect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:127,Energy Efficiency,schedul,scheduler,127,"// True if the subtarget should run MachineScheduler after aggressive; // coalescing. This currently replaces the SelectionDAG scheduler with the; // ""source"" order scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:165,Energy Efficiency,schedul,scheduler,165,"// True if the subtarget should run MachineScheduler after aggressive; // coalescing. This currently replaces the SelectionDAG scheduler with the; // ""source"" order scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:28,Security,access,accessed,28,// Return true if GV can be accessed using LARL for reloc model RM; // and code model CM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:172,Modifiability,variab,variables,172,"// Make sure that global data has at least 16 bits of alignment by; // default, so that we can refer to it using LARL. We don't have any; // special requirements for stack variables though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:106,Testability,stub,stub,106,"// For SystemZ we define the models as follows:; //; // Small: BRASL can call any function and will use a stub if necessary.; // Locally-binding symbols will always be in range of LARL.; //; // Medium: BRASL can call any function and will use a stub if necessary.; // GOT slots and locally-defined text will always be in range; // of LARL, but other symbols might not be.; //; // Large: Equivalent to Medium for now.; //; // Kernel: Equivalent to Medium for now.; //; // This means that any PIC module smaller than 4GB meets the; // requirements of Small, so Small seems like the best default there.; //; // All symbols bind locally in a non-PIC module, so the choice is less; // obvious. There are two cases:; //; // - When creating an executable, PLTs and copy relocations allow; // us to treat external symbols as part of the executable.; // Any executable smaller than 4GB meets the requirements of Small,; // so that seems like the best default.; //; // - When creating JIT code, stubs will be in range of BRASL if the; // image is less than 4GB in size. GOT entries will likewise be; // in range of LARL. However, the JIT environment has no equivalent; // of copy relocs, so locally-binding data symbols might not be in; // the range of LARL. We need the Medium model in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:245,Testability,stub,stub,245,"// For SystemZ we define the models as follows:; //; // Small: BRASL can call any function and will use a stub if necessary.; // Locally-binding symbols will always be in range of LARL.; //; // Medium: BRASL can call any function and will use a stub if necessary.; // GOT slots and locally-defined text will always be in range; // of LARL, but other symbols might not be.; //; // Large: Equivalent to Medium for now.; //; // Kernel: Equivalent to Medium for now.; //; // This means that any PIC module smaller than 4GB meets the; // requirements of Small, so Small seems like the best default there.; //; // All symbols bind locally in a non-PIC module, so the choice is less; // obvious. There are two cases:; //; // - When creating an executable, PLTs and copy relocations allow; // us to treat external symbols as part of the executable.; // Any executable smaller than 4GB meets the requirements of Small,; // so that seems like the best default.; //; // - When creating JIT code, stubs will be in range of BRASL if the; // image is less than 4GB in size. GOT entries will likewise be; // in range of LARL. However, the JIT environment has no equivalent; // of copy relocs, so locally-binding data symbols might not be in; // the range of LARL. We need the Medium model in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:985,Testability,stub,stubs,985,"// For SystemZ we define the models as follows:; //; // Small: BRASL can call any function and will use a stub if necessary.; // Locally-binding symbols will always be in range of LARL.; //; // Medium: BRASL can call any function and will use a stub if necessary.; // GOT slots and locally-defined text will always be in range; // of LARL, but other symbols might not be.; //; // Large: Equivalent to Medium for now.; //; // Kernel: Equivalent to Medium for now.; //; // This means that any PIC module smaller than 4GB meets the; // requirements of Small, so Small seems like the best default there.; //; // All symbols bind locally in a non-PIC module, so the choice is less; // obvious. There are two cases:; //; // - When creating an executable, PLTs and copy relocations allow; // us to treat external symbols as part of the executable.; // Any executable smaller than 4GB meets the requirements of Small,; // so that seems like the best default.; //; // - When creating JIT code, stubs will be in range of BRASL if the; // image is less than 4GB in size. GOT entries will likewise be; // in range of LARL. However, the JIT environment has no equivalent; // of copy relocs, so locally-binding data symbols might not be in; // the range of LARL. We need the Medium model in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:32,Deployability,Configurat,Configuration,32,/// SystemZ Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:32,Modifiability,Config,Configuration,32,/// SystemZ Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:108,Availability,avail,available,108,"// We eliminate comparisons here rather than earlier because some; // transformations can change the set of available CC values and we; // generally want those transformations to have priority. This is; // especially true in the commonest case where the result of the comparison; // is used by a single in-range branch instruction, since we will then; // be able to fuse the compare and the branch instead.; //; // For example, two-address NILF can sometimes be converted into; // three-address RISBLG. NILF produces a CC value that indicates whether; // the low word is zero, but RISBLG does not modify CC at all. On the; // other hand, 64-bit ANDs like NILL can sometimes be converted to RISBG.; // The CC value produced by NILL isn't useful for our purposes, but the; // value produced by RISBG can be used for any comparison with zero; // (not just equality). So there are some transformations that lose; // CC values (while still being worthwhile) and others that happen to make; // the CC result more useful than it was originally.; //; // Another reason is that we only want to use BRANCH ON COUNT in cases; // where we know that the count register is not going to be spilled.; //; // Doing it so late makes it more likely that a register will be reused; // between the comparison and the branch, but it isn't clear whether; // preventing that would be a win or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:1317,Usability,clear,clear,1317,"// We eliminate comparisons here rather than earlier because some; // transformations can change the set of available CC values and we; // generally want those transformations to have priority. This is; // especially true in the commonest case where the result of the comparison; // is used by a single in-range branch instruction, since we will then; // be able to fuse the compare and the branch instead.; //; // For example, two-address NILF can sometimes be converted into; // three-address RISBLG. NILF produces a CC value that indicates whether; // the low word is zero, but RISBLG does not modify CC at all. On the; // other hand, 64-bit ANDs like NILL can sometimes be converted to RISBG.; // The CC value produced by NILL isn't useful for our purposes, but the; // value produced by RISBG can be used for any comparison with zero; // (not just equality). So there are some transformations that lose; // CC values (while still being worthwhile) and others that happen to make; // the CC result more useful than it was originally.; //; // Another reason is that we only want to use BRANCH ON COUNT in cases; // where we know that the count register is not going to be spilled.; //; // Doing it so late makes it more likely that a register will be reused; // between the comparison and the branch, but it isn't clear whether; // preventing that would be a win or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:12,Energy Efficiency,schedul,scheduling,12,"// Do final scheduling after all other optimizations, to get an; // optimal input for the decoder (branch relaxation must happen; // after block placement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:39,Performance,optimiz,optimizations,39,"// Do final scheduling after all other optimizations, to get an; // optimal input for the decoder (branch relaxation must happen; // after block placement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:13,Performance,load,loaded,13,// Constants loaded via lgfi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:13,Performance,load,loaded,13,// Constants loaded via llilf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:13,Performance,load,loaded,13,// Constants loaded via llihf:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:19,Performance,load,loads,19,// i128 immediates loads from Constant Pool,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Availability,Mask,Masks,3,// Masks supported by oilf/xilf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Availability,Mask,Masks,3,// Masks supported by oihf/xihf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:10,Availability,mask,masks,10,// 64-bit masks supported by nilf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:10,Availability,mask,masks,10,// 64-bit masks supported by nilh.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:45,Security,access,accesses,45,// Don't prefetch a loop with many far apart accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:79,Performance,load,loads,79,"// TODO: return a good value for BB-VECTORIZER that includes the; // immediate loads, which we do not want to count for the loop; // vectorizer, since they are hopefully hoisted out of the loop. This; // would require a new parameter 'InLoop', but not sure if constant; // args are common enough to motivate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:129,Energy Efficiency,power,power,129,// There are thre cases of division and remainder: Dividing with a register; // needs a divide instruction. A divisor which is a power of two constant; // can be implemented with a sequence of shifts. Any other constant needs a; // multiply and shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:35,Testability,log,logical,35,// Give discount for some combined logical operations if supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:195,Safety,avoid,avoid,195,"// Temporary hack: disable high vectorization factors with integer; // division/remainder, which will get scalarized and handled with; // GR128 registers. The mischeduler is not clever enough to avoid; // spilling yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:14,Modifiability,enhance,enhancements,14,// The vector enhancements facility 1 provides v4f32 instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:81,Performance,load,loaded,81,"// Loop vectorizer calls here to figure out the extra cost of; // broadcasting a loaded value to all elements of a vector. Since vlrep; // loads and replicates with a single instruction, adjust the returned; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:139,Performance,load,loads,139,"// Loop vectorizer calls here to figure out the extra cost of; // broadcasting a loaded value to all elements of a vector. Since vlrep; // loads and replicates with a single instruction, adjust the returned; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:116,Availability,mask,mask,116,"// Up to 2 vector registers can be truncated efficiently with pack or; // permute. The latter requires an immediate mask to be loaded, which; // typically gets hoisted out of a loop. TODO: return a good value for; // BB-VECTORIZER that includes the immediate loads, which we do not want; // to count for the loop vectorizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:45,Energy Efficiency,efficient,efficiently,45,"// Up to 2 vector registers can be truncated efficiently with pack or; // permute. The latter requires an immediate mask to be loaded, which; // typically gets hoisted out of a loop. TODO: return a good value for; // BB-VECTORIZER that includes the immediate loads, which we do not want; // to count for the loop vectorizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:127,Performance,load,loaded,127,"// Up to 2 vector registers can be truncated efficiently with pack or; // permute. The latter requires an immediate mask to be loaded, which; // typically gets hoisted out of a loop. TODO: return a good value for; // BB-VECTORIZER that includes the immediate loads, which we do not want; // to count for the loop vectorizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:259,Performance,load,loads,259,"// Up to 2 vector registers can be truncated efficiently with pack or; // permute. The latter requires an immediate mask to be loaded, which; // typically gets hoisted out of a loop. TODO: return a good value for; // BB-VECTORIZER that includes the immediate loads, which we do not want; // to count for the loop vectorizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:114,Modifiability,extend,extend,114,"// Return the cost of converting a vector bitmask produced by a compare; // (SrcTy), to the type of the select or extend instruction (DstTy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:33,Availability,mask,mask,33,// Extra cost for moving part of mask before unpacking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:126,Modifiability,extend,extending,126,"// Get the cost of converting a boolean vector to a vector with same width; // and element size as Dst, plus the cost of zero extending if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:45,Availability,mask,mask,45,// One 'vn' per dst vector with an immediate mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:18,Testability,log,logic,18,// FIXME: Can the logic below also be used for these cost kinds?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:9,Modifiability,extend,extend,9,/*i8/i16 extend*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:88,Modifiability,extend,extending,88,"// Extensions from GPR to i128 (in VR) typically costs two instructions,; // but a zero-extending load would be just one extra instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:98,Performance,load,load,98,"// Extensions from GPR to i128 (in VR) typically costs two instructions,; // but a zero-extending load would be just one extra instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:28,Performance,load,load,28,// Will be converted to GPR load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:9,Performance,tune,tune,9,// TODO: tune vector-to-scalar cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:45,Usability,simpl,simplify,45,// TODO: Fix base implementation which could simplify things a bit here; // (seems to miss on differentiating on scalar/vector types).; // Only 64 bit vector conversions are natively supported before z15.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:65,Modifiability,extend,extending,65,// Scalar i8 / i16 operations will typically be made after first extending; // the operands to i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:33,Modifiability,extend,extends,33,// A load of i8 or i16 sign/zero extends to i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:5,Performance,load,load,5,// A load of i8 or i16 sign/zero extends to i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:5,Performance,load,loaded,5,"// A loaded value compared with 0 with multiple users becomes Load and; // Test. The load is then not foldable, so return 0 cost for the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:62,Performance,Load,Load,62,"// A loaded value compared with 0 with multiple users becomes Load and; // Test. The load is then not foldable, so return 0 cost for the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:85,Performance,load,load,85,"// A loaded value compared with 0 with multiple users becomes Load and; // Test. The load is then not foldable, so return 0 cost for the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:75,Testability,Test,Test,75,"// A loaded value compared with 0 with multiple users becomes Load and; // Test. The load is then not foldable, so return 0 cost for the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Performance,Load,Load,3,// Load On Condition / Select Register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:14,Availability,mask,mask,14,/*+test-under-mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Testability,test,test-under-mask,3,/*+test-under-mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:50,Deployability,pipeline,pipeline,50,// Give a slight penalty for moving out of vector pipeline to FXU unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:14,Performance,load,load,14,// Check if a load may be folded as a memory operand in its user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:30,Modifiability,extend,extend,30,// Load (single use) -> trunc/extend (single use) -> UserI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Performance,Load,Load,3,// Load (single use) -> trunc/extend (single use) -> UserI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:43,Performance,Load,LoadOrTruncBits,43,"// Not commutative, only RHS foldable.; // LoadOrTruncBits holds the number of effectively loaded bits, but 0 if an; // extension was made of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:91,Performance,load,loaded,91,"// Not commutative, only RHS foldable.; // LoadOrTruncBits holds the number of effectively loaded bits, but 0 if an; // extension was made of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:146,Performance,load,load,146,"// Not commutative, only RHS foldable.; // LoadOrTruncBits holds the number of effectively loaded bits, but 0 if an; // extension was made of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:38,Modifiability,extend,extended,38,// Store the load or its truncated or extended value in FoldedValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:13,Performance,load,load,13,// Store the load or its truncated or extended value in FoldedValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:24,Performance,load,loads,24,"// UserI can't fold two loads, so in that case return 0 cost only; // half of the time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:9,Performance,Load,Load,9,// Store/Load reversed saves one instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:14,Performance,load,load,14,"// In case of load -> bswap -> store, return normal cost for the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:65,Performance,load,load,65,"// In case of load -> bswap -> store, return normal cost for the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Performance,Load,Loading,3,"// Loading interleave groups may have gaps, which may mean fewer; // loads. Find out how many vectors will be loaded in total, and in how; // many of them each value will be in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:69,Performance,load,loads,69,"// Loading interleave groups may have gaps, which may mean fewer; // loads. Find out how many vectors will be loaded in total, and in how; // many of them each value will be in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:110,Performance,load,loaded,110,"// Loading interleave groups may have gaps, which may mean fewer; // loads. Find out how many vectors will be loaded in total, and in how; // many of them each value will be in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:22,Performance,load,loaded,22,"// Estimate that each loaded source vector containing this Index; // requires one operation, except that vperm can handle two input; // registers first time for each dst vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:11,Performance,load,load,11,// Cost of load/store operations and the permutations needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:599,Availability,mask,mask,599,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:640,Availability,mask,mask,640,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:685,Availability,mask,mask,685,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:711,Availability,mask,mask,711,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:788,Availability,mask,mask,788,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:862,Availability,mask,mask,862,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:911,Availability,mask,mask,911,"Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruction is superior), but are mapped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:928,Availability,mask,mask,928,"Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruction is superior), but are mapped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:934,Availability,mask,mask,934,"Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruction is superior), but are mapped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:1574,Performance,queue,queue,1574,"e-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruction is superior), but are mapped; // in the hopes of folding the result using rules 4 and 8-10 (likely removing; // the original comparison in the process).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:33,Testability,Test,Test,33,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:442,Testability,Test,Test,442,"//===-- SystemZTDC.cpp - Utilize Test Data Class instruction --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:1540,Testability,Log,LogicOpsWorklist,1540,"e-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruction is superior), but are mapped; // in the hopes of folding the result using rules 4 and 8-10 (likely removing; // the original comparison in the process).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:1716,Usability,simpl,simplify,1716,"e-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruction is superior), but are mapped; // in the hopes of folding the result using rules 4 and 8-10 (likely removing; // the original comparison in the process).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:88,Availability,mask,mask,88,"// Maps seen instructions that can be mapped to a TDC, values are; // (TDC operand, TDC mask, worthy flag) triples.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:7,Performance,queue,queue,7,// The queue of and/or/xor i1 instructions to be potentially folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:109,Performance,queue,queue,109,// Marks an instruction as converted - adds it to ConvertedInsts and adds; // any and/or/xor i1 users to the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:11,Availability,mask,masks,11,"// Partial masks to use for EQ, GT, LT, UN comparisons, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:17,Availability,mask,mask,17,// Construct the mask as a combination of the partial masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:54,Availability,mask,masks,54,// Construct the mask as a combination of the partial masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:31,Availability,mask,mask,31,// Fold with fabs - adjust the mask appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:15,Availability,mask,mask,15,// Bail if the mask is not a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:43,Usability,simpl,simple,43,"// icmp ne (call llvm.s390.tdc(...)), 0 -> simple TDC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:61,Availability,mask,mask,61,"// icmp eq (call llvm.s390.tdc(...)), 0 -> TDC with inverted mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:15,Performance,queue,queue,15,// Process the queue of logic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:24,Testability,log,logic,24,// Process the queue of logic instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:39,Usability,clear,clear,39,"// We've actually done something - now clear misc accumulated junk (fabs,; // bitcast).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:570,Availability,error,error,570,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:307,Integrability,depend,dependent,307,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:519,Integrability,depend,dependent,519,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:580,Integrability,message,messages,580,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:276,Safety,avoid,avoid,276,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:150,Security,access,access,150,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:85,Availability,error,error,85,"// Check the parsed register group ""Reg.Group"" with the expected ""Group""; // Have to error out if user specified wrong prefix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:37,Safety,safe,safe,37,"// Instruction has a ""Length"" field, safe to parse the first token as; // the ""Length"" field",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:208,Availability,error,error,208,"// Otherwise, if the instruction has no ""Length"" field, parse the; // token as a ""Register"". We don't have to worry about whether the; // instruction is invalid here, because the caller will take care of; // error reporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:174,Availability,avail,available,174,"// Check if the current operand has a custom associated parser, if so, try to; // custom parse the operand, or fallback to the general approach. Force all; // features to be available during the operand check, or else we will fail to; // find the custom parser, and then we will later get an InvalidOperand error; // instead of a MissingFeature errror.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:307,Availability,error,error,307,"// Check if the current operand has a custom associated parser, if so, try to; // custom parse the operand, or fallback to the general approach. Force all; // features to be available during the operand check, or else we will fail to; // find the custom parser, and then we will later get an InvalidOperand error; // instead of a MissingFeature errror.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:107,Availability,error,error,107,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:83,Integrability,depend,dependent,83,"// Check for a register. All real register operands should have used; // a context-dependent parse routine, which gives the required register; // class. The code is here to mop up other cases, like those where; // the instruction isn't recognized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:99,Integrability,rout,routine,99,"// Check for a register. All real register operands should have used; // a context-dependent parse routine, which gives the required register; // class. The code is here to mop up other cases, like those where; // the instruction isn't recognized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:125,Integrability,depend,dependent,125,"// The only other type of operand is an immediate or address. As above,; // real address operands should have used a context-dependent parse routine,; // so we treat any plain expression as an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:141,Integrability,rout,routine,141,"// The only other type of operand is an immediate or address. As above,; // real address operands should have used a context-dependent parse routine,; // so we treat any plain expression as an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:20,Availability,error,error,20,// Special case the error message for the very common case where only; // a single subtarget feature is missing,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:26,Integrability,message,message,26,// Special case the error message for the very common case where only; // a single subtarget feature is missing,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZInstPrinter.h:43,Availability,mask,mask,43,"// Print the mnemonic for a condition-code mask (""ne"", ""lh"", etc.); // This forms part of the instruction name rather than the operand list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp:109,Deployability,install,installed,109,// Value is a fully-resolved relocation value: Symbol + Addend [- Pivot].; // Return the bits that should be installed in a relocation field for; // fixup kind Kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h:49,Energy Efficiency,allocate,allocated,49,"// How many bytes are in the ABI-defined, caller-allocated part of; // a stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h:353,Integrability,interface,interface,353,"// Maps of asm register numbers to LLVM register numbers, with 0 indicating; // an invalid register. In principle we could use 32-bit and 64-bit register; // classes directly, provided that we relegated the GPR allocation order; // in SystemZRegisterInfo.td to an AltOrder and left the default order; // as %r0-%r15. It seems better to provide the same interface for; // all classes though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp:309,Performance,load,load,309,"// Check whether MI uses a vector length operand. If so, we prepare for VL; // register. We would like to reuse VL register as much as possible. We; // also would like to keep the number of LEA instructions as fewer as; // possible. Therefore, we use a regular scalar register to hold immediate; // values to load VL register. And try to reuse identical scalar registers; // to avoid new LVLr instructions as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp:378,Safety,avoid,avoid,378,"// Check whether MI uses a vector length operand. If so, we prepare for VL; // register. We would like to reuse VL register as much as possible. We; // also would like to keep the number of LEA instructions as fewer as; // possible. Therefore, we use a regular scalar register to hold immediate; // values to load VL register. And try to reuse identical scalar registers; // to avoid new LVLr instructions as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp:13,Deployability,update,update,13,"// Check the update of a given scalar register holding an immediate value; // for VL register. Also, a call doesn't preserve VL register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp:33,Deployability,update,updated,33,"// The latest VL is needed to be updated, so disable HasRegForVL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VE.h:25,Integrability,interface,interface,25,"//===-- VE.h - Top-level interface for VE representation --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // VE back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- VEAsmPrinter.cpp - VE LLVM assembly writer ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format VE assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp:8,Performance,load,load,8,// Just load the address of GOT to MCRegOP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp:92,Safety,safe,safe,92,"// PLT; // lea %dst, func@plt_lo(-24); // and %dst, %dst, (32)0; // sic %plt ; FIXME: is it safe to use %plt here?; // lea.sl %dst, func@plt_hi(%plt, %dst)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:396,Integrability,interface,interfaces,396,"//===-- VECustomDAG.h - VE Custom DAG Nodes ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that VE uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:16,Availability,avail,available,16,// This is only available for VP SDNodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:16,Availability,avail,available,16,// This is only available for VP SDNodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:24,Performance,LOAD,LOAD,24,// Regular MLOAD/MSTORE/LOAD/STORE; // No stride argument -> use the contiguous element size as stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:12,Availability,mask,mask,12,// Constant mask splat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:12,Availability,Mask,Mask,12,// Legalize Mask (unpack or all-true),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:208,Availability,mask,mask,208,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:478,Integrability,wrap,wrapping,478,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:1151,Integrability,wrap,wraps,1151,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:1256,Integrability,wrap,wrapped,1256,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:1037,Performance,perform,performed,1037,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:945,Testability,log,logical,945,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:3,Availability,Mask,Mask,3,// Mask position of this node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:21,Availability,mask,mask,21,// Get the vector or mask register type for this packing and element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:41,Availability,mask,mask,41,// Whether this type belongs to a packed mask or vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:3,Integrability,Wrap,Wrap,3,// Wrap AVL in a LEGALAVL node (unless it is one already).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:533,Availability,down,downward,533,"//===-- VEFrameLowering.cpp - VE Frame Information ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the VE implementation of TargetFrameLowering class.; //; // On VE, stack frames are structured as follows:; //; // The stack grows downward.; //; // All of the individual frame areas on the frame below are optional, i.e. it's; // possible to create a function so that the particular area isn't present; // in the frame.; //; // At function entry, the ""frame"" looks as follows:; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- sp; // | | Lower address; //; // VE doesn't use on demand stack allocation, so user code generated by LLVM; // needs to call VEOS to allocate stack frame. VE's ABI want to reduce the; // number of VEOS calls, so ABI requires to allocate not only RSA (in general; // CSR, callee saved register) area but also call frame at the prologue of; // caller function.; //; // After the prologue has run, the frame has the following general structure.; // Note that technically the last frame area (VLAs) doesn't get created until; // in the main function body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:1380,Energy Efficiency,allocate,allocate,1380,"--------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the VE implementation of TargetFrameLowering class.; //; // On VE, stack frames are structured as follows:; //; // The stack grows downward.; //; // All of the individual frame areas on the frame below are optional, i.e. it's; // possible to create a function so that the particular area isn't present; // in the frame.; //; // At function entry, the ""frame"" looks as follows:; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- sp; // | | Lower address; //; // VE doesn't use on demand stack allocation, so user code generated by LLVM; // needs to call VEOS to allocate stack frame. VE's ABI want to reduce the; // number of VEOS calls, so ABI requires to allocate not only RSA (in general; // CSR, callee saved register) area but also call frame at the prologue of; // caller function.; //; // After the prologue has run, the frame has the following general structure.; // Note that technically the last frame area (VLAs) doesn't get created until; // in the main function body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Regis",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:1419,Energy Efficiency,reduce,reduce,1419,"lows:; //; // The stack grows downward.; //; // All of the individual frame areas on the frame below are optional, i.e. it's; // possible to create a function so that the particular area isn't present; // in the frame.; //; // At function entry, the ""frame"" looks as follows:; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- sp; // | | Lower address; //; // VE doesn't use on demand stack allocation, so user code generated by LLVM; // needs to call VEOS to allocate stack frame. VE's ABI want to reduce the; // number of VEOS calls, so ABI requires to allocate not only RSA (in general; // CSR, callee saved register) area but also call frame at the prologue of; // caller function.; //; // After the prologue has run, the frame has the following general structure.; // Note that technically the last frame area (VLAs) doesn't get created until; // in the main function body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- fp(=old sp); // |.empty.space.to.make.part.below.aligned.in....|; // |.case.it.needs.more.than.the.standard.16-byte.| (size of this area is; // |.alignment....",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:1475,Energy Efficiency,allocate,allocate,1475,"lows:; //; // The stack grows downward.; //; // All of the individual frame areas on the frame below are optional, i.e. it's; // possible to create a function so that the particular area isn't present; // in the frame.; //; // At function entry, the ""frame"" looks as follows:; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- sp; // | | Lower address; //; // VE doesn't use on demand stack allocation, so user code generated by LLVM; // needs to call VEOS to allocate stack frame. VE's ABI want to reduce the; // number of VEOS calls, so ABI requires to allocate not only RSA (in general; // CSR, callee saved register) area but also call frame at the prologue of; // caller function.; //; // After the prologue has run, the frame has the following general structure.; // Note that technically the last frame area (VLAs) doesn't get created until; // in the main function body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- fp(=old sp); // |.empty.space.to.make.part.below.aligned.in....|; // |.case.it.needs.more.than.the.standard.16-byte.| (size of this area is; // |.alignment....",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:2627,Modifiability,variab,variables,2627," has the following general structure.; // Note that technically the last frame area (VLAs) doesn't get created until; // in the main function body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- fp(=old sp); // |.empty.space.to.make.part.below.aligned.in....|; // |.case.it.needs.more.than.the.standard.16-byte.| (size of this area is; // |.alignment....................................| unknown at compile time); // |----------------------------------------------|; // | Local variables of fixed size including spill|; // | slots |; // |----------------------------------------------| <- bp(not defined by ABI,; // |.variable-sized.local.variables.(VLAs)........| LLVM chooses SX17); // |..............................................| (size of this area is; // |..............................................| unknown at compile time); // |----------------------------------------------| <- stack top (returned by; // | Parameter area for callee | alloca); // |----------------------------------------------|; // | Register save area (RSA) for callee |; // |----------------------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted back",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:2767,Modifiability,variab,variable-sized,2767," the main function body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- fp(=old sp); // |.empty.space.to.make.part.below.aligned.in....|; // |.case.it.needs.more.than.the.standard.16-byte.| (size of this area is; // |.alignment....................................| unknown at compile time); // |----------------------------------------------|; // | Local variables of fixed size including spill|; // | slots |; // |----------------------------------------------| <- bp(not defined by ABI,; // |.variable-sized.local.variables.(VLAs)........| LLVM chooses SX17); // |..............................................| (size of this area is; // |..............................................| unknown at compile time); // |----------------------------------------------| <- stack top (returned by; // | Parameter area for callee | alloca); // |----------------------------------------------|; // | Register save area (RSA) for callee |; // |----------------------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:2788,Modifiability,variab,variables,2788,"body, after the prologue is run. However, it's depicted; // here for completeness.; //; // | | Higher address; // |----------------------------------------------|; // | Parameter area for this function |; // |----------------------------------------------|; // | Register save area (RSA) for this function |; // |----------------------------------------------|; // | Return address for this function |; // |----------------------------------------------|; // | Frame pointer for this function |; // |----------------------------------------------| <- fp(=old sp); // |.empty.space.to.make.part.below.aligned.in....|; // |.case.it.needs.more.than.the.standard.16-byte.| (size of this area is; // |.alignment....................................| unknown at compile time); // |----------------------------------------------|; // | Local variables of fixed size including spill|; // | slots |; // |----------------------------------------------| <- bp(not defined by ABI,; // |.variable-sized.local.variables.(VLAs)........| LLVM chooses SX17); // |..............................................| (size of this area is; // |..............................................| unknown at compile time); // |----------------------------------------------| <- stack top (returned by; // | Parameter area for callee | alloca); // |----------------------------------------------|; // | Register save area (RSA) for callee |; // |----------------------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp to be set up to b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:4107,Modifiability,variab,variables,4107,"ed by; // | Parameter area for callee | alloca); // |----------------------------------------------|; // | Register save area (RSA) for callee |; // |----------------------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp to be set up to be able to access all contents in the frame areas,; // assuming all of the frame areas are non-empty.; //; // For most functions, some of the frame areas are empty. For those functions,; // it may not be necessary to set up fp or bp:; // * A base pointer is definitely needed when there are both VLAs and local; // variables with more-than-default alignment requirements.; // * A frame pointer is definitely needed when there are local variables with; // more-than-default alignment requirements.; //; // In addition, VE ABI defines RSA frame, return address, and frame pointer; // as follows:; //; // |----------------------------------------------| <- sp+176; // | %s18...%s33 |; // |----------------------------------------------| <- sp+48; // | Linkage area register (%s17) |; // |----------------------------------------------| <- sp+40; // | Procedure linkage table register (%plt=%s16) |; // |----------------------------------------------| <- sp+32; // | Global offset table register (%got=%s15) |; // |----------------------------------------------| <- sp+24; // | Thread pointer register (%tp=%s14) |; // |----------------------------------------------| <- sp+16; // | Return address |; // |----------------------------------------------| <- sp+8; // | Frame",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:4228,Modifiability,variab,variables,4228,"------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp to be set up to be able to access all contents in the frame areas,; // assuming all of the frame areas are non-empty.; //; // For most functions, some of the frame areas are empty. For those functions,; // it may not be necessary to set up fp or bp:; // * A base pointer is definitely needed when there are both VLAs and local; // variables with more-than-default alignment requirements.; // * A frame pointer is definitely needed when there are local variables with; // more-than-default alignment requirements.; //; // In addition, VE ABI defines RSA frame, return address, and frame pointer; // as follows:; //; // |----------------------------------------------| <- sp+176; // | %s18...%s33 |; // |----------------------------------------------| <- sp+48; // | Linkage area register (%s17) |; // |----------------------------------------------| <- sp+40; // | Procedure linkage table register (%plt=%s16) |; // |----------------------------------------------| <- sp+32; // | Global offset table register (%got=%s15) |; // |----------------------------------------------| <- sp+24; // | Thread pointer register (%tp=%s14) |; // |----------------------------------------------| <- sp+16; // | Return address |; // |----------------------------------------------| <- sp+8; // | Frame pointer |; // |----------------------------------------------| <- sp+0; //; // NOTE: This description is based on VE ABI and description in; // AArch64FrameLowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:3469,Security,access,access,3469,"ion |; // |----------------------------------------------| <- fp(=old sp); // |.empty.space.to.make.part.below.aligned.in....|; // |.case.it.needs.more.than.the.standard.16-byte.| (size of this area is; // |.alignment....................................| unknown at compile time); // |----------------------------------------------|; // | Local variables of fixed size including spill|; // | slots |; // |----------------------------------------------| <- bp(not defined by ABI,; // |.variable-sized.local.variables.(VLAs)........| LLVM chooses SX17); // |..............................................| (size of this area is; // |..............................................| unknown at compile time); // |----------------------------------------------| <- stack top (returned by; // | Parameter area for callee | alloca); // |----------------------------------------------|; // | Register save area (RSA) for callee |; // |----------------------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp to be set up to be able to access all contents in the frame areas,; // assuming all of the frame areas are non-empty.; //; // For most functions, some of the frame areas are empty. For those functions,; // it may not be necessary to set up fp or bp:; // * A base pointer is definitely needed when there are both VLAs and local; // variables with more-than-default alignment requirements.; // * A frame pointer is definitely needed when there are local variables with; // more-than-default alignment requirem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:3596,Security,access,access,3596,"ion |; // |----------------------------------------------| <- fp(=old sp); // |.empty.space.to.make.part.below.aligned.in....|; // |.case.it.needs.more.than.the.standard.16-byte.| (size of this area is; // |.alignment....................................| unknown at compile time); // |----------------------------------------------|; // | Local variables of fixed size including spill|; // | slots |; // |----------------------------------------------| <- bp(not defined by ABI,; // |.variable-sized.local.variables.(VLAs)........| LLVM chooses SX17); // |..............................................| (size of this area is; // |..............................................| unknown at compile time); // |----------------------------------------------| <- stack top (returned by; // | Parameter area for callee | alloca); // |----------------------------------------------|; // | Register save area (RSA) for callee |; // |----------------------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp to be set up to be able to access all contents in the frame areas,; // assuming all of the frame areas are non-empty.; //; // For most functions, some of the frame areas are empty. For those functions,; // it may not be necessary to set up fp or bp:; // * A base pointer is definitely needed when there are both VLAs and local; // variables with more-than-default alignment requirements.; // * A frame pointer is definitely needed when there are local variables with; // more-than-default alignment requirem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:3803,Security,access,access,3803,"ned by ABI,; // |.variable-sized.local.variables.(VLAs)........| LLVM chooses SX17); // |..............................................| (size of this area is; // |..............................................| unknown at compile time); // |----------------------------------------------| <- stack top (returned by; // | Parameter area for callee | alloca); // |----------------------------------------------|; // | Register save area (RSA) for callee |; // |----------------------------------------------|; // | Return address for callee |; // |----------------------------------------------|; // | Frame pointer for callee |; // |----------------------------------------------| <- sp; // | | Lower address; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp to be set up to be able to access all contents in the frame areas,; // assuming all of the frame areas are non-empty.; //; // For most functions, some of the frame areas are empty. For those functions,; // it may not be necessary to set up fp or bp:; // * A base pointer is definitely needed when there are both VLAs and local; // variables with more-than-default alignment requirements.; // * A frame pointer is definitely needed when there are local variables with; // more-than-default alignment requirements.; //; // In addition, VE ABI defines RSA frame, return address, and frame pointer; // as follows:; //; // |----------------------------------------------| <- sp+176; // | %s18...%s33 |; // |----------------------------------------------| <- sp+48; // | Linkage area register (%s17) |; // |----------------------------------------------| <- sp+40; // | Procedure linkage table register (%plt=%s16) |; // |----------------------------------------------| <- sp+32; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:72,Availability,avail,available,72,"// Emit following codes. This clobbers SX13 which we always know is; // available here.; // lea %s13, NumBytes@lo; // and %s13, %s13, (32)0; // lea.sl %sp, NumBytes@hi(%s13, %sp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:728,Energy Efficiency,monitor,monitor,728,"// Emit following codes. It is not possible to insert multiple; // BasicBlocks in PEI pass, so we emit two pseudo instructions here.; //; // EXTEND_STACK // pseudo instrcution; // EXTEND_STACK_GUARD // pseudo instrcution; //; // EXTEND_STACK pseudo will be converted by ExpandPostRA pass into; // following instructions with multiple basic blocks later.; //; // thisBB:; // brge.l.t %sp, %sl, sinkBB; // syscallBB:; // ld %s61, 0x18(, %tp) // load param area; // or %s62, 0, %s0 // spill the value of %s0; // lea %s63, 0x13b // syscall # of grow; // shm.l %s63, 0x0(%s61) // store syscall # at addr:0; // shm.l %sl, 0x8(%s61) // store old limit at addr:8; // shm.l %sp, 0x10(%s61) // store new limit at addr:16; // monc // call monitor; // or %s0, 0, %s62 // restore the value of %s0; // sinkBB:; //; // EXTEND_STACK_GUARD pseudo will be simply eliminated by ExpandPostRA; // pass. This pseudo is required to be at the next of EXTEND_STACK; // pseudo in order to protect iteration loop in ExpandPostRA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:443,Performance,load,load,443,"// Emit following codes. It is not possible to insert multiple; // BasicBlocks in PEI pass, so we emit two pseudo instructions here.; //; // EXTEND_STACK // pseudo instrcution; // EXTEND_STACK_GUARD // pseudo instrcution; //; // EXTEND_STACK pseudo will be converted by ExpandPostRA pass into; // following instructions with multiple basic blocks later.; //; // thisBB:; // brge.l.t %sp, %sl, sinkBB; // syscallBB:; // ld %s61, 0x18(, %tp) // load param area; // or %s62, 0, %s0 // spill the value of %s0; // lea %s63, 0x13b // syscall # of grow; // shm.l %s63, 0x0(%s61) // store syscall # at addr:0; // shm.l %sl, 0x8(%s61) // store old limit at addr:8; // shm.l %sp, 0x10(%s61) // store new limit at addr:16; // monc // call monitor; // or %s0, 0, %s62 // restore the value of %s0; // sinkBB:; //; // EXTEND_STACK_GUARD pseudo will be simply eliminated by ExpandPostRA; // pass. This pseudo is required to be at the next of EXTEND_STACK; // pseudo in order to protect iteration loop in ExpandPostRA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:838,Usability,simpl,simply,838,"// Emit following codes. It is not possible to insert multiple; // BasicBlocks in PEI pass, so we emit two pseudo instructions here.; //; // EXTEND_STACK // pseudo instrcution; // EXTEND_STACK_GUARD // pseudo instrcution; //; // EXTEND_STACK pseudo will be converted by ExpandPostRA pass into; // following instructions with multiple basic blocks later.; //; // thisBB:; // brge.l.t %sp, %sl, sinkBB; // syscallBB:; // ld %s61, 0x18(, %tp) // load param area; // or %s62, 0, %s0 // spill the value of %s0; // lea %s63, 0x13b // syscall # of grow; // shm.l %s63, 0x0(%s61) // store syscall # at addr:0; // shm.l %sl, 0x8(%s61) // store old limit at addr:8; // shm.l %sp, 0x10(%s61) // store new limit at addr:16; // monc // call monitor; // or %s0, 0, %s62 // restore the value of %s0; // sinkBB:; //; // EXTEND_STACK_GUARD pseudo will be simply eliminated by ExpandPostRA; // pass. This pseudo is required to be at the next of EXTEND_STACK; // pseudo in order to protect iteration loop in ExpandPostRA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.; // This number of bytes is already aligned to ABI stack alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:3,Deployability,Update,Update,3,// Update stack size with corrected value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:14,Modifiability,extend,extend,14,// Emit stack extend instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:134,Modifiability,variab,variable,134,// hasFP - Return true if the specified function should have a dedicated frame; // pointer register. This is true if the function has variable sized allocas; // or if frame pointer elimination is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:116,Modifiability,variab,variable,116,"// If data on stack require realignemnt, frame indexies are based on a %sp; // or %s17 (bp) register. If there is a variable sized object, bp is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp:61,Energy Efficiency,allocate,allocate,61,// Functions having BP need to emit prologue and epilogue to allocate local; // buffer on the stack even if the function is a leaf function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.h:18,Modifiability,extend,extending,18,// Emits code for extending SP in function prologue/epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrBuilder.h:393,Security,expose,exposes,393,"//===-- VEInstrBuilder.h - Aides for building VE insts ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to simplify generating frame and constant pool; // references.; //; // For reference, the order of operands for memory references is:; // (Operand), Dest Reg, Base Reg, and either Reg Index or Immediate; // Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrBuilder.h:484,Usability,simpl,simplify,484,"//===-- VEInstrBuilder.h - Aides for building VE insts ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to simplify generating frame and constant pool; // references.; //; // For reference, the order of operands for memory references is:; // (Operand), Dest Reg, Base Reg, and either Reg Index or Immediate; // Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:495,Safety,avoid,avoids,495,"// Try to fold like below:; // %1:i64 = ORim 0, 0(1); // %2:i64 = CMPSLrr %0, %1; // To; // %2:i64 = CMPSLrm %0, 0(1); //; // Another example:; // %1:i64 = ORim 6, 0(1); // %2:i64 = CMPSLrr %1, %0; // To; // %2:i64 = CMPSLir 6, %0; //; // Support commutable instructions like below:; // %1:i64 = ORim 6, 0(1); // %2:i64 = ADDSLrr %1, %0; // To; // %2:i64 = ADDSLri %0, 6; //; // FIXME: Need to support i32. Current implementtation requires; // EXTRACT_SUBREG, so input has following COPY and it avoids folding:; // %1:i64 = ORim 6, 0(1); // %2:i32 = COPY %1.sub_i32; // %3:i32 = ADDSWSXrr %0, %2; // FIXME: Need to support shift, cmov, and more instructions.; // FIXME: Need to support lvl too, but LVLGen runs after peephole-opt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:17,Testability,log,logical,17,// Expand pseudo logical vector instructions for VM512 registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:434,Energy Efficiency,monitor,monitor,434,"// Create following instructions and multiple basic blocks.; //; // thisBB:; // brge.l.t %sp, %sl, sinkBB; // syscallBB:; // ld %s61, 0x18(, %tp) // load param area; // or %s62, 0, %s0 // spill the value of %s0; // lea %s63, 0x13b // syscall # of grow; // shm.l %s63, 0x0(%s61) // store syscall # at addr:0; // shm.l %sl, 0x8(%s61) // store old limit at addr:8; // shm.l %sp, 0x10(%s61) // store new limit at addr:16; // monc // call monitor; // or %s0, 0, %s62 // restore the value of %s0; // sinkBB:; // Create new MBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:149,Performance,load,load,149,"// Create following instructions and multiple basic blocks.; //; // thisBB:; // brge.l.t %sp, %sl, sinkBB; // syscallBB:; // ld %s61, 0x18(, %tp) // load param area; // or %s62, 0, %s0 // spill the value of %s0; // lea %s63, 0x13b // syscall # of grow; // shm.l %s63, 0x0(%s61) // store syscall # at addr:0; // shm.l %sl, 0x8(%s61) // store old limit at addr:8; // shm.l %sp, 0x10(%s61) // store new limit at addr:16; // monc // call monitor; // or %s0, 0, %s62 // restore the value of %s0; // sinkBB:; // Create new MBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h:32,Performance,Optimiz,Optimization,32,/// } Stack Spill & Reload; /// Optimization {,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h:6,Performance,Optimiz,Optimization,6,/// } Optimization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp:31,Integrability,wrap,wrapper,31,// Late eliminate the LEGALAVL wrapper,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp:57,Safety,safe,safe,57,// memory; // Try to match ADDRri since reg+imm style is safe for all VE instructions; // with a memory operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp:108,Energy Efficiency,schedul,scheduling,108,"/// createVEISelDag - This pass converts a legalized DAG into a; /// VE-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:408,Integrability,interface,interfaces,408,"//===-- VEISelLowering.cpp - VE DAG Lowering Implementation ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interfaces that VE uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:47,Modifiability,extend,extending,47,/// Load & Store {; // VE doesn't have i1 sign extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:4,Performance,Load,Load,4,/// Load & Store {; // VE doesn't have i1 sign extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:57,Performance,load,load,57,/// Load & Store {; // VE doesn't have i1 sign extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:25,Performance,load,load,25,"// VE doesn't have fp128 load/store, so expand them in custom lower.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:6,Performance,Load,Load,6,/// } Load & Store; // Custom legalize address nodes into LO/HI parts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:32,Security,access,access,32,// VAARG needs to be lowered to access with 8 bytes alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:16,Availability,mask,mask,16,// Custom lower mask ops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:46,Modifiability,extend,extended,46,// Integer return values must be sign or zero extended by the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the preserved area first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:14,Energy Efficiency,allocate,allocated,14,"// We already allocated the preserved area, so the stack offset computed; // by CC_VE would be correct now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:50,Testability,Assert,Assert,50,"// The caller promoted the argument, so insert an Assert?ext SDNode so we; // won't promote the value again in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:25,Availability,down,down,25,// Truncate the register down to the argument type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:152,Performance,load,load,152,"// Adjust offset for a float argument by adding 4 since the argument is; // stored in 8 bytes buffer with offset like below. LLVM generates; // 4 bytes load instruction, so need to adjust offset here. This; // adjustment is required in only LowerFormalArguments. In LowerCall,; // a float argument is converted to i64 first, and stored as 8 bytes; // data, which is required by ABI, so no need for adjustment.; // 0 4; // +------+------+; // | empty| float|; // +------+------+",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:23,Modifiability,variab,variable,23,"// This function takes variable arguments, some of which may have been passed; // in registers %s0-%s8.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.; // TODO: need to calculate offset correctly once we support f128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:173,Modifiability,variab,variable,173,"// This function takes variable arguments, some of which may have been passed; // in registers %s0-%s8.; //; // The va_start intrinsic needs to know the offset to the first variable; // argument.; // TODO: need to calculate offset correctly once we support f128.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:44,Performance,optimiz,optimization,44,// VE target does not yet support tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the preserved area first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:14,Energy Efficiency,allocate,allocated,14,"// We already allocated the preserved area, so the stack offset computed; // by CC_VE would be correct now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:99,Safety,avoid,avoid,99,// Adjust the stack pointer to make room for the arguments.; // FIXME: Use hasReservedCallFrame to avoid %sp adjustments around all calls; // with more than 6 arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:65,Testability,stub,stub,65,"// PC-relative references to external symbols should go through $stub.; // If so, we need to prepare GlobalBaseReg first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:174,Safety,avoid,avoid,174,"// When returning 'inreg {i32, i32 }', two consecutive i32 arguments can; // reside in the same register in the high and low bits. Reuse the; // CopyFromReg previous node to avoid duplicate copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:54,Testability,Assert,Assert,54,"// The callee promoted the return value, so insert an Assert?ext SDNode so; // we won't promote the value again in this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:25,Availability,down,down,25,// Truncate the register down to the return value type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:179,Performance,load,load,179,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:544,Availability,error,error,544,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// whether the unaligned memory access is ""fast"" in the last argument by; /// reference. This is used, for example, in situations where an array; /// copy/move/set is converted to a sequence of store operations. Its use; /// helps to ensure that such replacements don't generate code that causes an; /// alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:54,Security,access,accesses,54,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// whether the unaligned memory access is ""fast"" in the last argument by; /// reference. This is used, for example, in situations where an array; /// copy/move/set is converted to a sequence of store operations. Its use; /// helps to ensure that such replacements don't generate code that causes an; /// alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:139,Security,access,accesses,139,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// whether the unaligned memory access is ""fast"" in the last argument by; /// reference. This is used, for example, in situations where an array; /// copy/move/set is converted to a sequence of store operations. Its use; /// helps to ensure that such replacements don't generate code that causes an; /// alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:262,Security,access,access,262,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// whether the unaligned memory access is ""fast"" in the last argument by; /// reference. This is used, for example, in situations where an array; /// copy/move/set is converted to a sequence of store operations. Its use; /// helps to ensure that such replacements don't generate code that causes an; /// alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:56,Modifiability,variab,variable,56,// Handle PIC mode first. VE needs a got load for every variable!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:41,Performance,load,load,41,// Handle PIC mode first. VE needs a got load for every variable!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:11,Deployability,Release,Release,11,"// VE uses Release consistency, so need a fence instruction if it is a; // cross-thread fence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:26,Deployability,release,release,26,"// Generate ""fencem 1"" as release fence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:106,Security,access,accesses,106,"// Generate ""fencem 3"" as acq_rel and seq_cst fence.; // FIXME: ""fencem 3"" doesn't wait for PCIe deveices accesses,; // so seq_cst may require more instruction for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:16,Performance,load,load,16,// Lower a f128 load into two f64 loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:34,Performance,load,loads,34,// Lower a f128 load into two f64 loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:16,Performance,load,load,16,"// Lower a vXi1 load into following instructions; // LDrii %1, (,%addr); // LVMxir %vm, 0, %1; // LDrii %2, 8(,%addr); // LVMxir %vm, 0, %2; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:12,Performance,load,load,12,// Generate load dag and prepare chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:12,Performance,load,load,12,// Generate load dag and prepare chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:40,Availability,mask,mask,40,"// If VPU is enabled, always expand non-mask vector loads to VVP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:52,Performance,load,loads,52,"// If VPU is enabled, always expand non-mask vector loads to VVP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:72,Integrability,depend,dependency,72,// Do not expand store instruction with frame index here because of; // dependency problems. We expand it later in eliminateFrameIndex().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:40,Availability,mask,mask,40,"// If VPU is enabled, always expand non-mask vector stores to VVP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:72,Integrability,depend,dependency,72,// Do not expand store instruction with frame index here because of; // dependency problems. We expand it later in eliminateFrameIndex().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList.; // We can't count on greater alignment than the word size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:20,Deployability,update,updated,20,"// Since FP is only updated here but NOT referenced, it's treated as GPR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:105,Performance,load,load,105,"// For `call @llvm.eh.sjlj.longjmp(buf)`, we generate following instructions.; //; // ThisMBB:; // %fp = load buf[0]; // %jmp = load buf[1]; // %s10 = buf ; Store an address of buf to SX10 for RestoreMBB; // %sp = load buf[2] ; generated by llvm.eh.sjlj.setjmp.; // jmp %jmp; // Reload FP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:128,Performance,load,load,128,"// For `call @llvm.eh.sjlj.longjmp(buf)`, we generate following instructions.; //; // ThisMBB:; // %fp = load buf[0]; // %jmp = load buf[1]; // %s10 = buf ; Store an address of buf to SX10 for RestoreMBB; // %sp = load buf[2] ; generated by llvm.eh.sjlj.setjmp.; // jmp %jmp; // Reload FP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:214,Performance,load,load,214,"// For `call @llvm.eh.sjlj.longjmp(buf)`, we generate following instructions.; //; // ThisMBB:; // %fp = load buf[0]; // %jmp = load buf[1]; // %s10 = buf ; Store an address of buf to SX10 for RestoreMBB; // %sp = load buf[2] ; generated by llvm.eh.sjlj.setjmp.; // jmp %jmp; // Reload FP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:22,Energy Efficiency,allocate,allocated,22,"// The %fn_context is allocated like below (from --print-after=sjljehprepare):; // %fn_context = alloca { i8*, i64, [4 x i64], i8*, i8*, [5 x i8*] }; //; // This `[5 x i8*]` is jmpbuf, so jmpbuf[1] is FI+72.; // First `i64` is callsite, so callsite is FI+8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:217,Performance,load,load,217,"// Create the MBBs for the dispatch code like following:; //; // ThisMBB:; // Prepare DispatchBB address and store it to buf[1].; // ...; //; // DispatchBB:; // %s15 = GETGOT iff isPositionIndependent; // %callsite = load callsite; // brgt.l.t #size of callsites, %callsite, DispContBB; //; // TrapBB:; // Call abort.; //; // DispContBB:; // %breg = address of jump table; // %pc = load and calculate next pc from %breg and %callsite; // jmp %pc; // Shove the dispatch's address into the return slot in the function context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:382,Performance,load,load,382,"// Create the MBBs for the dispatch code like following:; //; // ThisMBB:; // Prepare DispatchBB address and store it to buf[1].; // ...; //; // DispatchBB:; // %s15 = GETGOT iff isPositionIndependent; // %callsite = load callsite; // brgt.l.t #size of callsites, %callsite, DispContBB; //; // TrapBB:; // Call abort.; //; // DispContBB:; // %breg = address of jump table; // %pc = load and calculate next pc from %breg and %callsite; // jmp %pc; // Shove the dispatch's address into the return slot in the function context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:311,Safety,abort,abort,311,"// Create the MBBs for the dispatch code like following:; //; // ThisMBB:; // Prepare DispatchBB address and store it to buf[1].; // ...; //; // DispatchBB:; // %s15 = GETGOT iff isPositionIndependent; // %callsite = load callsite; // brgt.l.t #size of callsites, %callsite, DispContBB; //; // TrapBB:; // Call abort.; //; // DispContBB:; // %breg = address of jump table; // %pc = load and calculate next pc from %breg and %callsite; // jmp %pc; // Shove the dispatch's address into the return slot in the function context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:34,Testability,assert,assert,34,// Trap BB will causes trap like `assert(0)`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:23,Safety,abort,abort,23,// Insert code to call abort in the TrapBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask with no preserved registers. This results in all; // registers being marked as clobbered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:12,Usability,simpl,simple,12,"// Generate simple block address code for no-PIC model.; // sll %Tmp1, %IReg, 3; // lds %TReg, 0(%Tmp1, %BReg); // bcfla %TReg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid quadratic complexity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:154,Safety,safe,safe,154,"// For the case of floating point setcc, only unordered comparison; // or general comparison with -enable-no-nans-fp-math option reach; // here, so it is safe even if values are NaN. Only f128 doesn't; // safe since VE uses f64 result of f128 comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:205,Safety,safe,safe,205,"// For the case of floating point setcc, only unordered comparison; // or general comparison with -enable-no-nans-fp-math option reach; // here, so it is safe even if values are NaN. Only f128 doesn't; // safe since VE uses f64 result of f128 comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:45,Safety,safe,safe,45,"// For the case of equal or not equal, it is safe without comparison with 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:81,Safety,safe,safe,81,"// For the case of integer setcc with cmov, all signed comparison with 0; // are safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:68,Safety,safe,safe,68,"// For the case of integer setcc, only signed 64 bits comparison is safe.; // For unsigned, ""CMPU 0x80000000, 0"" has to be greater than 0, but it becomes; // less than 0 witout CMPU. For 32 bits, other half of 32 bits are; // uncoditional, so it is not safe too without CMPI..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:253,Safety,safe,safe,253,"// For the case of integer setcc, only signed 64 bits comparison is safe.; // For unsigned, ""CMPU 0x80000000, 0"" has to be greater than 0, but it becomes; // less than 0 witout CMPU. For 32 bits, other half of 32 bits are; // uncoditional, so it is not safe too without CMPI..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:41,Safety,safe,safe,41,"// Compare values. If RHS is 0 and it is safe to calculate without; // comparison, we don't generate an instruction for comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:120,Deployability,update,update,120,"// VE's condition move can handle MImm in True clause, so swap True and; // False clauses if False has MImm value. And, update condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:73,Deployability,update,update,73,"// VE's comparison can handle Simm7 in LHS, so swap LHS and RHS, and; // update condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:120,Deployability,update,update,120,"// VE's condition move can handle MImm in True clause, so swap True and; // False clauses if False has MImm value. And, update condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:34,Performance,optimiz,optimized,34,"// (srl (trunc (srl ...))) may be optimized by combining srl, so; // doesn't optimize trunc now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:77,Performance,optimiz,optimize,77,"// (srl (trunc (srl ...))) may be optimized by combining srl, so; // doesn't optimize trunc now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:62,Safety,safe,safe,62,"// CMOV in (cmov (trunc ...), true, false, int-comparison) is safe.; // However, trunc in true or false clauses is not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:119,Safety,safe,safe,119,"// CMOV in (cmov (trunc ...), true, false, int-comparison) is safe.; // However, trunc in true or false clauses is not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:89,Performance,optimiz,optimize,89,"// Check all use of selections, bit operations, and copies. If all of them; // are safe, optimize truncate to extract_subreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:83,Safety,safe,safe,83,"// Check all use of selections, bit operations, and copies. If all of them; // are safe, optimize truncate to extract_subreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:56,Performance,optimiz,optimize,56,"// Check all use of User node. If all of them are safe, optimize; // truncate to extract_subreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:50,Safety,safe,safe,50,"// Check all use of User node. If all of them are safe, optimize; // truncate to extract_subreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:82,Safety,safe,safe,82,"// If the use is an instruction which treats the source operand as i32,; // it is safe to avoid truncate here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:90,Safety,avoid,avoid,90,"// If the use is an instruction which treats the source operand as i32,; // it is safe to avoid truncate here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:11,Performance,optimiz,optimizations,11,// Special optimizations to the combination of ext and trunc.; // (ext ... (select ... (trunc ...))) is safe to avoid truncate here; // since this truncate instruction clears higher 32 bits which is filled; // by one of ext instructions later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:104,Safety,safe,safe,104,// Special optimizations to the combination of ext and trunc.; // (ext ... (select ... (trunc ...))) is safe to avoid truncate here; // since this truncate instruction clears higher 32 bits which is filled; // by one of ext instructions later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:112,Safety,avoid,avoid,112,// Special optimizations to the combination of ext and trunc.; // (ext ... (select ... (trunc ...))) is safe to avoid truncate here; // since this truncate instruction clears higher 32 bits which is filled; // by one of ext instructions later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:168,Usability,clear,clears,168,// Special optimizations to the combination of ext and trunc.; // (ext ... (select ... (trunc ...))) is safe to avoid truncate here; // since this truncate instruction clears higher 32 bits which is filled; // by one of ext instructions later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize TRUNCATE in DAG combining. Optimizing it in CUSTOM lower is; // sometime too early. Optimizing it in DAG pattern matching in VEInstrInfo.td; // is sometime too late. So, doing it at here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:39,Performance,Optimiz,Optimizing,39,"// Optimize TRUNCATE in DAG combining. Optimizing it in CUSTOM lower is; // sometime too early. Optimizing it in DAG pattern matching in VEInstrInfo.td; // is sometime too late. So, doing it at here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:96,Performance,Optimiz,Optimizing,96,"// Optimize TRUNCATE in DAG combining. Optimizing it in CUSTOM lower is; // sometime too early. Optimizing it in DAG pattern matching in VEInstrInfo.td; // is sometime too late. So, doing it at here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:95,Performance,Optimiz,Optimization,95,//===----------------------------------------------------------------------===//; // VE Target Optimization Support; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:56,Performance,load,load,56,// Specify 8 for PIC model to relieve the impact of PIC load instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:9,Performance,optimiz,optimized,9,// TODO: optimized implementation using constant values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:9,Performance,optimiz,optimized,9,// TODO: optimized implementation using constant values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:43,Integrability,Interface,Interface,43,"//===-- VEISelLowering.h - VE DAG Lowering Interface ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that VE uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- VEISelLowering.h - VE DAG Lowering Interface ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that VE uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:3,Performance,Load,Load,3,// Load function address through %plt insturction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:3,Performance,Load,Load,3,// Load address for TLS access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:24,Security,access,access,24,// Load address for TLS access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:60,Integrability,wrap,wrapper,60,"// Replicate subregister to other half.; // Annotation as a wrapper. LEGALAVL(VL) means that VL refers to 64bit of; // data, whereas the raw EVL coming in from VP nodes always refers to number; // of elements, regardless of their size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:11,Deployability,release,release,11,"// VE uses release consistency, so need fence for each atomics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:20,Modifiability,variab,variable,20,// Prepare function/variable address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:55,Security,access,accesses,55,/// Returns true if the target allows unaligned memory accesses of the; /// specified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:34,Performance,Optimiz,Optimization,34,/// } Inline Assembly; /// Target Optimization {; // Return lower limit for number of blocks in a jump table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:13,Performance,Optimiz,Optimization,13,/// } Target Optimization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp:99,Availability,avail,available,99,"// If the offset doesn't fit, emit following codes. This clobbers SX13; // which we always know is available here.; // lea %clobber, Offset@lo; // and %clobber, %clobber, (32)0; // lea.sl %clobber, Offset@hi(FrameReg, %clobber)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp:6,Performance,load,loads,6,// VE loads HiReg from 8(addr) and LoReg from 0(addr),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VESubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VESubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VESubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VESubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VESubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VESubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp:27,Deployability,Configurat,Configuration,27,/// VE Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp:27,Modifiability,Config,Configuration,27,/// VE Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp:33,Energy Efficiency,schedul,scheduling,33,// LVLGen should be called after scheduling and register allocation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h:74,Availability,error,errors,74,"// NEC nld doesn't support relative lookup tables. It shows following; // errors. So, we disable it at the moment.; // /opt/nec/ve/bin/nld: src/CMakeFiles/cxxabi_shared.dir/cxa_demangle.cpp; // .o(.rodata+0x17b4): reloc against `.L.str.376': error 2; // /opt/nec/ve/bin/nld: final link failed: Nonrepresentable section on; // output",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h:242,Availability,error,error,242,"// NEC nld doesn't support relative lookup tables. It shows following; // errors. So, we disable it at the moment.; // /opt/nec/ve/bin/nld: src/CMakeFiles/cxxabi_shared.dir/cxa_demangle.cpp; // .o(.rodata+0x17b4): reloc against `.L.str.376': error 2; // /opt/nec/ve/bin/nld: final link failed: Nonrepresentable section on; // output",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h:3,Performance,Load,Load,3,// Load & Store {,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h:5,Performance,Load,Load,5,// } Load & Store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:41,Availability,mask,mask,41,// All upstream VP SDNodes always have a mask and avl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:23,Availability,mask,mask,23,// Materialize default mask and avl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:3,Performance,Load,Load,3,// Load specific.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:30,Availability,mask,mask,30,// TODO: Infer lower AVL from mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:27,Availability,mask,mask,27,// Default to the all-true mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:35,Availability,mask,mask,35,// VP ops already have an explicit mask and AVL. When expanding from non-VP; // attach those additional inputs here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:3,Performance,Load,Load,3,// Load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:30,Availability,mask,mask,30,// TODO: Infer lower AVL from mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:27,Availability,mask,mask,27,// Default to the all-true mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:28,Performance,load,load,28,"// TODO: Recognize packable load,store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:35,Availability,mask,mask,35,// VP ops already have an explicit mask and AVL. When expanding from non-VP; // attach those additional inputs here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp:17,Integrability,interface,interface,17,/// }; // public interface of the MCTargetAsmParser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp:107,Availability,error,error,107,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp:133,Security,validat,validation,133,"// VE uses identical register name for all registers like both; // F32 and I32 uses ""%s23"". Need to convert the name of them; // for validation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the bits; // from the fixup value. The Value has been ""split up"" into the; // appropriate bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/MCTargetDesc/VEMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssembly.h:34,Integrability,interface,interface,34,"//===-- WebAssembly.h - Top-level interface for WebAssembly ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the entry points for global functions defined in; /// the LLVM WebAssembly back-end.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssembly.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssembly.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAddMissingPrototypes.cpp:99,Usability,simpl,simple,99,"// We could not derive a type for this function. In this case strip; // the isVarArg and make it a simple zero-arg function. This has more; // chance of being correct. The current signature of (...) is illegal in; // C since it doesn't have any arguments before the ""..."", we this at; // least makes it possible for this symbol to be resolved by the linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAddMissingPrototypes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAddMissingPrototypes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp:440,Energy Efficiency,Schedul,ScheduleDAG,440,"//===-- WebAssemblyArgumentMove.cpp - Argument instruction moving ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file moves ARGUMENT instructions after ScheduleDAG scheduling.; ///; /// Arguments are really live-in registers, however, since we use virtual; /// registers and LLVM doesn't support live-in virtual registers, we're; /// currently making do with ARGUMENT instructions which are placed at the top; /// of the entry block. The trick is to get them to *stay* at the top of the; /// entry block.; ///; /// The ARGUMENTS physical register keeps these instructions pinned in place; /// during liveness-aware CodeGen passes, however one thing which does not; /// respect this is the ScheduleDAG scheduler. This pass is therefore run; /// immediately after that.; ///; /// This is all hopefully a temporary solution until we find a better solution; /// for describing the live-in nature of arguments.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp:452,Energy Efficiency,schedul,scheduling,452,"//===-- WebAssemblyArgumentMove.cpp - Argument instruction moving ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file moves ARGUMENT instructions after ScheduleDAG scheduling.; ///; /// Arguments are really live-in registers, however, since we use virtual; /// registers and LLVM doesn't support live-in virtual registers, we're; /// currently making do with ARGUMENT instructions which are placed at the top; /// of the entry block. The trick is to get them to *stay* at the top of the; /// entry block.; ///; /// The ARGUMENTS physical register keeps these instructions pinned in place; /// during liveness-aware CodeGen passes, however one thing which does not; /// respect this is the ScheduleDAG scheduler. This pass is therefore run; /// immediately after that.; ///; /// This is all hopefully a temporary solution until we find a better solution; /// for describing the live-in nature of arguments.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp:977,Energy Efficiency,Schedul,ScheduleDAG,977,"//===-- WebAssemblyArgumentMove.cpp - Argument instruction moving ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file moves ARGUMENT instructions after ScheduleDAG scheduling.; ///; /// Arguments are really live-in registers, however, since we use virtual; /// registers and LLVM doesn't support live-in virtual registers, we're; /// currently making do with ARGUMENT instructions which are placed at the top; /// of the entry block. The trick is to get them to *stay* at the top of the; /// entry block.; ///; /// The ARGUMENTS physical register keeps these instructions pinned in place; /// during liveness-aware CodeGen passes, however one thing which does not; /// respect this is the ScheduleDAG scheduler. This pass is therefore run; /// immediately after that.; ///; /// This is all hopefully a temporary solution until we find a better solution; /// for describing the live-in nature of arguments.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp:989,Energy Efficiency,schedul,scheduler,989,"//===-- WebAssemblyArgumentMove.cpp - Argument instruction moving ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file moves ARGUMENT instructions after ScheduleDAG scheduling.; ///; /// Arguments are really live-in registers, however, since we use virtual; /// registers and LLVM doesn't support live-in virtual registers, we're; /// currently making do with ARGUMENT instructions which are placed at the top; /// of the entry block. The trick is to get them to *stay* at the top of the; /// entry block.; ///; /// The ARGUMENTS physical register keeps these instructions pinned in place; /// during liveness-aware CodeGen passes, however one thing which does not; /// respect this is the ScheduleDAG scheduler. This pass is therefore run; /// immediately after that.; ///; /// This is all hopefully a temporary solution until we find a better solution; /// for describing the live-in nature of arguments.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyArgumentMove.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:488,Integrability,depend,dependent,488,"//===-- WebAssemblyAsmPrinter.cpp - WebAssembly LLVM assembly writer ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a printer that converts from our internal; /// representation of machine-dependent LLVM code to the WebAssembly assembly; /// language.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:589,Availability,avail,available,589,"// Emscripten exception handling helpers; //; // This converts invoke names generated by LowerEmscriptenEHSjLj to real names; // that are expected by JavaScript glue code. The invoke names generated by; // Emscripten JS glue code are based on their argument and return types; for; // example, for a function that takes an i32 and returns nothing, it is; // 'invoke_vi'. But the format of invoke generated by LowerEmscriptenEHSjLj pass; // contains a mangled string generated from their IR types, for example,; // ""__invoke_void_%struct.mystruct*_int"", because final wasm types are not; // available in the IR pass. So we convert those names to the form that; // Emscripten JS code expects.; //; // Refer to LowerEmscriptenEHSjLj pass for more details.; // Returns true if the given function name is an invoke name generated by; // LowerEmscriptenEHSjLj pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:363,Availability,alive,alive,363,"// When a function's address is taken, a TABLE_INDEX relocation is emitted; // against the function symbol at the use site. However the relocation; // doesn't explicitly refer to the table. In the future we may want to; // define a new kind of reloc against both the function and the table, so; // that the linker can see that the function symbol keeps the table alive,; // but for now manually mark the table as live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:71,Safety,safe,safe,71,// This pseudo-feature tells the linker whether shared memory would be safe,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:49,Modifiability,variab,variable,49,// The first field is a pointer to the annotated variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:144,Usability,simpl,simplifies,144,"// The current approach to inline asm is that ""r"" constraints are expressed; // as local indices, rather than values on the operand stack. This simplifies; // using ""r"" as it eliminates the need to push and pop the values in a; // particular order, however it also makes it impossible to have an ""m""; // constraint. So we don't support it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp:52,Testability,test,testing,52,// Option to disable EH pad first sorting. Only for testing unwind destination; // mismatches in CFGStackify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp:48,Deployability,update,update,48,"// Remember original layout ordering, so we can update terminators after; // reordering to point to the original layout successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp:490,Performance,queue,queues,490,"// Topological sort the CFG, with additional constraints:; // - Between a region header and the last block in the region, there can be; // no blocks not dominated by its header.; // - It's desirable to preserve the original block order when possible.; // We use two ready lists; Preferred and Ready. Preferred has recently; // processed successors, to help preserve block sequences from the original; // order. Ready has the remaining ready blocks. EH blocks are picked first; // from both queues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp:29,Testability,log,logic,29,// The main topological sort logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGSort.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Integrability,Wrap,Wrap-up,3,// Wrap-up,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:18,Modifiability,rewrite,rewriteDepthImmediates,18,"// Before running rewriteDepthImmediates function, 'delegate' has a BB as its; // destination operand. getFakeCallerBlock() returns a fake BB that will be; // used for the operand when 'delegate' needs to rethrow to the caller. This; // will be rewritten as an immediate value that is the number of block depths; // + 1 in rewriteDepthImmediates, and this fake BB will be removed at the end; // of the pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:323,Modifiability,rewrite,rewriteDepthImmediates,323,"// Before running rewriteDepthImmediates function, 'delegate' has a BB as its; // destination operand. getFakeCallerBlock() returns a fake BB that will be; // used for the operand when 'delegate' needs to rethrow to the caller. This; // will be rewritten as an immediate value that is the number of block depths; // + 1 in rewriteDepthImmediates, and this fake BB will be removed at the end; // of the pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:4,Testability,Test,Test,4,"/// Test whether Pred has any terminators explicitly branching to MBB, as; /// opposed to falling through. Note that it's possible (eg. in unoptimized; /// code) for a branch instruction to both branch to a block and fallthrough; /// to it, so we check the actual branch operands to see if there are any; /// explicit mentions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:320,Security,validat,validation,320,"// Returns an iterator to the earliest position possible within the MBB,; // satisfying the restrictions given by BeforeSet and AfterSet. BeforeSet; // contains instructions that should go before the marker, and AfterSet contains; // ones that should go after the marker. In this function, AfterSet is only; // used for validation checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Security,Validat,Validation,3,// Validation check,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:319,Security,validat,validation,319,"// Returns an iterator to the latest position possible within the MBB,; // satisfying the restrictions given by BeforeSet and AfterSet. BeforeSet; // contains instructions that should go before the marker, and AfterSet contains; // ones that should go after the marker. In this function, BeforeSet is only; // used for validation checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Security,Validat,Validation,3,// Validation check,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:165,Energy Efficiency,reduce,reduces,165,"// First compute the nearest common dominator of all forward non-fallthrough; // predecessors so that we minimize the time that the BLOCK is on the stack,; // which reduces overall stack height.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:39,Integrability,wrap,wrapped,39,// Possibly throwing calls are usually wrapped by EH_LABEL; // instructions. We don't want to split them and the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Integrability,Wrap,Wrap,3,// Wrap the given range of instruction with try-delegate. RangeBegin and; // RangeEnd are inclusive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:662,Availability,failure,failure,662,"// Linearizing the control flow by placing TRY / END_TRY markers can create; // mismatches in unwind destinations for throwing instructions, such as calls.; //; // We use the 'delegate' instruction to fix the unwind mismatches. 'delegate'; // instruction delegates an exception to an outer 'catch'. It can target not; // only 'catch' but all block-like structures including another 'delegate',; // but with slightly different semantics than branches. When it targets a; // 'catch', it will delegate the exception to that catch. It is being; // discussed how to define the semantics when 'delegate''s target is a non-try; // block: it will either be a validation failure or it will target the next; // outer try-catch. But anyway our LLVM backend currently does not generate; // such code. The example below illustrates where the 'delegate' instruction; // in the middle will delegate the exception to, depending on the value of N.; // try; // try; // block; // try; // try; // call @foo; // delegate N ;; Where will this delegate to?; // catch ;; N == 0; // end; // end ;; N == 1 (invalid; will not be generated); // delegate ;; N == 2; // catch ;; N == 3; // end; // ;; N == 4 (to caller); // 1. When an instruction may throw, but the EH pad it will unwind to can be; // different from the original CFG.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to bb3; // bb2 (ehpad):; // catch; // ...; // bb3 (ehpad); // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like: (BB markers are omitted); // try; // try; // call @foo; // call @bar ;; if it throws, unwind to bb3; // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-del",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:902,Integrability,depend,depending,902,"// Linearizing the control flow by placing TRY / END_TRY markers can create; // mismatches in unwind destinations for throwing instructions, such as calls.; //; // We use the 'delegate' instruction to fix the unwind mismatches. 'delegate'; // instruction delegates an exception to an outer 'catch'. It can target not; // only 'catch' but all block-like structures including another 'delegate',; // but with slightly different semantics than branches. When it targets a; // 'catch', it will delegate the exception to that catch. It is being; // discussed how to define the semantics when 'delegate''s target is a non-try; // block: it will either be a validation failure or it will target the next; // outer try-catch. But anyway our LLVM backend currently does not generate; // such code. The example below illustrates where the 'delegate' instruction; // in the middle will delegate the exception to, depending on the value of N.; // try; // try; // block; // try; // try; // call @foo; // delegate N ;; Where will this delegate to?; // catch ;; N == 0; // end; // end ;; N == 1 (invalid; will not be generated); // delegate ;; N == 2; // catch ;; N == 3; // end; // ;; N == 4 (to caller); // 1. When an instruction may throw, but the EH pad it will unwind to can be; // different from the original CFG.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to bb3; // bb2 (ehpad):; // catch; // ...; // bb3 (ehpad); // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like: (BB markers are omitted); // try; // try; // call @foo; // call @bar ;; if it throws, unwind to bb3; // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-del",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:1946,Integrability,wrap,wrapping,1946," delegate N ;; Where will this delegate to?; // catch ;; N == 0; // end; // end ;; N == 1 (invalid; will not be generated); // delegate ;; N == 2; // catch ;; N == 3; // end; // ;; N == 4 (to caller); // 1. When an instruction may throw, but the EH pad it will unwind to can be; // different from the original CFG.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to bb3; // bb2 (ehpad):; // catch; // ...; // bb3 (ehpad); // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like: (BB markers are omitted); // try; // try; // call @foo; // call @bar ;; if it throws, unwind to bb3; // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-delegate that rethrows the exception to the right; // 'catch'.; //; // try; // try; // call @foo; // try ;; (new); // call @bar; // delegate 1 (bb3) ;; (new); // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // ---; // 2. The same as 1, but in this case an instruction unwinds to a caller; // function and not another EH pad.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to caller; // bb2 (ehpad):; // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like:; // try; // call @foo; // call @bar ;; if it throws, unwind to caller; // catch ;; ehpad (bb2); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, when it is supposed; // throw up to the caller. We solve this problem in the same way, but in this; // case 'delegate's immediate argument is the number of ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3497,Integrability,wrap,wrapped,3497,";; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-delegate that rethrows the exception to the right; // 'catch'.; //; // try; // try; // call @foo; // try ;; (new); // call @bar; // delegate 1 (bb3) ;; (new); // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // ---; // 2. The same as 1, but in this case an instruction unwinds to a caller; // function and not another EH pad.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to caller; // bb2 (ehpad):; // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like:; // try; // call @foo; // call @bar ;; if it throws, unwind to caller; // catch ;; ehpad (bb2); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, when it is supposed; // throw up to the caller. We solve this problem in the same way, but in this; // case 'delegate's immediate argument is the number of block depths + 1,; // which means it rethrows to the caller.; // try; // call @foo; // try ;; (new); // call @bar; // delegate 1 (caller) ;; (new); // catch ;; ehpad (bb2); // ...; // end_try; //; // Before rewriteDepthImmediates, delegate's argument is a BB. In case of the; // caller, it will take a fake BB generated by getFakeCallerBlock(), which; // will be converted to a correct immediate argument later.; //; // In case there are multiple calls in a BB that may throw to the caller, they; // can be wrapped together in one nested try-delegate scope. (In 1, this; // couldn't happen, because may-throwing instruction there had an unwind; // destination, i.e., it was an invoke before, and there could be only one; // invoke within a BB.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3197,Modifiability,rewrite,rewriteDepthImmediates,3197,";; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-delegate that rethrows the exception to the right; // 'catch'.; //; // try; // try; // call @foo; // try ;; (new); // call @bar; // delegate 1 (bb3) ;; (new); // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // ---; // 2. The same as 1, but in this case an instruction unwinds to a caller; // function and not another EH pad.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to caller; // bb2 (ehpad):; // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like:; // try; // call @foo; // call @bar ;; if it throws, unwind to caller; // catch ;; ehpad (bb2); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, when it is supposed; // throw up to the caller. We solve this problem in the same way, but in this; // case 'delegate's immediate argument is the number of block depths + 1,; // which means it rethrows to the caller.; // try; // call @foo; // try ;; (new); // call @bar; // delegate 1 (caller) ;; (new); // catch ;; ehpad (bb2); // ...; // end_try; //; // Before rewriteDepthImmediates, delegate's argument is a BB. In case of the; // caller, it will take a fake BB generated by getFakeCallerBlock(), which; // will be converted to a correct immediate argument later.; //; // In case there are multiple calls in a BB that may throw to the caller, they; // can be wrapped together in one nested try-delegate scope. (In 1, this; // couldn't happen, because may-throwing instruction there had an unwind; // destination, i.e., it was an invoke before, and there could be only one; // invoke within a BB.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:651,Security,validat,validation,651,"// Linearizing the control flow by placing TRY / END_TRY markers can create; // mismatches in unwind destinations for throwing instructions, such as calls.; //; // We use the 'delegate' instruction to fix the unwind mismatches. 'delegate'; // instruction delegates an exception to an outer 'catch'. It can target not; // only 'catch' but all block-like structures including another 'delegate',; // but with slightly different semantics than branches. When it targets a; // 'catch', it will delegate the exception to that catch. It is being; // discussed how to define the semantics when 'delegate''s target is a non-try; // block: it will either be a validation failure or it will target the next; // outer try-catch. But anyway our LLVM backend currently does not generate; // such code. The example below illustrates where the 'delegate' instruction; // in the middle will delegate the exception to, depending on the value of N.; // try; // try; // block; // try; // try; // call @foo; // delegate N ;; Where will this delegate to?; // catch ;; N == 0; // end; // end ;; N == 1 (invalid; will not be generated); // delegate ;; N == 2; // catch ;; N == 3; // end; // ;; N == 4 (to caller); // 1. When an instruction may throw, but the EH pad it will unwind to can be; // different from the original CFG.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to bb3; // bb2 (ehpad):; // catch; // ...; // bb3 (ehpad); // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like: (BB markers are omitted); // try; // try; // call @foo; // call @bar ;; if it throws, unwind to bb3; // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-del",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:30,Integrability,wrap,wrapped,30,// Range of intructions to be wrapped in a new nested try/catch. A range; // exists in a single BB and does not span multiple BBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:6,Integrability,wrap,wrap,6,// We wrap up the current range when we see a marker even if we haven't; // finished a BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Deployability,Update,Update,3,// Update EHPadStack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:32,Integrability,wrap,wrapping,32,// Now we fix the mismatches by wrapping calls with inner try-delegates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:92,Integrability,wrap,wrap,92,"// If this BB has an EH pad successor, i.e., ends with an 'invoke', now we; // are going to wrap the invoke with try-delegate, making the 'delegate'; // BB the new successor instead, so remove the EH pad succesor here. The; // BB may not have an EH pad successor if calls in this BB throw to the; // caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:982,Integrability,wrap,wrap,982,"// There is another kind of unwind destination mismatches besides call unwind; // mismatches, which we will call ""catch unwind mismatches"". See this example; // after the marker placement:; // try; // try; // call @foo; // catch __cpp_exception ;; ehpad A (next unwind dest: caller); // ...; // end_try; // catch_all ;; ehpad B; // ...; // end_try; //; // 'call @foo's unwind destination is the ehpad A. But suppose 'call @foo'; // throws a foreign exception that is not caught by ehpad A, and its next; // destination should be the caller. But after control flow linearization,; // another EH pad can be placed in between (e.g. ehpad B here), making the; // next unwind destination incorrect. In this case, the foreign exception; // will instead go to ehpad B and will be caught there instead. In this; // example the correct next unwind destination is the caller, but it can be; // another outer catch in other cases.; //; // There is no specific 'call' or 'throw' instruction to wrap with a; // try-delegate, so we wrap the whole try-catch-end with a try-delegate and; // make it rethrow to the right destination, as in the example below:; // try; // try ;; (new); // try; // call @foo; // catch __cpp_exception ;; ehpad A (next unwind dest: caller); // ...; // end_try; // delegate 1 (caller) ;; (new); // catch_all ;; ehpad B; // ...; // end_try",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:1018,Integrability,wrap,wrap,1018,"// There is another kind of unwind destination mismatches besides call unwind; // mismatches, which we will call ""catch unwind mismatches"". See this example; // after the marker placement:; // try; // try; // call @foo; // catch __cpp_exception ;; ehpad A (next unwind dest: caller); // ...; // end_try; // catch_all ;; ehpad B; // ...; // end_try; //; // 'call @foo's unwind destination is the ehpad A. But suppose 'call @foo'; // throws a foreign exception that is not caught by ehpad A, and its next; // destination should be the caller. But after control flow linearization,; // another EH pad can be placed in between (e.g. ehpad B here), making the; // next unwind destination incorrect. In this case, the foreign exception; // will instead go to ehpad B and will be caught there instead. In this; // example the correct next unwind destination is the caller, but it can be; // another outer catch in other cases.; //; // There is no specific 'call' or 'throw' instruction to wrap with a; // try-delegate, so we wrap the whole try-catch-end with a try-delegate and; // make it rethrow to the right destination, as in the example below:; // try; // try ;; (new); // try; // call @foo; // catch __cpp_exception ;; ehpad A (next unwind dest: caller); // ...; // end_try; // delegate 1 (caller) ;; (new); // catch_all ;; ehpad B; // ...; // end_try",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:67,Performance,optimiz,optimization,67,"// This can happen when the unwind dest was removed during the; // optimization, e.g. because it was unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:25,Integrability,wrap,wrapping,25,"// Adding a try-delegate wrapping an existing try-catch-end can make existing; // branch destination BBs invalid. For example,; //; // - Before:; // bb0:; // block; // br bb3; // bb1:; // try; // ...; // bb2: (ehpad); // catch; // bb3:; // end_try; // end_block ;; 'br bb3' targets here; //; // Suppose this try-catch-end has a catch unwind mismatch, so we need to wrap; // this with a try-delegate. Then this becomes:; //; // - After:; // bb0:; // block; // br bb3 ;; invalid destination!; // bb1:; // try ;; (new instruction); // try; // ...; // bb2: (ehpad); // catch; // bb3:; // end_try ;; 'br bb3' still incorrectly targets here!; // delegate_bb: ;; (new BB); // delegate ;; (new instruction); // split_bb: ;; (new BB); // end_block; //; // Now 'br bb3' incorrectly branches to an inner scope.; //; // As we can see in this case, when branches target a BB that has both; // 'end_try' and 'end_block' and the BB is split to insert a 'delegate', we; // have to remap existing branch destinations so that they target not the; // 'end_try' BB but the new 'end_block' BB. There can be multiple 'delegate's; // in between, so we try to find the next BB with 'end_block' instruction. In; // this example, the 'br bb3' instruction should be remapped to 'br split_bb'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:365,Integrability,wrap,wrap,365,"// Adding a try-delegate wrapping an existing try-catch-end can make existing; // branch destination BBs invalid. For example,; //; // - Before:; // bb0:; // block; // br bb3; // bb1:; // try; // ...; // bb2: (ehpad); // catch; // bb3:; // end_try; // end_block ;; 'br bb3' targets here; //; // Suppose this try-catch-end has a catch unwind mismatch, so we need to wrap; // this with a try-delegate. Then this becomes:; //; // - After:; // bb0:; // block; // br bb3 ;; invalid destination!; // bb1:; // try ;; (new instruction); // try; // ...; // bb2: (ehpad); // catch; // bb3:; // end_try ;; 'br bb3' still incorrectly targets here!; // delegate_bb: ;; (new BB); // delegate ;; (new instruction); // split_bb: ;; (new BB); // end_block; //; // Now 'br bb3' incorrectly branches to an inner scope.; //; // As we can see in this case, when branches target a BB that has both; // 'end_try' and 'end_block' and the BB is split to insert a 'delegate', we; // have to remap existing branch destinations so that they target not the; // 'end_try' BB but the new 'end_block' BB. There can be multiple 'delegate's; // in between, so we try to find the next BB with 'end_block' instruction. In; // this example, the 'br bb3' instruction should be remapped to 'br split_bb'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:6,Energy Efficiency,allocate,allocate,6,// We allocate one more than the number of blocks in the function to; // accommodate for the possible fake block we may insert at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:7,Modifiability,rewrite,rewrite,7,// Now rewrite references to basic blocks to be depth immediates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:91,Modifiability,rewrite,rewrite,91,"// We handle DELEGATE in the default level, because DELEGATE has; // immediate operands to rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite MBB operands to be depth immediates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:39,Deployability,pipeline,pipeline,39,"// At this very end of the compilation pipeline, if any DBG_VALUEs with; // registers remain, it means they are dangling info which we failed to update; // when their corresponding def instruction was transformed/moved/splitted etc.; // Because Wasm cannot access values in LLVM virtual registers in the debugger,; // these dangling DBG_VALUEs in effect kill the effect of any previous DBG_VALUE; // associated with the variable, which will appear as ""optimized out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:145,Deployability,update,update,145,"// At this very end of the compilation pipeline, if any DBG_VALUEs with; // registers remain, it means they are dangling info which we failed to update; // when their corresponding def instruction was transformed/moved/splitted etc.; // Because Wasm cannot access values in LLVM virtual registers in the debugger,; // these dangling DBG_VALUEs in effect kill the effect of any previous DBG_VALUE; // associated with the variable, which will appear as ""optimized out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:420,Modifiability,variab,variable,420,"// At this very end of the compilation pipeline, if any DBG_VALUEs with; // registers remain, it means they are dangling info which we failed to update; // when their corresponding def instruction was transformed/moved/splitted etc.; // Because Wasm cannot access values in LLVM virtual registers in the debugger,; // these dangling DBG_VALUEs in effect kill the effect of any previous DBG_VALUE; // associated with the variable, which will appear as ""optimized out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:452,Performance,optimiz,optimized,452,"// At this very end of the compilation pipeline, if any DBG_VALUEs with; // registers remain, it means they are dangling info which we failed to update; // when their corresponding def instruction was transformed/moved/splitted etc.; // Because Wasm cannot access values in LLVM virtual registers in the debugger,; // these dangling DBG_VALUEs in effect kill the effect of any previous DBG_VALUE; // associated with the variable, which will appear as ""optimized out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:257,Security,access,access,257,"// At this very end of the compilation pipeline, if any DBG_VALUEs with; // registers remain, it means they are dangling info which we failed to update; // when their corresponding def instruction was transformed/moved/splitted etc.; // Because Wasm cannot access values in LLVM virtual registers in the debugger,; // these dangling DBG_VALUEs in effect kill the effect of any previous DBG_VALUE; // associated with the variable, which will appear as ""optimized out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:67,Modifiability,variab,variable,67,// Save the DBG_VALUE instruction that defined this stackified; // variable since later we need it to construct another one on; // pop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:28,Modifiability,variab,variable,28,"// This stackified reg is a variable that started life at; // Prev.DebugValue, so now that we're popping it we must insert; // a $noreg DBG_VALUE for the variable to end it, right after; // the current instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp:154,Modifiability,variab,variable,154,"// This stackified reg is a variable that started life at; // Prev.DebugValue, so now that we're popping it we must insert; // a $noreg DBG_VALUE for the variable to end it, right after; // the current instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:100,Usability,simpl,simple,100,"// Def and Insert are in different BBs; // If Def and Insert are in different BBs, we only handle a simple case in; // which Insert's BB is a successor of Def's BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:453,Deployability,update,updated,453,"// Sink 'Def', and also sink its eligible DBG_VALUEs to the place before; // 'Insert'. Convert the original DBG_VALUEs into undefs.; //; // For DBG_VALUEs to sink properly, if 'Def' and 'Insert' are within the same; // BB, 'Insert' should be below 'Def'; if they are in different BBs, 'Insert'; // should be in one of 'Def's BBs successors. Def will be sunk regardless of the; // location.; //; // This DebugValueManager's new Def and DbgValues will be updated to the newly; // sinked Def + DBG_VALUEs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:717,Deployability,update,updated,717,"// When sinking a Def and its DBG_VALUEs, we shouldn't just remove the; // original DBG_VALUE instructions; we should set them to undef not to create; // an impossible combination of variable assignments in the original program.; // For example, this is the original program in order:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 2, b = 3; //; // If %2 were to sink below %3, if we just sink DBG_VALUE %1 with it, the; // debug info will show the variable ""b"" is updated to 2, creating the; // variable assignment combination of (a = 0, b = 3), which is not possible in; // the original program:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 0, b = 3 (Incorrect!); // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; //; // To fix this,we leave an undef DBG_VALUE in its original place, so that the; // result will be; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // DBG_VALUE $noreg, !""a"", !DIExpression() // a = ?, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = ?, b = 3; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; // Now in the middle ""a"" will be shown as ""optimized out"", but it wouldn't; // show the impossible combination of (a = 0, b = 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:183,Modifiability,variab,variable,183,"// When sinking a Def and its DBG_VALUEs, we shouldn't just remove the; // original DBG_VALUE instructions; we should set them to undef not to create; // an impossible combination of variable assignments in the original program.; // For example, this is the original program in order:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 2, b = 3; //; // If %2 were to sink below %3, if we just sink DBG_VALUE %1 with it, the; // debug info will show the variable ""b"" is updated to 2, creating the; // variable assignment combination of (a = 0, b = 3), which is not possible in; // the original program:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 0, b = 3 (Incorrect!); // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; //; // To fix this,we leave an undef DBG_VALUE in its original place, so that the; // result will be; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // DBG_VALUE $noreg, !""a"", !DIExpression() // a = ?, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = ?, b = 3; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; // Now in the middle ""a"" will be shown as ""optimized out"", but it wouldn't; // show the impossible combination of (a = 0, b = 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:701,Modifiability,variab,variable,701,"// When sinking a Def and its DBG_VALUEs, we shouldn't just remove the; // original DBG_VALUE instructions; we should set them to undef not to create; // an impossible combination of variable assignments in the original program.; // For example, this is the original program in order:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 2, b = 3; //; // If %2 were to sink below %3, if we just sink DBG_VALUE %1 with it, the; // debug info will show the variable ""b"" is updated to 2, creating the; // variable assignment combination of (a = 0, b = 3), which is not possible in; // the original program:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 0, b = 3 (Incorrect!); // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; //; // To fix this,we leave an undef DBG_VALUE in its original place, so that the; // result will be; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // DBG_VALUE $noreg, !""a"", !DIExpression() // a = ?, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = ?, b = 3; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; // Now in the middle ""a"" will be shown as ""optimized out"", but it wouldn't; // show the impossible combination of (a = 0, b = 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:748,Modifiability,variab,variable,748,"// When sinking a Def and its DBG_VALUEs, we shouldn't just remove the; // original DBG_VALUE instructions; we should set them to undef not to create; // an impossible combination of variable assignments in the original program.; // For example, this is the original program in order:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 2, b = 3; //; // If %2 were to sink below %3, if we just sink DBG_VALUE %1 with it, the; // debug info will show the variable ""b"" is updated to 2, creating the; // variable assignment combination of (a = 0, b = 3), which is not possible in; // the original program:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 0, b = 3 (Incorrect!); // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; //; // To fix this,we leave an undef DBG_VALUE in its original place, so that the; // result will be; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // DBG_VALUE $noreg, !""a"", !DIExpression() // a = ?, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = ?, b = 3; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; // Now in the middle ""a"" will be shown as ""optimized out"", but it wouldn't; // show the impossible combination of (a = 0, b = 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:1685,Performance,optimiz,optimized,1685,"// When sinking a Def and its DBG_VALUEs, we shouldn't just remove the; // original DBG_VALUE instructions; we should set them to undef not to create; // an impossible combination of variable assignments in the original program.; // For example, this is the original program in order:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 2, b = 3; //; // If %2 were to sink below %3, if we just sink DBG_VALUE %1 with it, the; // debug info will show the variable ""b"" is updated to 2, creating the; // variable assignment combination of (a = 0, b = 3), which is not possible in; // the original program:; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = 0, b = 3 (Incorrect!); // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; //; // To fix this,we leave an undef DBG_VALUE in its original place, so that the; // result will be; // %0 = CONST_I32 0; // DBG_VALUE %0, !""a"", !DIExpression() // a = 0, b = ?; // %1 = CONST_I32 1; // DBG_VALUE %1, !""b"", !DIExpression() // a = 0, b = 1; // DBG_VALUE $noreg, !""a"", !DIExpression() // a = ?, b = 1; // %3 = CONST_I32 3; // DBG_VALUE %3, !""b"", !DIExpression() // a = ?, b = 3; // %2 = CONST_I32 2; // DBG_VALUE %2, !""a"", !DIExpression() // a = 2, b = 3; // Now in the middle ""a"" will be shown as ""optimized out"", but it wouldn't; // show the impossible combination of (a = 0, b = 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:3,Deployability,Update,Update,3,// Update the register for Def and DBG_VALUEs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.h:3,Deployability,Update,Update,3,// Update the register for Def and DBG_VALUEs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyDebugValueManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp:315,Usability,intuit,intuitive,315,"// WasmEHFuncInfo contains a map of <catchpad, its next unwind destination>,; // which means, if an exception is not caught by the catchpad, it should end; // up in the next unwind destination stored in this data structure. (It is; // written as catchswitch's 'unwind' destination in ll files.) The below is an; // intuitive example of their relationship in C++ code:; // try {; // try {; // } catch (int) { // catchpad; // ... // this catch (int) { ... } is grouped as an exception; // }; // } catch (...) { // next unwind destination; // }; // (The example is try-catches for illustration purpose, but the unwind; // destination can be also a cleanuppad generated by destructor calls.) So the; // unwind destination is in the outside of the catchpad's exception.; //; // We group exceptions in this analysis simply by including all BBs dominated; // by an EH pad. But in case the EH pad's unwind destination does not have any; // children outside of the exception, that unwind destination ends up also; // being dominated by the EH pad and included in the exception, which is not; // semantically correct, because it unwinds/rethrows into an inner scope.; //; // Here we extract those unwind destinations from their (incorrect) parent; // exception. Note that the unwind destinations may not be an immediate; // children of the parent exception, so we have to traverse the parent chain.; //; // We should traverse BBs in the preorder of the dominator tree, because; // otherwise the result can be incorrect. For example, when there are three; // exceptions A, B, and C and A > B > C (> is subexception relationship here),; // and A's unwind destination is B and B's is C. When we visit B before A, we; // end up extracting C only out of B but not out of A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp:810,Usability,simpl,simply,810,"// WasmEHFuncInfo contains a map of <catchpad, its next unwind destination>,; // which means, if an exception is not caught by the catchpad, it should end; // up in the next unwind destination stored in this data structure. (It is; // written as catchswitch's 'unwind' destination in ll files.) The below is an; // intuitive example of their relationship in C++ code:; // try {; // try {; // } catch (int) { // catchpad; // ... // this catch (int) { ... } is grouped as an exception; // }; // } catch (...) { // next unwind destination; // }; // (The example is try-catches for illustration purpose, but the unwind; // destination can be also a cleanuppad generated by destructor calls.) So the; // unwind destination is in the outside of the catchpad's exception.; //; // We group exceptions in this analysis simply by including all BBs dominated; // by an EH pad. But in case the EH pad's unwind destination does not have any; // children outside of the exception, that unwind destination ends up also; // being dominated by the EH pad and included in the exception, which is not; // semantically correct, because it unwinds/rethrows into an inner scope.; //; // Here we extract those unwind destinations from their (incorrect) parent; // exception. Note that the unwind destinations may not be an immediate; // children of the parent exception, so we have to traverse the parent chain.; //; // We should traverse BBs in the preorder of the dominator tree, because; // otherwise the result can be incorrect. For example, when there are three; // exceptions A, B, and C and A > B > C (> is subexception relationship here),; // and A's unwind destination is B and B's is C. When we visit B before A, we; // end up extracting C only out of B but not out of A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp:3,Deployability,Update,Update,3,// Update debug value to point to the local before removing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp:64,Integrability,contract,contract,64,// Inline asm may have a def in the middle of the operands. Our contract; // with inline asm register operands is to provide local indices as; // immediates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp:7,Integrability,contract,contract,7,// Our contract with inline asm register operands is to provide local; // indices as immediates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp:193,Modifiability,variab,variables,193,"// Use a InsertPt as our DebugLoc, since MI may be discontinuous from; // the where this local is being inserted, causing non-linear stepping; // in the debugger or function entry points where variables aren't live; // yet. Alternative is previous instruction, but that is strictly worse; // since it can point at the previous statement.; // See crbug.com/1251909, crbug.com/1249745",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp:3,Testability,Assert,Assert,3,// Assert that all registers have been stackified at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:18,Integrability,rout,routines,18,// Utility helper routines,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:13,Integrability,rout,routines,13,// Selection routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:25,Integrability,wrap,wrap,25,// Non-inbounds geps can wrap; wasm's offsets can't.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:53,Availability,mask,mask,53,"// If the value is naturally an i1, we don't need to mask it. We only know; // if a value is naturally an i1 if it is definitely lowered by FastISel,; // not a DAG ISel fallback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:37,Modifiability,extend,extend,37,// TODO: Fold a following sign-/zero-extend into the load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:53,Performance,load,load,53,// TODO: Fold a following sign-/zero-extend into the load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:435,Availability,redundant,redundant,435,"//=- WebAssemblyFixBrTableDefaults.cpp - Fix br_table default branch targets -//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This file implements a pass that eliminates redundant range checks; /// guarding br_table instructions. Since jump tables on most targets cannot; /// handle out of range indices, LLVM emits these checks before most jump; /// tables. But br_table takes a default branch target as an argument, so it; /// does not need the range checks.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:435,Safety,redund,redundant,435,"//=- WebAssemblyFixBrTableDefaults.cpp - Fix br_table default branch targets -//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This file implements a pass that eliminates redundant range checks; /// guarding br_table instructions. Since jump tables on most targets cannot; /// handle out of range indices, LLVM emits these checks before most jump; /// tables. But br_table takes a default branch target as an argument, so it; /// does not need the range checks.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:17,Modifiability,extend,extending,17,"// Unnecessarily extending a 32-bit value to 64, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:20,Modifiability,extend,extend,20,"// No more users of extend, delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:149,Availability,redundant,redundant,149,"// `MI` is a br_table instruction with a dummy default target argument. This; // function finds and adds the default target argument and removes any redundant; // range check preceding the br_table. Returns the MBB that the br_table is; // moved into so it can be removed from further consideration, or nullptr if the; // br_table cannot be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:341,Performance,optimiz,optimized,341,"// `MI` is a br_table instruction with a dummy default target argument. This; // function finds and adds the default target argument and removes any redundant; // range check preceding the br_table. Returns the MBB that the br_table is; // moved into so it can be removed from further consideration, or nullptr if the; // br_table cannot be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:149,Safety,redund,redundant,149,"// `MI` is a br_table instruction with a dummy default target argument. This; // function finds and adds the default target argument and removes any redundant; // range check preceding the br_table. Returns the MBB that the br_table is; // moved into so it can be removed from further consideration, or nullptr if the; // br_table cannot be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:44,Availability,redundant,redundant,44,"// Get the header block, which contains the redundant range check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:44,Safety,redund,redundant,44,"// Get the header block, which contains the redundant range check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:53,Performance,optimiz,optimize,53,"// If the range check checks an i64 value, we cannot optimize it out because; // the i64 index is truncated to an i32, making values over 2^32; // indistinguishable from small numbers. There are also other strange edge; // cases that can arise in practice that we don't want to reason about, so; // conservatively only perform the optimization if the range check is the; // normal case of an i32.gt_u.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:319,Performance,perform,perform,319,"// If the range check checks an i64 value, we cannot optimize it out because; // the i64 index is truncated to an i32, making values over 2^32; // indistinguishable from small numbers. There are also other strange edge; // cases that can arise in practice that we don't want to reason about, so; // conservatively only perform the optimization if the range check is the; // normal case of an i32.gt_u.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:331,Performance,optimiz,optimization,331,"// If the range check checks an i64 value, we cannot optimize it out because; // the i64 index is truncated to an i32, making values over 2^32; // indistinguishable from small numbers. There are also other strange edge; // cases that can arise in practice that we don't want to reason about, so; // conservatively only perform the optimization if the range check is the; // normal case of an i32.gt_u.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:39,Deployability,install,install,39,// Remove the dummy default target and install the real one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:3,Deployability,Update,Update,3,// Update CFG to skip the old jump table block. Remove shared successors; // before transferring to avoid duplicated successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:100,Safety,avoid,avoid,100,// Update CFG to skip the old jump table block. Remove shared successors; // before transferring to avoid duplicated successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:637,Integrability,wrap,wrapper,637,"//===-- WebAssemblyFixFunctionBitcasts.cpp - Fix function bitcasts --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Fix bitcasted functions.; ///; /// WebAssembly requires caller and callee signatures to match, however in LLVM,; /// some amount of slop is vaguely permitted. Detect mismatch by looking for; /// bitcasts of functions and rewrite them to use wrapper functions instead.; ///; /// This doesn't catch all cases, such as when a function's address is taken in; /// one place and casted in another, but it works for many common cases.; ///; /// Note that LLVM already optimizes away function bitcasts in common cases by; /// dropping arguments as needed, so this pass only ends up getting used in less; /// common cases.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:617,Modifiability,rewrite,rewrite,617,"//===-- WebAssemblyFixFunctionBitcasts.cpp - Fix function bitcasts --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Fix bitcasted functions.; ///; /// WebAssembly requires caller and callee signatures to match, however in LLVM,; /// some amount of slop is vaguely permitted. Detect mismatch by looking for; /// bitcasts of functions and rewrite them to use wrapper functions instead.; ///; /// This doesn't catch all cases, such as when a function's address is taken in; /// one place and casted in another, but it works for many common cases.; ///; /// Note that LLVM already optimizes away function bitcasts in common cases by; /// dropping arguments as needed, so this pass only ends up getting used in less; /// common cases.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:857,Performance,optimiz,optimizes,857,"//===-- WebAssemblyFixFunctionBitcasts.cpp - Fix function bitcasts --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Fix bitcasted functions.; ///; /// WebAssembly requires caller and callee signatures to match, however in LLVM,; /// some amount of slop is vaguely permitted. Detect mismatch by looking for; /// bitcasts of functions and rewrite them to use wrapper functions instead.; ///; /// This doesn't catch all cases, such as when a function's address is taken in; /// one place and casted in another, but it works for many common cases.; ///; /// Note that LLVM already optimizes away function bitcasts in common cases by; /// dropping arguments as needed, so this pass only ends up getting used in less; /// common cases.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:555,Safety,Detect,Detect,555,"//===-- WebAssemblyFixFunctionBitcasts.cpp - Fix function bitcasts --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Fix bitcasted functions.; ///; /// WebAssembly requires caller and callee signatures to match, however in LLVM,; /// some amount of slop is vaguely permitted. Detect mismatch by looking for; /// bitcasts of functions and rewrite them to use wrapper functions instead.; ///; /// This doesn't catch all cases, such as when a function's address is taken in; /// one place and casted in another, but it works for many common cases.; ///; /// Note that LLVM already optimizes away function bitcasts in common cases by; /// dropping arguments as needed, so this pass only ends up getting used in less; /// common cases.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:927,Availability,error,error,927,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:12,Integrability,wrap,wrapper,12,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:523,Integrability,wrap,wrapper,523,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:674,Integrability,wrap,wrapper,674,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:1342,Integrability,wrap,wrapper,1342,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:714,Safety,abort,abort,714,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:1114,Safety,detect,detects,1114,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:16,Integrability,wrap,wrapper,16,// Create a new wrapper that simply contains `unreachable`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:29,Usability,simpl,simply,29,// Create a new wrapper that simply contains `unreachable`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:3,Testability,Test,Test,3,// Test whether a main function with type FuncTy should be rewritten to have; // type MainTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:36,Integrability,wrap,wrappers,36,// Collect all the places that need wrappers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:175,Integrability,wrap,wrapper,175,"// If we have a ""main"" function, and its type isn't; // ""int main(int argc, char *argv[])"", create an artificial call with it; // bitcasted to that type so that we generate a wrapper for it, so that; // the C runtime can call it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:19,Integrability,wrap,wrapper,19,"// If we created a wrapper for main, rename the wrapper so that it's the; // one that gets called from startup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:48,Integrability,wrap,wrapper,48,"// If we created a wrapper for main, rename the wrapper so that it's the; // one that gets called from startup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:7,Integrability,wrap,wrapper,7,// The wrapper is not needed in this case as we don't need to export; // it to anyone else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:22,Integrability,wrap,wrapper,22,"// Otherwise give the wrapper the same linkage as the original main; // function, so that it can be called from the same places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:1257,Modifiability,variab,variable,1257,"Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a pass that removes irreducible control flow.; /// Irreducible control flow means multiple-entry loops, which this pass; /// transforms to have a single entry.; ///; /// Note that LLVM has a generic pass that lowers irreducible control flow, but; /// it linearizes control flow, turning diamonds into two triangles, which is; /// both unnecessary and undesirable for WebAssembly.; ///; /// The big picture: We recursively process each ""region"", defined as a group; /// of blocks with a single entry and no branches back to that entry. A region; /// may be the entire function body, or the inner part of a loop, i.e., the; /// loop's body without branches back to the loop entry. In each region we fix; /// up multi-entry loops by adding a new block that can dispatch to each of the; /// loop entries, based on the value of a label ""helper"" variable, and we; /// replace direct branches to the entries with assignments to the label; /// variable and a branch to the dispatch block. Then the dispatch block is the; /// single entry in the loop containing the previous multiple entries. After; /// ensuring all the loops in a region are reducible, we recurse into them. The; /// total time complexity of this pass is:; ///; /// O(NumBlocks * NumNestedLoops * NumIrreducibleLoops +; /// NumLoops * NumLoops); ///; /// This pass is similar to what the Relooper [1] does. Both identify looping; /// code that requires multiple entries, and resolve it in a similar way (in; /// Relooper terminology, we implement a Multiple shape in a Loop shape). Note; /// also that like the Relooper, we implement a ""minimal"" intervention: we only; /// use the ""label"" helper for the blocks we absolutely must and no others. We; /// also prioritize code size and do not duplicate code in order to resolve; /// irreducibility. The graph algorithms for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:1353,Modifiability,variab,variable,1353,"Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a pass that removes irreducible control flow.; /// Irreducible control flow means multiple-entry loops, which this pass; /// transforms to have a single entry.; ///; /// Note that LLVM has a generic pass that lowers irreducible control flow, but; /// it linearizes control flow, turning diamonds into two triangles, which is; /// both unnecessary and undesirable for WebAssembly.; ///; /// The big picture: We recursively process each ""region"", defined as a group; /// of blocks with a single entry and no branches back to that entry. A region; /// may be the entire function body, or the inner part of a loop, i.e., the; /// loop's body without branches back to the loop entry. In each region we fix; /// up multi-entry loops by adding a new block that can dispatch to each of the; /// loop entries, based on the value of a label ""helper"" variable, and we; /// replace direct branches to the entries with assignments to the label; /// variable and a branch to the dispatch block. Then the dispatch block is the; /// single entry in the loop containing the previous multiple entries. After; /// ensuring all the loops in a region are reducible, we recurse into them. The; /// total time complexity of this pass is:; ///; /// O(NumBlocks * NumNestedLoops * NumIrreducibleLoops +; /// NumLoops * NumLoops); ///; /// This pass is similar to what the Relooper [1] does. Both identify looping; /// code that requires multiple entries, and resolve it in a similar way (in; /// Relooper terminology, we implement a Multiple shape in a Loop shape). Note; /// also that like the Relooper, we implement a ""minimal"" intervention: we only; /// use the ""label"" helper for the blocks we absolutely must and no others. We; /// also prioritize code size and do not duplicate code in order to resolve; /// irreducibility. The graph algorithms for",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:47,Safety,detect,detect,47,"// ""Loopers"" are blocks that are in a loop. We detect these by finding blocks; // that can reach themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:197,Safety,avoid,avoid,197,"// Only go on to actually process the inner loops when we are done; // removing irreducible control flow and changing the graph. Modifying; // the graph as we go is possible, and that might let us avoid looking at; // the already-fixed loops again if we are careful, but all that is; // complex and bug-prone. Since irreducible loops are rare, just starting; // another iteration is best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:178,Deployability,update,updates,178,"// Given a set of entries to a single loop, create a single entry for that; // loop by creating a dispatch block for them, routing control flow using; // a helper variable. Also updates Blocks with any new blocks created, so; // that we properly track all the blocks in the region. But this does not update; // ReachabilityGraph; this will be updated in the caller of this function as; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:300,Deployability,update,update,300,"// Given a set of entries to a single loop, create a single entry for that; // loop by creating a dispatch block for them, routing control flow using; // a helper variable. Also updates Blocks with any new blocks created, so; // that we properly track all the blocks in the region. But this does not update; // ReachabilityGraph; this will be updated in the caller of this function as; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:343,Deployability,update,updated,343,"// Given a set of entries to a single loop, create a single entry for that; // loop by creating a dispatch block for them, routing control flow using; // a helper variable. Also updates Blocks with any new blocks created, so; // that we properly track all the blocks in the region. But this does not update; // ReachabilityGraph; this will be updated in the caller of this function as; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:123,Integrability,rout,routing,123,"// Given a set of entries to a single loop, create a single entry for that; // loop by creating a dispatch block for them, routing control flow using; // a helper variable. Also updates Blocks with any new blocks created, so; // that we properly track all the blocks in the region. But this does not update; // ReachabilityGraph; this will be updated in the caller of this function as; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:163,Modifiability,variab,variable,163,"// Given a set of entries to a single loop, create a single entry for that; // loop by creating a dispatch block for them, routing control flow using; // a helper variable. Also updates Blocks with any new blocks created, so; // that we properly track all the blocks in the region. But this does not update; // ReachabilityGraph; this will be updated in the caller of this function as; // needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the problematic successors for every block that wants to reach; // the bad blocks. For simplicity, we just introduce a new block for every; // edge we need to rewrite. (Fancier things are possible.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:170,Modifiability,rewrite,rewrite,170,"// Rewrite the problematic successors for every block that wants to reach; // the bad blocks. For simplicity, we just introduce a new block for every; // edge we need to rewrite. (Fancier things are possible.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:98,Usability,simpl,simplicity,98,"// Rewrite the problematic successors for every block that wants to reach; // the bad blocks. For simplicity, we just introduce a new block for every; // edge we need to rewrite. (Fancier things are possible.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:33,Integrability,rout,routing,33,"// We need to create at most two routing blocks per entry: one for; // predecessors outside the loop and one for predecessors inside the loop.; // This map stores; // <<loop entry, Predecessor is within the loop?>, routing block>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:215,Integrability,rout,routing,215,"// We need to create at most two routing blocks per entry: one for; // predecessors outside the loop and one for predecessors inside the loop.; // This map stores; // <<loop entry, Predecessor is within the loop?>, routing block>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:111,Integrability,rout,routing,111,"// If there exists a layout predecessor of this entry and this predecessor; // is not that, we rather create a routing block after that layout; // predecessor to save a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:34,Modifiability,rewrite,rewrite,34,// This is a successor we need to rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:3,Testability,Test,Test,3,// Test whether the given register has an ARGUMENT def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:475,Usability,simpl,simple,475,"// Now we've inserted dispatch blocks, some register uses can have incoming; // paths without a def. For example, before this pass register %a was; // defined in BB1 and used in BB2, and there was only one path from BB1 and; // BB2. But if this pass inserts a dispatch block having multiple; // predecessors between the two BBs, now there are paths to BB2 without; // visiting BB1, and %a's use in BB2 is not dominated by its def. Adding; // IMPLICIT_DEFs to all regs is one simple way to fix it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:644,Availability,down,downward,644,"//===-- WebAssemblyFrameLowering.cpp - WebAssembly Frame Lowering ----------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the WebAssembly implementation of; /// TargetFrameLowering class.; ///; /// On WebAssembly, there aren't a lot of things to do here. There are no; /// callee-saved registers to save, and no spill slots.; ///; /// The stack grows downward.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:10,Energy Efficiency,allocate,allocated,10,"// If not allocated in the object address space, this object will be in; // linear memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:14,Energy Efficiency,allocate,allocate,14,"// Otherwise, allocate this object in the named value stack, outside of linear; // memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate WebAssembly locals for each non-aggregate component of the; // allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:60,Energy Efficiency,allocate,allocated,60,// Abuse object size to record number of WebAssembly locals allocated to; // this object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:156,Modifiability,variab,variable,156,"/// Returns true if this function needs a local user-space stack pointer.; /// Unlike a machine stack pointer, the wasm user stack pointer is a global; /// variable, so it is loaded into a register in the prolog.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:175,Performance,load,loaded,175,"/// Returns true if this function needs a local user-space stack pointer.; /// Unlike a machine stack pointer, the wasm user stack pointer is a global; /// variable, so it is loaded into a register in the prolog.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:164,Availability,down,down,164,"// When we don't need a local stack pointer for its local frame but only to; // support EH, we don't need to write SP back in the epilog, because we don't; // bump down the stack pointer in the prolog. We need to write SP back in the; // epilog only if; // 1. We need SP not only for EH support but also because we actually use; // stack or we have a frame address taken.; // 2. We cannot use the red zone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:163,Performance,load,load,163,"// Unlike most conventional targets (where FP points to the saved FP),; // FP points to the bottom of the fixed-size locals, so we can use positive; // offsets in load/store instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:65,Security,access,accessed,65,"// Use the Object stack for WebAssembly locals which can only be accessed; // by name, not via an address in linear memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.h:103,Energy Efficiency,allocate,allocated,103,"// Returns the index of the WebAssembly local to which the stack object; // FrameIndex in MF should be allocated, or std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:6,Security,access,access,6,// To access function attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:32,Energy Efficiency,allocate,allocated,32,"// Stack objects that should be allocated to locals are hoisted to WebAssembly; // locals when they are first used. However for those without uses, we hoist; // them here. It would be nice if there were some hook to do this when they; // are added to the MachineFrameInfo, but that's not the case right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:17,Modifiability,variab,variable,17,"// CALL has both variable operands and variable results, but ISel only; // supports one or the other. Split calls into two nodes glued together, one; // for the operands and one for the results. These two nodes will be; // recombined in a custom inserter hook into a single MachineInstr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:39,Modifiability,variab,variable,39,"// CALL has both variable operands and variable results, but ISel only; // supports one or the other. Split calls into two nodes glued together, one; // for the operands and one for the results. These two nodes will be; // recombined in a custom inserter hook into a single MachineInstr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:14,Integrability,wrap,wrapper,14,"// Remove the wrapper when the call target is a function, an external; // symbol (which will be lowered to a library function), or an alias of; // a function. If the target is not a function/external symbol, we; // shouldn't remove the wrapper, because we cannot call it directly and; // instead we want it to be loaded with a CONST instruction and called; // with a call_indirect later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:236,Integrability,wrap,wrapper,236,"// Remove the wrapper when the call target is a function, an external; // symbol (which will be lowered to a library function), or an alias of; // a function. If the target is not a function/external symbol, we; // shouldn't remove the wrapper, because we cannot call it directly and; // instead we want it to be loaded with a CONST instruction and called; // with a call_indirect later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:313,Performance,load,loaded,313,"// Remove the wrapper when the call target is a function, an external; // symbol (which will be lowered to a library function), or an alias of; // a function. If the target is not a function/external symbol, we; // shouldn't remove the wrapper, because we cannot call it directly and; // instead we want it to be loaded with a CONST instruction and called; // with a call_indirect later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:19,Usability,simpl,simple,19,// We just support simple memory operands that just have a single address; // operand and need no special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:184,Integrability,wrap,wrapping,184,"// WebAssembly constant offsets are performed as unsigned with infinite; // precision, so we need to check for NoUnsignedWrap so that we don't fold an; // offset for an add that needs wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:36,Performance,perform,performed,36,"// WebAssembly constant offsets are performed as unsigned with infinite; // precision, so we need to check for NoUnsignedWrap so that we don't fold an; // offset for an add that needs wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:25,Performance,load,load,25,// Else it's a plain old load/store with no offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:99,Energy Efficiency,schedul,scheduling,99,"/// This pass converts a legalized DAG into a WebAssembly-specific DAG, ready; /// for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:53,Energy Efficiency,reduce,reduce,53,"// We don't know the microarchitecture here, so just reduce register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:107,Modifiability,variab,variables,107,"// Transform loads and stores to pointers in address space 1 to loads and; // stores to WebAssembly global variables, outside linear memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:13,Performance,load,loads,13,"// Transform loads and stores to pointers in address space 1 to loads and; // stores to WebAssembly global variables, outside linear memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:64,Performance,load,loads,64,"// Transform loads and stores to pointers in address space 1 to loads and; // stores to WebAssembly global variables, outside linear memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:18,Performance,load,load,18,"// We need custom load and store lowering for both externref, funcref and; // Other. The MVT::Other here represents tables of reference types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:17,Deployability,configurat,configuration,17,// SIMD-specific configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:17,Modifiability,config,configuration,17,// SIMD-specific configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:18,Availability,mask,mask,18,// Combine vector mask reductions into alltrue/anytrue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:11,Modifiability,extend,extends,11,// Combine extends of extract_subvectors into widening ops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:57,Availability,mask,mask,57,// We have custom shuffle lowering to expose the shuffle mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:38,Security,expose,expose,38,// We have custom shuffle lowering to expose the shuffle mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:44,Modifiability,variab,variable,44,// Custom lower lane accesses to expand out variable indices,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:21,Security,access,accesses,21,// Custom lower lane accesses to expand out variable indices,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:18,Modifiability,extend,extending,18,// Support vector extending,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:80,Modifiability,extend,extend,80,"// As a special case, these operators use the type to mean the type to; // sign-extend from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:8,Modifiability,extend,extends,8,// Sign extends are legal only when extending a vector extract,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:36,Modifiability,extend,extending,36,// Sign extends are legal only when extending a vector extract,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:50,Modifiability,extend,extending,50,// WebAssembly doesn't have:; // - Floating-point extending loads.; // - Floating-point truncating stores.; // - i1 extending loads.; // - truncating SIMD stores and most extending loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:116,Modifiability,extend,extending,116,// WebAssembly doesn't have:; // - Floating-point extending loads.; // - Floating-point truncating stores.; // - i1 extending loads.; // - truncating SIMD stores and most extending loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:171,Modifiability,extend,extending,171,// WebAssembly doesn't have:; // - Floating-point extending loads.; // - Floating-point truncating stores.; // - i1 extending loads.; // - truncating SIMD stores and most extending loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:60,Performance,load,loads,60,// WebAssembly doesn't have:; // - Floating-point extending loads.; // - Floating-point truncating stores.; // - i1 extending loads.; // - truncating SIMD stores and most extending loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:126,Performance,load,loads,126,// WebAssembly doesn't have:; // - Floating-point extending loads.; // - Floating-point truncating stores.; // - i1 extending loads.; // - truncating SIMD stores and most extending loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:181,Performance,load,loads,181,// WebAssembly doesn't have:; // - Floating-point extending loads.; // - Floating-point truncating stores.; // - i1 extending loads.; // - truncating SIMD stores and most extending loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:19,Modifiability,extend,extending,19,// But some vector extending loads are legal,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:29,Performance,load,loads,29,// But some vector extending loads are legal,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:158,Integrability,depend,depending,158,"// Define the emscripten name for return address helper.; // TODO: when implementing other Wasm backends, make this generic or only do; // this on emscripten depending on what they end up doing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:120,Energy Efficiency,reduce,reduces,120,"// Always convert switches to br_tables unless there is only one case, which; // is equivalent to a simple branch. This reduces code size for wasm, and we; // defer possible jump table optimizations to the VM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:185,Performance,optimiz,optimizations,185,"// Always convert switches to br_tables unless there is only one case, which; // is equivalent to a simple branch. This reduces code size for wasm, and we; // defer possible jump table optimizations to the VM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:100,Usability,simpl,simple,100,"// Always convert switches to br_tables unless there is only one case, which; // is equivalent to a simple branch. This reduces code size for wasm, and we; // defer possible jump table optimizations to the VM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:98,Deployability,install,installed,98,"// For funcrefs, call_indirect is done through __funcref_call_table and the; // funcref is always installed in slot 0 of the table, therefore instead of; // having the function pointer added at the end of the params list, a zero; // (the index in; // __funcref_call_table is added).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:33,Safety,avoid,avoid,33,"// If this is a funcref call, to avoid hidden GC roots, we need to clear the; // table slot with ref.null upon call_indirect return.; //; // This generates the following code, which comes right after a call_indirect; // of a funcref:; //; // i32.const 0; // ref.null func; // table.set __funcref_call_table",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:67,Usability,clear,clear,67,"// If this is a funcref call, to avoid hidden GC roots, we need to clear the; // table slot with ref.null upon call_indirect return.; //; // This generates the following code, which comes right after a call_indirect; // of a funcref:; //; // i32.const 0; // ref.null func; // table.set __funcref_call_table",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:53,Integrability,wrap,wrapping,53,"// WebAssembly offsets are added as unsigned without wrapping. The; // isLegalAddressingMode gives us no way to determine if wrapping could be; // happening, so we approximate this by accepting only non-negative offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:125,Integrability,wrap,wrapping,125,"// WebAssembly offsets are added as unsigned without wrapping. The; // isLegalAddressingMode gives us no way to determine if wrapping could be; // happening, so we approximate this by accepting only non-negative offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:107,Performance,load,loads,107,"// WebAssembly supports unaligned accesses, though it should be declared; // with the p2align attribute on loads and stores which do so, and there; // may be a performance impact. We tell LLVM they're ""fast"" because; // for the kinds of things that LLVM uses this for (merging adjacent stores; // of constants, etc.), WebAssembly implementations will either want the; // unaligned access or they'll split anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:160,Performance,perform,performance,160,"// WebAssembly supports unaligned accesses, though it should be declared; // with the p2align attribute on loads and stores which do so, and there; // may be a performance impact. We tell LLVM they're ""fast"" because; // for the kinds of things that LLVM uses this for (merging adjacent stores; // of constants, etc.), WebAssembly implementations will either want the; // unaligned access or they'll split anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:34,Security,access,accesses,34,"// WebAssembly supports unaligned accesses, though it should be declared; // with the p2align attribute on loads and stores which do so, and there; // may be a performance impact. We tell LLVM they're ""fast"" because; // for the kinds of things that LLVM uses this for (merging adjacent stores; // of constants, etc.), WebAssembly implementations will either want the; // unaligned access or they'll split anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:381,Security,access,access,381,"// WebAssembly supports unaligned accesses, though it should be declared; // with the p2align attribute on loads and stores which do so, and there; // may be a performance impact. We tell LLVM they're ""fast"" because; // for the kinds of things that LLVM uses this for (merging adjacent stores; // of constants, etc.), WebAssembly implementations will either want the; // unaligned access or they'll split anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:50,Performance,perform,perform,50,"// The current thinking is that wasm engines will perform this optimization,; // so we can save on code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:63,Performance,optimiz,optimization,63,"// The current thinking is that wasm engines will perform this optimization,; // so we can save on code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:172,Energy Efficiency,reduce,reduce,172,"// So far, all branch instructions in Wasm take an I32 condition.; // The default TargetLowering::getSetCCResultType returns the pointer size,; // which would be useful to reduce instruction counts when testing; // against 64-bit pointers/values if at some point Wasm supports that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:203,Testability,test,testing,203,"// So far, all branch instructions in Wasm take an I32 condition.; // The default TargetLowering::getSetCCResultType returns the pointer size,; // which would be useful to reduce instruction counts when testing; // against 64-bit pointers/values if at some point Wasm supports that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:45,Performance,load,load,45,"// atomic.notify instruction does not really load the memory specified with; // this argument, but MachineMemOperand should either be load or store, so; // we set this to a load.; // FIXME Volatile isn't really correct, but currently all LLVM atomic; // instructions are treated as volatiles in the backend, so we should be; // consistent. The same applies for wasm_atomic_wait intrinsics too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:134,Performance,load,load,134,"// atomic.notify instruction does not really load the memory specified with; // this argument, but MachineMemOperand should either be load or store, so; // we set this to a load.; // FIXME Volatile isn't really correct, but currently all LLVM atomic; // instructions are treated as volatiles in the backend, so we should be; // consistent. The same applies for wasm_atomic_wait intrinsics too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:173,Performance,load,load,173,"// atomic.notify instruction does not really load the memory specified with; // this argument, but MachineMemOperand should either be load or store, so; // we set this to a load.; // FIXME Volatile isn't really correct, but currently all LLVM atomic; // instructions are treated as volatiles in the backend, so we should be; // consistent. The same applies for wasm_atomic_wait intrinsics too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:146,Modifiability,extend,extend,146,"// We have legal vector types with these lane types, so widening the; // vector would let us use some of the lanes directly without having to; // extend or truncate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:374,Integrability,rout,routines,374,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:532,Integrability,rout,routines,532,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:707,Integrability,rout,routine,707,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:90,Performance,optimiz,optimization,90,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:625,Usability,Simpl,SimplifyDemandedVectorElts,625,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:989,Usability,Simpl,SimplifyDemandedVectorElts,989,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:3,Testability,Test,Test,3,// Test whether the given calling convention is supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:84,Availability,reliab,reliable,84,"// Add all fixed arguments. Note that for non-varargs calls, NumFixedArgs; // isn't reliable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:36,Energy Efficiency,allocate,allocated,36,"// Varargs are copied into a buffer allocated by the caller, and a pointer to; // the buffer is passed as an argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:86,Testability,log,logic,86,// TODO: Use signatures in WebAssemblyMachineFunctionInfo too and unify; // the param logic here with ComputeSignatureVTs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:194,Modifiability,extend,extends,194,"// Do not add any results, signifying that N should not be custom lowered; // after all. This happens because simd128 turns on custom lowering for; // SIGN_EXTEND_INREG, but for non-vector sign extends the result might be an; // illegal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:246,Usability,usab,usable,246,"// CopyToReg nodes don't support FrameIndex operands. Other targets select; // the FI to some LEA-like instruction, but since we don't have that, we; // need to insert some kind of instruction that can take an FI operand and; // produces a value usable by CopyToReg (i.e. in a vreg). So insert a dummy; // local.copy between Op and its FI operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:21,Modifiability,variab,variables,21,// For DSO-local TLS variables we use offset from __tls_base,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:25,Integrability,Wrap,Wrapper,25,"// There's no need for a Wrapper node because we always incorporate a jump; // table operand into a BR_TABLE instruction, rather than ever; // materializing it in a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:139,Integrability,depend,depend,139,"// If sign extension operations are disabled, allow sext_inreg only if operand; // is a vector extract of an i8 or i16 lane. SIMD does not depend on sign; // extension operations, but allowing sext_inreg in this context lets us have; // simple patterns to select extract_lane_s instructions. Expanding sext_inreg; // everywhere would be simpler in this file, but would necessitate large and; // brittle patterns to undo the expansion and select extract_lane_s; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:237,Usability,simpl,simple,237,"// If sign extension operations are disabled, allow sext_inreg only if operand; // is a vector extract of an i8 or i16 lane. SIMD does not depend on sign; // extension operations, but allowing sext_inreg in this context lets us have; // simple patterns to select extract_lane_s instructions. Expanding sext_inreg; // everywhere would be simpler in this file, but would necessitate large and; // brittle patterns to undo the expansion and select extract_lane_s; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:337,Usability,simpl,simpler,337,"// If sign extension operations are disabled, allow sext_inreg only if operand; // is a vector extract of an i8 or i16 lane. SIMD does not depend on sign; // extension operations, but allowing sext_inreg in this context lets us have; // simple patterns to select extract_lane_s instructions. Expanding sext_inreg; // everywhere would be simpler in this file, but would necessitate large and; // brittle patterns to undo the expansion and select extract_lane_s; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:415,Usability,undo,undo,415,"// If sign extension operations are disabled, allow sext_inreg only if operand; // is a vector extract of an i8 or i16 lane. SIMD does not depend on sign; // extension operations, but allowing sext_inreg in this context lets us have; // simple patterns to select extract_lane_s instructions. Expanding sext_inreg; // everywhere would be simpler in this file, but would necessitate large and; // brittle patterns to undo the expansion and select extract_lane_s; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:228,Performance,Tune,Tune,228,"// BUILD_VECTORs are lowered to the instruction that initializes the highest; // possible number of lanes at once followed by a sequence of replace_lane; // instructions to individually initialize any remaining lanes.; // TODO: Tune this. For example, lanewise swizzling is very expensive, so; // swizzled lanes should be given greater weight.; // TODO: Investigate looping rather than always extracting/replacing specific; // lanes to fill gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:54,Modifiability,extend,extend,54,"// Values may need to be fixed so that they will sign extend to be; // within the expected range during ISel. Check whether the value is in; // bounds based on the lane bit width and if it is out of bounds, lop; // off the extra bits and subtract 2^n to reflect giving the high bit; // value -2^(n-1) rather than +2^(n-1). Skip the i64 case because it; // cannot possibly be out of range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:45,Performance,load,load,45,// Use a splat (which might be selected as a load splat),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:41,Availability,mask,mask,41,// Space for two vector args and sixteen mask indices,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:10,Availability,mask,mask,10,// Expand mask indices to byte indices and materialize them as operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:38,Availability,mask,mask,38,"// Lower undefs (represented by -1 in mask) to {0..J}, which use a; // whole lane of vector input, to allow further reduction at VM. E.g.; // match an 8x16 byte shuffle to an equivalent cheaper 32x4 shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:39,Modifiability,variab,variable,39,"// Allow constant lane indices, expand variable lane indices",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform default expansion,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:13,Availability,mask,mask,13,// Otherwise mask the shift value to get proper semantics from 32-bit shift,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:203,Availability,mask,mask,203,"// Hoist vector bitcasts that don't change the number of lanes out of unary; // shuffles, where they are less likely to get in the way of other combines.; // (shuffle (vNxT1 (bitcast (vNxT0 x))), undef, mask) ->; // (vNxT1 (bitcast (vNxT0 (shuffle x, undef, mask))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:258,Availability,mask,mask,258,"// Hoist vector bitcasts that don't change the number of lanes out of unary; // shuffles, where they are less likely to get in the way of other combines.; // (shuffle (vNxT1 (bitcast (vNxT0 x))), undef, mask) ->; // (vNxT1 (bitcast (vNxT0 (shuffle x, undef, mask))))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:159,Modifiability,extend,extending,159,"/// Convert ({u,s}itofp vec) --> ({u,s}itofp ({s,z}ext vec)) so it doesn't get; /// split up into scalar instructions during legalization, and the vector; /// extending instructions are selected in performVectorExtendCombine below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:198,Performance,perform,performVectorExtendCombine,198,"/// Convert ({u,s}itofp vec) --> ({u,s}itofp ({s,z}ext vec)) so it doesn't get; /// split up into scalar instructions during legalization, and the vector; /// extending instructions are selected in performVectorExtendCombine below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:109,Energy Efficiency,power,power,109,// This is the index of the first element of the VectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:133,Usability,clear,clear,133,// This is the index of the first element of the VectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h:57,Integrability,Interface,Interface,57,"//- WebAssemblyISelLowering.h - WebAssembly DAG Lowering Interface -*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that WebAssembly uses to lower LLVM; /// code into a selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h:418,Integrability,interface,interfaces,418,"//- WebAssemblyISelLowering.h - WebAssembly DAG Lowering Interface -*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that WebAssembly uses to lower LLVM; /// code into a selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLateEHPrepare.cpp:126,Safety,safe,safe,126,"// Insert __stack_pointer restoring instructions at the beginning of each EH; // pad, after the catch instruction. Here it is safe to assume that SP32; // holds the latest value of __stack_pointer, because the only exception for; // this case is when a function uses the red zone, but that only happens; // with leaf functions, and we don't restore __stack_pointer in leaf; // functions anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLateEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLateEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:9379,Availability,reliab,reliable,9379,"try-catch mechanism. It instead uses Wasm exception handling intrinsics,; /// which will be lowered to exception handling instructions.; ///; /// If there are calls to longjmp(); ///; /// 1) Lower; /// longjmp(env, val); /// into; /// __wasm_longjmp(env, val); ///; /// If there are calls to setjmp(); ///; /// 2) and 3): The same as 2) and 3) in Emscripten SjLj.; /// (setjmpTable/setjmpTableSize initialization + setjmp callsite; /// transformation); ///; /// 4) Create a catchpad with a wasm.catch() intrinsic, which returns the value; /// thrown by __wasm_longjmp function. In Emscripten library, we have this; /// struct:; ///; /// struct __WasmLongjmpArgs {; /// void *env;; /// int val;; /// };; /// struct __WasmLongjmpArgs __wasm_longjmp_args;; ///; /// The thrown value here is a pointer to __wasm_longjmp_args struct object. We; /// use this struct to transfer two values by throwing a single value. Wasm; /// throw and catch instructions are capable of throwing and catching multiple; /// values, but it also requires multivalue support that is currently not very; /// reliable.; /// TODO Switch to throwing and catching two values without using the struct; ///; /// All longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:831,Integrability,wrap,wrappers,831,"//=== WebAssemblyLowerEmscriptenEHSjLj.cpp - Lower exceptions for Emscripten =//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file lowers exception-related instructions and setjmp/longjmp function; /// calls to use Emscripten's library functions. The pass uses JavaScript's try; /// and catch mechanism in case of Emscripten EH/SjLj and Wasm EH intrinsics in; /// case of Emscripten SjLJ.; ///; /// * Emscripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:854,Integrability,wrap,wrappers,854,"//=== WebAssemblyLowerEmscriptenEHSjLj.cpp - Lower exceptions for Emscripten =//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file lowers exception-related instructions and setjmp/longjmp function; /// calls to use Emscripten's library functions. The pass uses JavaScript's try; /// and catch mechanism in case of Emscripten EH/SjLj and Wasm EH intrinsics in; /// case of Emscripten SjLJ.; ///; /// * Emscripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:897,Integrability,wrap,wraps,897,"//=== WebAssemblyLowerEmscriptenEHSjLj.cpp - Lower exceptions for Emscripten =//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file lowers exception-related instructions and setjmp/longjmp function; /// calls to use Emscripten's library functions. The pass uses JavaScript's try; /// and catch mechanism in case of Emscripten EH/SjLj and Wasm EH intrinsics in; /// case of Emscripten SjLJ.; ///; /// * Emscripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:1584,Integrability,wrap,wrappers,1584,"nd catch mechanism in case of Emscripten EH/SjLj and Wasm EH intrinsics in; /// case of Emscripten SjLJ.; ///; /// * Emscripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run after EH handling, which means; /// we don't expect any exception-related instructions when SjLj runs.; /// FIXME Currently this scheme does not support indirect call of setjmp,; /// because of the limitation of the scheme itself. fastcomp does not support it; /// either.; ///; /// In detail, this pass does following things:; ///; /// 1) Assumes the existence of global variables: __THREW__, __threwValue; /// __THREW__ and __threwValue are defined in compiler-rt in Emscripten.; /// These variables are used for bot",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:4044,Integrability,wrap,wrappers,4044," existence of setThrew and setTempRet0/getTempRet0 functions; /// at link time. setThrew exists in Emscripten's compiler-rt:; ///; /// void setThrew(uintptr_t threw, int value) {; /// if (__THREW__ == 0) {; /// __THREW__ = threw;; /// __threwValue = value;; /// }; /// }; //; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; /// In exception handling, getTempRet0 indicates the type of an exception; /// caught, and in setjmp/longjmp, it means the second argument to longjmp; /// function.; ///; /// 3) Lower; /// invoke @func(arg1, arg2) to label %invoke.cont unwind label %lpad; /// into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// if (%__THREW__.val == 1); /// goto %lpad; /// else; /// goto %invoke.cont; /// SIG is a mangled string generated based on the LLVM IR-level function; /// signature. After LLVM IR types are lowered to the target wasm types,; /// the names for these wrappers will change based on wasm types as well,; /// as in invoke_vi (function takes an int and returns void). The bodies of; /// these wrappers will be generated in JS glue code, and inside those; /// wrappers we use JS try-catch to generate actual exception effects. It; /// also calls the original callee function. An example wrapper in JS code; /// would look like this:; /// function invoke_vi(index,a1) {; /// try {; /// Module[""dynCall_vi""](index,a1); // This calls original callee; /// } catch(e) {; /// if (typeof e !== 'number' && e !== 'longjmp') throw e;; /// _setThrew(1, 0); // setThrew is called here; /// }; /// }; /// If an exception is thrown, __THREW__ will be set to true in a wrapper,; /// so we can jump to the right BB based on this value.; ///; /// 4) Lower; /// %val = landingpad catch c1 catch c2 catch c3 ...; /// ... use %val ...; /// into; /// %fmc = call @__cxa_find_matching_catch_N(c1, c2, c3, ...); /// %val = {%fmc, getTempRet0()}; /// ... use %val ...; /// Here N is a number c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:4182,Integrability,wrap,wrappers,4182,"{; /// if (__THREW__ == 0) {; /// __THREW__ = threw;; /// __threwValue = value;; /// }; /// }; //; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; /// In exception handling, getTempRet0 indicates the type of an exception; /// caught, and in setjmp/longjmp, it means the second argument to longjmp; /// function.; ///; /// 3) Lower; /// invoke @func(arg1, arg2) to label %invoke.cont unwind label %lpad; /// into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// if (%__THREW__.val == 1); /// goto %lpad; /// else; /// goto %invoke.cont; /// SIG is a mangled string generated based on the LLVM IR-level function; /// signature. After LLVM IR types are lowered to the target wasm types,; /// the names for these wrappers will change based on wasm types as well,; /// as in invoke_vi (function takes an int and returns void). The bodies of; /// these wrappers will be generated in JS glue code, and inside those; /// wrappers we use JS try-catch to generate actual exception effects. It; /// also calls the original callee function. An example wrapper in JS code; /// would look like this:; /// function invoke_vi(index,a1) {; /// try {; /// Module[""dynCall_vi""](index,a1); // This calls original callee; /// } catch(e) {; /// if (typeof e !== 'number' && e !== 'longjmp') throw e;; /// _setThrew(1, 0); // setThrew is called here; /// }; /// }; /// If an exception is thrown, __THREW__ will be set to true in a wrapper,; /// so we can jump to the right BB based on this value.; ///; /// 4) Lower; /// %val = landingpad catch c1 catch c2 catch c3 ...; /// ... use %val ...; /// into; /// %fmc = call @__cxa_find_matching_catch_N(c1, c2, c3, ...); /// %val = {%fmc, getTempRet0()}; /// ... use %val ...; /// Here N is a number calculated based on the number of clauses.; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; ///; /// 5) Lower; /// resume {%a, %b}; /// into; /// cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:4248,Integrability,wrap,wrappers,4248,"{; /// if (__THREW__ == 0) {; /// __THREW__ = threw;; /// __threwValue = value;; /// }; /// }; //; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; /// In exception handling, getTempRet0 indicates the type of an exception; /// caught, and in setjmp/longjmp, it means the second argument to longjmp; /// function.; ///; /// 3) Lower; /// invoke @func(arg1, arg2) to label %invoke.cont unwind label %lpad; /// into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// if (%__THREW__.val == 1); /// goto %lpad; /// else; /// goto %invoke.cont; /// SIG is a mangled string generated based on the LLVM IR-level function; /// signature. After LLVM IR types are lowered to the target wasm types,; /// the names for these wrappers will change based on wasm types as well,; /// as in invoke_vi (function takes an int and returns void). The bodies of; /// these wrappers will be generated in JS glue code, and inside those; /// wrappers we use JS try-catch to generate actual exception effects. It; /// also calls the original callee function. An example wrapper in JS code; /// would look like this:; /// function invoke_vi(index,a1) {; /// try {; /// Module[""dynCall_vi""](index,a1); // This calls original callee; /// } catch(e) {; /// if (typeof e !== 'number' && e !== 'longjmp') throw e;; /// _setThrew(1, 0); // setThrew is called here; /// }; /// }; /// If an exception is thrown, __THREW__ will be set to true in a wrapper,; /// so we can jump to the right BB based on this value.; ///; /// 4) Lower; /// %val = landingpad catch c1 catch c2 catch c3 ...; /// ... use %val ...; /// into; /// %fmc = call @__cxa_find_matching_catch_N(c1, c2, c3, ...); /// %val = {%fmc, getTempRet0()}; /// ... use %val ...; /// Here N is a number calculated based on the number of clauses.; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; ///; /// 5) Lower; /// resume {%a, %b}; /// into; /// cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:4375,Integrability,wrap,wrapper,4375," 3) Lower; /// invoke @func(arg1, arg2) to label %invoke.cont unwind label %lpad; /// into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// if (%__THREW__.val == 1); /// goto %lpad; /// else; /// goto %invoke.cont; /// SIG is a mangled string generated based on the LLVM IR-level function; /// signature. After LLVM IR types are lowered to the target wasm types,; /// the names for these wrappers will change based on wasm types as well,; /// as in invoke_vi (function takes an int and returns void). The bodies of; /// these wrappers will be generated in JS glue code, and inside those; /// wrappers we use JS try-catch to generate actual exception effects. It; /// also calls the original callee function. An example wrapper in JS code; /// would look like this:; /// function invoke_vi(index,a1) {; /// try {; /// Module[""dynCall_vi""](index,a1); // This calls original callee; /// } catch(e) {; /// if (typeof e !== 'number' && e !== 'longjmp') throw e;; /// _setThrew(1, 0); // setThrew is called here; /// }; /// }; /// If an exception is thrown, __THREW__ will be set to true in a wrapper,; /// so we can jump to the right BB based on this value.; ///; /// 4) Lower; /// %val = landingpad catch c1 catch c2 catch c3 ...; /// ... use %val ...; /// into; /// %fmc = call @__cxa_find_matching_catch_N(c1, c2, c3, ...); /// %val = {%fmc, getTempRet0()}; /// ... use %val ...; /// Here N is a number calculated based on the number of clauses.; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; ///; /// 5) Lower; /// resume {%a, %b}; /// into; /// call @__resumeException(%a); /// where __resumeException() is a function in JS glue code.; ///; /// 6) Lower; /// call @llvm.eh.typeid.for(type) (intrinsic); /// into; /// call @llvm_eh_typeid_for(type); /// llvm_eh_typeid_for function will be generated in JS glue code.; ///; /// * Emscripten setjmp / longjmp handling; ///; /// If there are calls to lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:4743,Integrability,wrap,wrapper,4743," 3) Lower; /// invoke @func(arg1, arg2) to label %invoke.cont unwind label %lpad; /// into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// if (%__THREW__.val == 1); /// goto %lpad; /// else; /// goto %invoke.cont; /// SIG is a mangled string generated based on the LLVM IR-level function; /// signature. After LLVM IR types are lowered to the target wasm types,; /// the names for these wrappers will change based on wasm types as well,; /// as in invoke_vi (function takes an int and returns void). The bodies of; /// these wrappers will be generated in JS glue code, and inside those; /// wrappers we use JS try-catch to generate actual exception effects. It; /// also calls the original callee function. An example wrapper in JS code; /// would look like this:; /// function invoke_vi(index,a1) {; /// try {; /// Module[""dynCall_vi""](index,a1); // This calls original callee; /// } catch(e) {; /// if (typeof e !== 'number' && e !== 'longjmp') throw e;; /// _setThrew(1, 0); // setThrew is called here; /// }; /// }; /// If an exception is thrown, __THREW__ will be set to true in a wrapper,; /// so we can jump to the right BB based on this value.; ///; /// 4) Lower; /// %val = landingpad catch c1 catch c2 catch c3 ...; /// ... use %val ...; /// into; /// %fmc = call @__cxa_find_matching_catch_N(c1, c2, c3, ...); /// %val = {%fmc, getTempRet0()}; /// ... use %val ...; /// Here N is a number calculated based on the number of clauses.; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; ///; /// 5) Lower; /// resume {%a, %b}; /// into; /// call @__resumeException(%a); /// where __resumeException() is a function in JS glue code.; ///; /// 6) Lower; /// call @llvm.eh.typeid.for(type) (intrinsic); /// into; /// call @llvm_eh_typeid_for(type); /// llvm_eh_typeid_for function will be generated in JS glue code.; ///; /// * Emscripten setjmp / longjmp handling; ///; /// If there are calls to lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:7589,Integrability,wrap,wrapper,7589," 'env'. A BB with setjmp is split into two after setjmp call in; /// order to make the post-setjmp BB the possible destination of longjmp BB.; ///; /// 4) Lower every call that might longjmp into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// %__threwValue.val = __threwValue;; /// if (%__THREW__.val != 0 & %__threwValue.val != 0) {; /// %label = testSetjmp(mem[%__THREW__.val], setjmpTable,; /// setjmpTableSize);; /// if (%label == 0); /// emscripten_longjmp(%__THREW__.val, %__threwValue.val);; /// setTempRet0(%__threwValue.val);; /// } else {; /// %label = -1;; /// }; /// longjmp_result = getTempRet0();; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// testSetjmp examines setjmpTable to see if there is a matching setjmp; /// call. After calling an invoke wrapper, if a longjmp occurred, __THREW__; /// will be the address of matching jmp_buf buffer and __threwValue be the; /// second argument to longjmp. mem[%__THREW__.val] is a setjmp ID that is; /// stored in saveSetjmp. testSetjmp returns a setjmp label, a unique ID to; /// each setjmp callsite. Label 0 means this longjmp buffer does not; /// correspond to one of the setjmp callsites in this function, so in this; /// case we just chain the longjmp to the caller. Label -1 means no longjmp; /// occurred. Otherwise we jump to the right post-setjmp BB based on the; /// label.; ///; /// * Wasm setjmp / longjmp handling; /// This mode still uses some Emscripten library functions but not JavaScript's; /// try-catch mechanism. It instead uses Wasm exception handling intrinsics,; /// which will be lowered to exception handling instructions.; ///; /// If there are calls to longjmp(); ///; /// 1) Lower; /// longjmp(env, val); /// into; /// __wasm_longjmp(env, val); ///; /// If there are calls to setjmp(); ///; /// 2) and 3): The same as 2) and 3) in Emscrip",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:1027,Modifiability,variab,variables,1027,"Lower exceptions for Emscripten =//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file lowers exception-related instructions and setjmp/longjmp function; /// calls to use Emscripten's library functions. The pass uses JavaScript's try; /// and catch mechanism in case of Emscripten EH/SjLj and Wasm EH intrinsics in; /// case of Emscripten SjLJ.; ///; /// * Emscripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run afte",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:1660,Modifiability,variab,variables,1660,"scripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run after EH handling, which means; /// we don't expect any exception-related instructions when SjLj runs.; /// FIXME Currently this scheme does not support indirect call of setjmp,; /// because of the limitation of the scheme itself. fastcomp does not support it; /// either.; ///; /// In detail, this pass does following things:; ///; /// 1) Assumes the existence of global variables: __THREW__, __threwValue; /// __THREW__ and __threwValue are defined in compiler-rt in Emscripten.; /// These variables are used for both exceptions and setjmp/longjmps.; /// __THREW__ indicates whether an exception or a longjmp occurred or not. 0; /// me",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:2414,Modifiability,variab,variables,2414,"he latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run after EH handling, which means; /// we don't expect any exception-related instructions when SjLj runs.; /// FIXME Currently this scheme does not support indirect call of setjmp,; /// because of the limitation of the scheme itself. fastcomp does not support it; /// either.; ///; /// In detail, this pass does following things:; ///; /// 1) Assumes the existence of global variables: __THREW__, __threwValue; /// __THREW__ and __threwValue are defined in compiler-rt in Emscripten.; /// These variables are used for both exceptions and setjmp/longjmps.; /// __THREW__ indicates whether an exception or a longjmp occurred or not. 0; /// means nothing occurred, 1 means an exception occurred, and other numbers; /// mean a longjmp occurred. In the case of longjmp, __THREW__ variable; /// indicates the corresponding setjmp buffer the longjmp corresponds to.; /// __threwValue is 0 for exceptions, and the argument to longjmp in case of; /// longjmp.; ///; /// * Emscripten exception handling; ///; /// 2) We assume the existence of setThrew and setTempRet0/getTempRet0 functions; /// at link time. setThrew exists in Emscripten's compiler-rt:; ///; /// void setThrew(uintptr_t threw, int value) {; /// if (__THREW__ == 0) {; /// __THREW__ = threw;; /// __threwValue = value;; /// }; /// }; //; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; /// In ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:2534,Modifiability,variab,variables,2534,"e also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run after EH handling, which means; /// we don't expect any exception-related instructions when SjLj runs.; /// FIXME Currently this scheme does not support indirect call of setjmp,; /// because of the limitation of the scheme itself. fastcomp does not support it; /// either.; ///; /// In detail, this pass does following things:; ///; /// 1) Assumes the existence of global variables: __THREW__, __threwValue; /// __THREW__ and __threwValue are defined in compiler-rt in Emscripten.; /// These variables are used for both exceptions and setjmp/longjmps.; /// __THREW__ indicates whether an exception or a longjmp occurred or not. 0; /// means nothing occurred, 1 means an exception occurred, and other numbers; /// mean a longjmp occurred. In the case of longjmp, __THREW__ variable; /// indicates the corresponding setjmp buffer the longjmp corresponds to.; /// __threwValue is 0 for exceptions, and the argument to longjmp in case of; /// longjmp.; ///; /// * Emscripten exception handling; ///; /// 2) We assume the existence of setThrew and setTempRet0/getTempRet0 functions; /// at link time. setThrew exists in Emscripten's compiler-rt:; ///; /// void setThrew(uintptr_t threw, int value) {; /// if (__THREW__ == 0) {; /// __THREW__ = threw;; /// __threwValue = value;; /// }; /// }; //; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; /// In exception handling, getTempRet0 indicates the type of an exception; /// caught, and in setjmp/longjmp, it means the second argument to longj",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:2814,Modifiability,variab,variable,2814,"After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run after EH handling, which means; /// we don't expect any exception-related instructions when SjLj runs.; /// FIXME Currently this scheme does not support indirect call of setjmp,; /// because of the limitation of the scheme itself. fastcomp does not support it; /// either.; ///; /// In detail, this pass does following things:; ///; /// 1) Assumes the existence of global variables: __THREW__, __threwValue; /// __THREW__ and __threwValue are defined in compiler-rt in Emscripten.; /// These variables are used for both exceptions and setjmp/longjmps.; /// __THREW__ indicates whether an exception or a longjmp occurred or not. 0; /// means nothing occurred, 1 means an exception occurred, and other numbers; /// mean a longjmp occurred. In the case of longjmp, __THREW__ variable; /// indicates the corresponding setjmp buffer the longjmp corresponds to.; /// __threwValue is 0 for exceptions, and the argument to longjmp in case of; /// longjmp.; ///; /// * Emscripten exception handling; ///; /// 2) We assume the existence of setThrew and setTempRet0/getTempRet0 functions; /// at link time. setThrew exists in Emscripten's compiler-rt:; ///; /// void setThrew(uintptr_t threw, int value) {; /// if (__THREW__ == 0) {; /// __THREW__ = threw;; /// __threwValue = value;; /// }; /// }; //; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; /// In exception handling, getTempRet0 indicates the type of an exception; /// caught, and in setjmp/longjmp, it means the second argument to longjmp; /// function.; ///; /// 3) Lower; /// invoke @func(arg1, arg2) to label %invoke.cont unwind label %lpad; /// into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// if (%__THREW__.val == 1); /// goto %lpad; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:1236,Performance,perform,performant,1236," license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file lowers exception-related instructions and setjmp/longjmp function; /// calls to use Emscripten's library functions. The pass uses JavaScript's try; /// and catch mechanism in case of Emscripten EH/SjLj and Wasm EH intrinsics in; /// case of Emscripten SjLJ.; ///; /// * Emscripten exception handling; /// This pass lowers invokes and landingpads into library functions in JS glue; /// code. Invokes are lowered into function wrappers called invoke wrappers that; /// exist in JS side, which wraps the original function call with JS try-catch.; /// If an exception occurred, cxa_throw() function in JS side sets some; /// variables (see below) so we can check whether an exception occurred from; /// wasm code and handle it appropriately.; ///; /// * Emscripten setjmp-longjmp handling; /// This pass lowers setjmp to a reasonably-performant approach for emscripten.; /// The idea is that each block with a setjmp is broken up into two parts: the; /// part containing setjmp and the part right after the setjmp. The latter part; /// is either reached from the setjmp, or later from a longjmp. To handle the; /// longjmp, all calls that might longjmp are also called using invoke wrappers; /// and thus JS / try-catch. JS longjmp() function also sets some variables so; /// we can check / whether a longjmp occurred from wasm code. Each block with a; /// function call that might longjmp is also split up after the longjmp call.; /// After the longjmp call, we check whether a longjmp occurred, and if it did,; /// which setjmp it corresponds to, and jump to the right post-setjmp block.; /// We assume setjmp-longjmp handling always run after EH handling, which means; /// we don't expect any exception-related instructions when SjLj runs.; /// FIXME Currently this scheme does not support indirect cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:11146,Performance,load,load,11146," longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke void @foo() ;; foo is a longjmpable function; /// to label %next unwind label %catch.dispatch.longjmp; /// ...; ///; /// catch.dispatch.longjmp:; /// %0 = catchswitch within none [label %catch.longjmp] unwind to caller; ///; /// catch.longjmp:; /// %longjmp.args = wasm.catch() ;; struct __WasmLongjmpArgs; /// %env = load 'env' field from __WasmLongjmpArgs; /// %val = load 'val' field from __WasmLongjmpArgs; /// %label = testSetjmp(mem[%env], setjmpTable, setjmpTableSize);; /// if (%label == 0); /// __wasm_longjmp(%env, %val); /// catchret to %setjmp.dispatch; ///; ///===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:11198,Performance,load,load,11198," longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke void @foo() ;; foo is a longjmpable function; /// to label %next unwind label %catch.dispatch.longjmp; /// ...; ///; /// catch.dispatch.longjmp:; /// %0 = catchswitch within none [label %catch.longjmp] unwind to caller; ///; /// catch.longjmp:; /// %longjmp.args = wasm.catch() ;; struct __WasmLongjmpArgs; /// %env = load 'env' field from __WasmLongjmpArgs; /// %val = load 'val' field from __WasmLongjmpArgs; /// %label = testSetjmp(mem[%env], setjmpTable, setjmpTableSize);; /// if (%label == 0); /// __wasm_longjmp(%env, %val); /// catchret to %setjmp.dispatch; ///; ///===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:7072,Testability,test,testSetjmp,7072," into; /// setjmpTable = saveSetjmp(env, label, setjmpTable, setjmpTableSize);; /// setjmpTableSize = getTempRet0();; /// For each dynamic setjmp call, setjmpTable stores its ID (a number which; /// is incrementally assigned from 0) and its label (a unique number that; /// represents each callsite of setjmp). When we need more entries in; /// setjmpTable, it is reallocated in saveSetjmp() in Emscripten's; /// compiler-rt and it will return the new table address, and assign the new; /// table size in setTempRet0(). saveSetjmp also stores the setjmp's ID into; /// the buffer 'env'. A BB with setjmp is split into two after setjmp call in; /// order to make the post-setjmp BB the possible destination of longjmp BB.; ///; /// 4) Lower every call that might longjmp into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// %__threwValue.val = __threwValue;; /// if (%__THREW__.val != 0 & %__threwValue.val != 0) {; /// %label = testSetjmp(mem[%__THREW__.val], setjmpTable,; /// setjmpTableSize);; /// if (%label == 0); /// emscripten_longjmp(%__THREW__.val, %__threwValue.val);; /// setTempRet0(%__threwValue.val);; /// } else {; /// %label = -1;; /// }; /// longjmp_result = getTempRet0();; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// testSetjmp examines setjmpTable to see if there is a matching setjmp; /// call. After calling an invoke wrapper, if a longjmp occurred, __THREW__; /// will be the address of matching jmp_buf buffer and __threwValue be the; /// second argument to longjmp. mem[%__THREW__.val] is a setjmp ID that is; /// stored in saveSetjmp. testSetjmp returns a setjmp label, a unique ID to; /// each setjmp callsite. Label 0 means this longjmp buffer does not; /// correspond to one of the setjmp callsites in this function, so in this; /// case we just chain the longjmp to the caller. Label -1 means ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:7485,Testability,test,testSetjmp,7485," it will return the new table address, and assign the new; /// table size in setTempRet0(). saveSetjmp also stores the setjmp's ID into; /// the buffer 'env'. A BB with setjmp is split into two after setjmp call in; /// order to make the post-setjmp BB the possible destination of longjmp BB.; ///; /// 4) Lower every call that might longjmp into; /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// %__threwValue.val = __threwValue;; /// if (%__THREW__.val != 0 & %__threwValue.val != 0) {; /// %label = testSetjmp(mem[%__THREW__.val], setjmpTable,; /// setjmpTableSize);; /// if (%label == 0); /// emscripten_longjmp(%__THREW__.val, %__threwValue.val);; /// setTempRet0(%__threwValue.val);; /// } else {; /// %label = -1;; /// }; /// longjmp_result = getTempRet0();; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// testSetjmp examines setjmpTable to see if there is a matching setjmp; /// call. After calling an invoke wrapper, if a longjmp occurred, __THREW__; /// will be the address of matching jmp_buf buffer and __threwValue be the; /// second argument to longjmp. mem[%__THREW__.val] is a setjmp ID that is; /// stored in saveSetjmp. testSetjmp returns a setjmp label, a unique ID to; /// each setjmp callsite. Label 0 means this longjmp buffer does not; /// correspond to one of the setjmp callsites in this function, so in this; /// case we just chain the longjmp to the caller. Label -1 means no longjmp; /// occurred. Otherwise we jump to the right post-setjmp BB based on the; /// label.; ///; /// * Wasm setjmp / longjmp handling; /// This mode still uses some Emscripten library functions but not JavaScript's; /// try-catch mechanism. It instead uses Wasm exception handling intrinsics,; /// which will be lowered to exception handling instructions.; ///; /// If there are calls to longjmp(); ///; /// 1) Lower; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:7810,Testability,test,testSetjmp,7810," /// __THREW__ = 0;; /// call @__invoke_SIG(func, arg1, arg2); /// %__THREW__.val = __THREW__;; /// __THREW__ = 0;; /// %__threwValue.val = __threwValue;; /// if (%__THREW__.val != 0 & %__threwValue.val != 0) {; /// %label = testSetjmp(mem[%__THREW__.val], setjmpTable,; /// setjmpTableSize);; /// if (%label == 0); /// emscripten_longjmp(%__THREW__.val, %__threwValue.val);; /// setTempRet0(%__threwValue.val);; /// } else {; /// %label = -1;; /// }; /// longjmp_result = getTempRet0();; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// testSetjmp examines setjmpTable to see if there is a matching setjmp; /// call. After calling an invoke wrapper, if a longjmp occurred, __THREW__; /// will be the address of matching jmp_buf buffer and __threwValue be the; /// second argument to longjmp. mem[%__THREW__.val] is a setjmp ID that is; /// stored in saveSetjmp. testSetjmp returns a setjmp label, a unique ID to; /// each setjmp callsite. Label 0 means this longjmp buffer does not; /// correspond to one of the setjmp callsites in this function, so in this; /// case we just chain the longjmp to the caller. Label -1 means no longjmp; /// occurred. Otherwise we jump to the right post-setjmp BB based on the; /// label.; ///; /// * Wasm setjmp / longjmp handling; /// This mode still uses some Emscripten library functions but not JavaScript's; /// try-catch mechanism. It instead uses Wasm exception handling intrinsics,; /// which will be lowered to exception handling instructions.; ///; /// If there are calls to longjmp(); ///; /// 1) Lower; /// longjmp(env, val); /// into; /// __wasm_longjmp(env, val); ///; /// If there are calls to setjmp(); ///; /// 2) and 3): The same as 2) and 3) in Emscripten SjLj.; /// (setjmpTable/setjmpTableSize initialization + setjmp callsite; /// transformation); ///; /// 4) Create a catchpad with a wasm.catch() intrinsic, which returns the value; /// thrown ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:9633,Testability,test,test,9633,"j.; /// (setjmpTable/setjmpTableSize initialization + setjmp callsite; /// transformation); ///; /// 4) Create a catchpad with a wasm.catch() intrinsic, which returns the value; /// thrown by __wasm_longjmp function. In Emscripten library, we have this; /// struct:; ///; /// struct __WasmLongjmpArgs {; /// void *env;; /// int val;; /// };; /// struct __WasmLongjmpArgs __wasm_longjmp_args;; ///; /// The thrown value here is a pointer to __wasm_longjmp_args struct object. We; /// use this struct to transfer two values by throwing a single value. Wasm; /// throw and catch instructions are capable of throwing and catching multiple; /// values, but it also requires multivalue support that is currently not very; /// reliable.; /// TODO Switch to throwing and catching two values without using the struct; ///; /// All longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:9662,Testability,test,testSetjmp,9662,"j.; /// (setjmpTable/setjmpTableSize initialization + setjmp callsite; /// transformation); ///; /// 4) Create a catchpad with a wasm.catch() intrinsic, which returns the value; /// thrown by __wasm_longjmp function. In Emscripten library, we have this; /// struct:; ///; /// struct __WasmLongjmpArgs {; /// void *env;; /// int val;; /// };; /// struct __WasmLongjmpArgs __wasm_longjmp_args;; ///; /// The thrown value here is a pointer to __wasm_longjmp_args struct object. We; /// use this struct to transfer two values by throwing a single value. Wasm; /// throw and catch instructions are capable of throwing and catching multiple; /// values, but it also requires multivalue support that is currently not very; /// reliable.; /// TODO Switch to throwing and catching two values without using the struct; ///; /// All longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:9848,Testability,test,testSetjmp,9848,"he value; /// thrown by __wasm_longjmp function. In Emscripten library, we have this; /// struct:; ///; /// struct __WasmLongjmpArgs {; /// void *env;; /// int val;; /// };; /// struct __WasmLongjmpArgs __wasm_longjmp_args;; ///; /// The thrown value here is a pointer to __wasm_longjmp_args struct object. We; /// use this struct to transfer two values by throwing a single value. Wasm; /// throw and catch instructions are capable of throwing and catching multiple; /// values, but it also requires multivalue support that is currently not very; /// reliable.; /// TODO Switch to throwing and catching two values without using the struct; ///; /// All longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:9895,Testability,test,testing,9895,"he value; /// thrown by __wasm_longjmp function. In Emscripten library, we have this; /// struct:; ///; /// struct __WasmLongjmpArgs {; /// void *env;; /// int val;; /// };; /// struct __WasmLongjmpArgs __wasm_longjmp_args;; ///; /// The thrown value here is a pointer to __wasm_longjmp_args struct object. We; /// use this struct to transfer two values by throwing a single value. Wasm; /// throw and catch instructions are capable of throwing and catching multiple; /// values, but it also requires multivalue support that is currently not very; /// reliable.; /// TODO Switch to throwing and catching two values without using the struct; ///; /// All longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:9956,Testability,test,testing,9956,"_longjmp_args;; ///; /// The thrown value here is a pointer to __wasm_longjmp_args struct object. We; /// use this struct to transfer two values by throwing a single value. Wasm; /// throw and catch instructions are capable of throwing and catching multiple; /// values, but it also requires multivalue support that is currently not very; /// reliable.; /// TODO Switch to throwing and catching two values without using the struct; ///; /// All longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke void @foo() ;; foo is a longjmpable function; /// to label %next unwind label %catch.dispatch.longjmp; /// ...; ///; /// catch.dispatch.longjmp:; /// %0 = catchswitch within none [label %catch.longjmp] unwind ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:9972,Testability,test,testSetjmp,9972,"_longjmp_args;; ///; /// The thrown value here is a pointer to __wasm_longjmp_args struct object. We; /// use this struct to transfer two values by throwing a single value. Wasm; /// throw and catch instructions are capable of throwing and catching multiple; /// values, but it also requires multivalue support that is currently not very; /// reliable.; /// TODO Switch to throwing and catching two values without using the struct; ///; /// All longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke void @foo() ;; foo is a longjmpable function; /// to label %next unwind label %catch.dispatch.longjmp; /// ...; ///; /// catch.dispatch.longjmp:; /// %0 = catchswitch within none [label %catch.longjmp] unwind ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:11252,Testability,test,testSetjmp,11252," longjmpable function calls will be converted to an invoke that will; /// unwind to this catchpad in case a longjmp occurs. Within the catchpad, we; /// test the thrown values using testSetjmp function as we do for Emscripten; /// SjLj. The main difference is, in Emscripten SjLj, we need to transform every; /// longjmpable callsite into a sequence of code including testSetjmp() call; in; /// Wasm SjLj we do the testing in only one place, in this catchpad.; ///; /// After testing calling testSetjmp(), if the longjmp does not correspond to; /// one of the setjmps within the current function, it rethrows the longjmp; /// by calling __wasm_longjmp(). If it corresponds to one of setjmps in the; /// function, we jump to the beginning of the function, which contains a switch; /// to each post-setjmp BB. Again, in Emscripten SjLj, this switch is added for; /// every longjmpable callsite; in Wasm SjLj we do this only once at the top of; /// the function. (after setjmpTable/setjmpTableSize initialization); ///; /// The below is the pseudocode for what we have described; ///; /// entry:; /// Initialize setjmpTable and setjmpTableSize; ///; /// setjmp.dispatch:; /// switch %label {; /// label 1: goto post-setjmp BB 1; /// label 2: goto post-setjmp BB 2; /// ...; /// default: goto splitted next BB; /// }; /// ...; ///; /// bb:; /// invoke void @foo() ;; foo is a longjmpable function; /// to label %next unwind label %catch.dispatch.longjmp; /// ...; ///; /// catch.dispatch.longjmp:; /// %0 = catchswitch within none [label %catch.longjmp] unwind to caller; ///; /// catch.longjmp:; /// %longjmp.args = wasm.catch() ;; struct __WasmLongjmpArgs; /// %env = load 'env' field from __WasmLongjmpArgs; /// %val = load 'val' field from __WasmLongjmpArgs; /// %label = testSetjmp(mem[%env], setjmpTable, setjmpTableSize);; /// if (%label == 0); /// __wasm_longjmp(%env, %val); /// catchret to %setjmp.dispatch; ///; ///===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:5201,Usability,resume,resume,5201,"wrappers we use JS try-catch to generate actual exception effects. It; /// also calls the original callee function. An example wrapper in JS code; /// would look like this:; /// function invoke_vi(index,a1) {; /// try {; /// Module[""dynCall_vi""](index,a1); // This calls original callee; /// } catch(e) {; /// if (typeof e !== 'number' && e !== 'longjmp') throw e;; /// _setThrew(1, 0); // setThrew is called here; /// }; /// }; /// If an exception is thrown, __THREW__ will be set to true in a wrapper,; /// so we can jump to the right BB based on this value.; ///; /// 4) Lower; /// %val = landingpad catch c1 catch c2 catch c3 ...; /// ... use %val ...; /// into; /// %fmc = call @__cxa_find_matching_catch_N(c1, c2, c3, ...); /// %val = {%fmc, getTempRet0()}; /// ... use %val ...; /// Here N is a number calculated based on the number of clauses.; /// setTempRet0 is called from __cxa_find_matching_catch() in JS glue code.; ///; /// 5) Lower; /// resume {%a, %b}; /// into; /// call @__resumeException(%a); /// where __resumeException() is a function in JS glue code.; ///; /// 6) Lower; /// call @llvm.eh.typeid.for(type) (intrinsic); /// into; /// call @llvm_eh_typeid_for(type); /// llvm_eh_typeid_for function will be generated in JS glue code.; ///; /// * Emscripten setjmp / longjmp handling; ///; /// If there are calls to longjmp(); ///; /// 1) Lower; /// longjmp(env, val); /// into; /// emscripten_longjmp(env, val); ///; /// If there are calls to setjmp(); ///; /// 2) In the function entry that calls setjmp, initialize setjmpTable and; /// sejmpTableSize as follows:; /// setjmpTableSize = 4;; /// setjmpTable = (int *) malloc(40);; /// setjmpTable[0] = 0;; /// setjmpTable and setjmpTableSize are used to call saveSetjmp() function in; /// Emscripten compiler-rt.; ///; /// 3) Lower; /// setjmp(env); /// into; /// setjmpTable = saveSetjmp(env, label, setjmpTable, setjmpTableSize);; /// setjmpTableSize = getTempRet0();; /// For each dynamic setjmp call, setjmpTable stores its ID",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:23,Performance,perform,perform,23,// Whether we actually perform setjmp/longjmp handling,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Testability,test,testSetjmp,3,// testSetjmp() (Emscripten),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:46,Integrability,wrap,wrappers,46,"// Map of <function signature string, invoke_ wrappers>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:29,Modifiability,variab,variable,29,"// Get a thread-local global variable with the given name. If it doesn't exist; // declare it, which will generate an import and assume that it will exist at; // link time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:144,Availability,down,downgrade,144,"// Variables created by this function are thread local. If the target does not; // support TLS, we depend on CoalesceFeaturesAndStripAtomics to downgrade it; // to non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:99,Integrability,depend,depend,99,"// Variables created by this function are thread local. If the target does not; // support TLS, we depend on CoalesceFeaturesAndStripAtomics to downgrade it; // to non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Modifiability,Variab,Variables,3,"// Variables created by this function are thread local. If the target does not; // support TLS, we depend on CoalesceFeaturesAndStripAtomics to downgrade it; // to non-thread-local ones, in which case we don't allow this object to be; // linked with other objects using shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Usability,Simpl,Simple,3,"// Simple function name mangler.; // This function simply takes LLVM's string representation of parameter types; // and concatenate them with '_'. There are non-alphanumeric characters but llc; // is ok with it, and we need to postprocess these names after the lowering; // phase anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:51,Usability,simpl,simply,51,"// Simple function name mangler.; // This function simply takes LLVM's string representation of parameter types; // and concatenate them with '_'. There are non-alphanumeric characters but llc; // is ok with it, and we need to postprocess these names after the lowering; // phase anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:19,Integrability,wrap,wrapper,19,"// Generate invoke wrapper seqence with preamble and postamble; // Preamble:; // __THREW__ = 0;; // Postamble:; // %__THREW__.val = __THREW__; __THREW__ = 0;; // Returns %__THREW__.val, which indicates whether an exception is thrown (or; // whether longjmp occurred), for future use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:19,Integrability,wrap,wrapper,19,// Invoke function wrapper in JavaScript,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:94,Integrability,wrap,wrapper,94,"// Put the pointer to the callee as first argument, so it can be called; // within the invoke wrapper later",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:99,Integrability,wrap,wrappers,99,"// In case the callee has 'noreturn' attribute, We need to remove it, because; // we expect invoke wrappers to return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:23,Integrability,wrap,wrapper,23,// Get matching invoke wrapper based on callee signature,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:192,Integrability,rout,routines,192,// TODO Include more functions or consider checking with mangled prefixes; // The reason we include malloc/free here is to exclude the malloc/free; // calls generated in setjmp prep / cleanup routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:12,Testability,test,testSetjmp,12,"// Generate testSetjmp function call seqence with preamble and postamble.; // The code this generates is equivalent to the following JavaScript code:; // %__threwValue.val = __threwValue;; // if (%__THREW__.val != 0 & %__threwValue.val != 0) {; // %label = testSetjmp(mem[%__THREW__.val], setjmpTable, setjmpTableSize);; // if (%label == 0); // emscripten_longjmp(%__THREW__.val, %__threwValue.val);; // setTempRet0(%__threwValue.val);; // } else {; // %label = -1;; // }; // %longjmp_result = getTempRet0();; //; // As output parameters. returns %label, %longjmp_result, and the BB the last; // instruction (%longjmp_result = ...) is in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:257,Testability,test,testSetjmp,257,"// Generate testSetjmp function call seqence with preamble and postamble.; // The code this generates is equivalent to the following JavaScript code:; // %__threwValue.val = __threwValue;; // if (%__THREW__.val != 0 & %__threwValue.val != 0) {; // %label = testSetjmp(mem[%__THREW__.val], setjmpTable, setjmpTableSize);; // if (%label == 0); // emscripten_longjmp(%__THREW__.val, %__threwValue.val);; // setTempRet0(%__threwValue.val);; // } else {; // %label = -1;; // }; // %longjmp_result = getTempRet0();; //; // As output parameters. returns %label, %longjmp_result, and the BB the last; // instruction (%longjmp_result = ...) is in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:12,Testability,test,testSetjmp,12,"// %label = testSetjmp(mem[%__THREW__.val], setjmpTable, setjmpTableSize);; // if (%label == 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:62,Availability,avail,available,62,"// If a value is defined by an invoke instruction, it is only available in; // its normal destination and not in its unwind destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:222,Availability,error,errors,222,"// When a function contains a setjmp call but not other calls that can longjmp,; // we don't do setjmp transformation for that setjmp. But we need to convert the; // setjmp calls into ""i32 0"" so they don't cause link time errors. setjmp always; // returns 0 when called directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:125,Safety,detect,detect,125,"// In some platforms _setjmp and _longjmp are used instead. Change these to; // use setjmp/longjmp instead, because we later detect these functions by; // their names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:27,Modifiability,variab,variables,27,"// Declare (or get) global variables __THREW__, __threwValue, and; // getTempRet0/setTempRet0 function which are used in common for both; // exception handling and setjmp/longjmp handling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:12,Testability,test,testSetjmp,12,// Register testSetjmp function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:32,Availability,down,down,32,// wasm.catch() will be lowered down to wasm 'catch' instruction in; // instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:24,Modifiability,variab,variables,24,// Delete unused global variables and functions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:53,Modifiability,variab,variable,53,// PHI node for the loaded value of __THREW__ global variable in; // rethrow.longjmp BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:20,Performance,load,loaded,20,// PHI node for the loaded value of __THREW__ global variable in; // rethrow.longjmp BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Integrability,Wrap,Wrap,3,// Wrap invoke with invoke wrapper and generate preamble/postamble,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:27,Integrability,wrap,wrapper,27,// Wrap invoke with invoke wrapper and generate preamble/postamble,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:38,Modifiability,variab,variable,38,// Insert a branch based on __THREW__ variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:11,Usability,resume,resume,11,// Process resume instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:40,Usability,resume,resumes,40,// Scan the body of the basic block for resumes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:82,Safety,avoid,avoid,82,"// Fix call target; // Our index in the function is our place in the array + 1 to avoid index; // 0, because index 0 means the longjmp is not ours to handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:382,Modifiability,variab,variables,382,"// Every call to saveSetjmp can change setjmpTable and setjmpTableSize; // (when buffer reallocation occurs); // entry:; // setjmpTableSize = 4;; // setjmpTable = (int *) malloc(40);; // setjmpTable[0] = 0;; // ...; // somebb:; // setjmpTable = saveSetjmp(env, label, setjmpTable, setjmpTableSize);; // setjmpTableSize = getTempRet0();; // So we need to make sure the SSA for these variables is valid so that every; // saveSetjmp and testSetjmp calls have the correct arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:434,Testability,test,testSetjmp,434,"// Every call to saveSetjmp can change setjmpTable and setjmpTableSize; // (when buffer reallocation occurs); // entry:; // setjmpTableSize = 4;; // setjmpTable = (int *) malloc(40);; // setjmpTable[0] = 0;; // ...; // somebb:; // setjmpTable = saveSetjmp(env, label, setjmpTable, setjmpTableSize);; // setjmpTableSize = getTempRet0();; // So we need to make sure the SSA for these variables is valid so that every; // saveSetjmp and testSetjmp calls have the correct arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:68,Modifiability,variab,variables,68,"// Finally, our modifications to the cfg can break dominance of SSA variables.; // For example, in this code,; // if (x()) { .. setjmp() .. }; // if (y()) { .. longjmp() .. }; // We must split the longjmp block, and it can jump into the block splitted; // from setjmp one. But that means that when we split the setjmp block, it's; // first part no longer dominates its second part - there is a theoretically; // possible control flow path where x() is false, then y() is true and we; // reach the second part of the setjmp block, without ever reaching the first; // part. So, we rebuild SSA form here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Deployability,Update,Update,3,"// Update each call that can longjmp so it can return to the corresponding; // setjmp. Refer to 4) of ""Emscripten setjmp/longjmp handling"" section in the; // comments at top of the file for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:346,Deployability,update,update,346,"// We need to pass setjmpTable and setjmpTableSize to testSetjmp function.; // These values are defined in the beginning of the function and also in each; // setjmp callsite, but we don't know which values we should use at this; // point. So here we arbitraily use the ones defined in the beginning of the; // function, and SSAUpdater will later update them to the correct values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:54,Testability,test,testSetjmp,54,"// We need to pass setjmpTable and setjmpTableSize to testSetjmp function.; // These values are defined in the beginning of the function and also in each; // setjmp callsite, but we don't know which values we should use at this; // point. So here we arbitraily use the ones defined in the beginning of the; // function, and SSAUpdater will later update them to the correct values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:53,Modifiability,variab,variable,53,// PHI node for the loaded value of __THREW__ global variable in; // call.em.longjmp BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:20,Performance,load,loaded,20,// PHI node for the loaded value of __THREW__ global variable in; // call.em.longjmp BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:56,Modifiability,variab,variable,56,// PHI node for the loaded value of __threwValue global variable in; // call.em.longjmp BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:20,Performance,load,loaded,20,// PHI node for the loaded value of __threwValue global variable in; // call.em.longjmp BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:13,Integrability,wrap,wrapper,13,"// If invoke wrapper has already been generated for this call in; // previous EH phase, search for the load instruction; // %__THREW__.val = __THREW__;; // in postamble after the invoke wrapper call",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:186,Integrability,wrap,wrapper,186,"// If invoke wrapper has already been generated for this call in; // previous EH phase, search for the load instruction; // %__THREW__.val = __THREW__;; // in postamble after the invoke wrapper call",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:103,Performance,load,load,103,"// If invoke wrapper has already been generated for this call in; // previous EH phase, search for the load instruction; // %__THREW__.val = __THREW__;; // in postamble after the invoke wrapper call",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:46,Performance,load,load,46,// Search for the store instruction after the load above; // __THREW__ = 0;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Integrability,Wrap,Wrap,3,// Wrap call with invoke wrapper and generate preamble/postamble,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:25,Integrability,wrap,wrapper,25,// Wrap call with invoke wrapper and generate preamble/postamble,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:33,Testability,test,testSetjmp,33,// New insertion point to insert testSetjmp(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:31,Testability,test,testSetjmp,31,"// Generate a function call to testSetjmp function and preamble/postamble; // code to figure out (1) whether longjmp occurred (2) if longjmp; // occurred, which setjmp it corresponds to",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:214,Safety,avoid,avoid,214,"// -1 means no longjmp happened, continue normally (will hit the default; // switch case). 0 means a longjmp that is not ours to handle, needs a; // rethrow. Otherwise the index is the same as the index in P+1 (to avoid; // 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:74,Testability,test,test,74,"// Create a catchpad in which we catch a longjmp's env and val arguments, test; // if the longjmp corresponds to one of setjmps in the current function, and if; // so, jump to the setjmp dispatch BB from which we go to one of post-setjmp; // BBs. Refer to 4) of ""Wasm setjmp/longjmp handling"" section in the comments at; // top of the file for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:96,Deployability,update,update,96,// Arbitrarily use the ones defined in the beginning of the function.; // SSAUpdater will later update them to the correct values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:165,Availability,reliab,reliable,165,"// Wasm throw and catch instructions can throw and catch multiple values, but; // that requires multivalue support in the toolchain, which is currently not; // very reliable. We instead throw and catch a pointer to a struct value of; // type 'struct __WasmLongjmpArgs', which is defined in Emscripten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:12,Testability,test,testSetjmp,12,"// %label = testSetjmp(mem[%env], setjmpTable, setjmpTableSize);; // if (%label == 0); // __wasm_longjmp(%env, %val); // catchret to %setjmp.dispatch",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:214,Safety,avoid,avoid,214,"// -1 means no longjmp happened, continue normally (will hit the default; // switch case). 0 means a longjmp that is not ours to handle, needs a; // rethrow. Otherwise the index is the same as the index in P+1 (to avoid; // 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMachineFunctionInfo.cpp:77,Performance,optimiz,optimizations,77,"// SrcToUnwindDest can contain stale mappings in case BBs are removed in; // optimizations, in case, for example, they are unreachable. We should not; // include their info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMachineFunctionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMachineFunctionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp:97,Testability,test,tests,97,"// This disables the removal of registers when lowering into MC, as required; // by some current tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp:484,Usability,simpl,simplified,484,"// Remove all uses of stackified registers to bring the instruction format; // into its final stack form used thruout MC, and transition opcodes to; // their _S variant.; // We do this separate from the above code that still may need these; // registers for e.g. call_indirect signatures.; // See comments in lib/Target/WebAssembly/WebAssemblyInstrFormats.td for; // details.; // TODO: the code above creates new registers which are then removed here.; // That code could be slightly simplified by not doing that, though maybe; // it is simpler conceptually to keep the code above in ""register mode""; // until this transition point.; // FIXME: we are not processing inline assembly, which contains register; // operands, because it is used by later target generic code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp:537,Usability,simpl,simpler,537,"// Remove all uses of stackified registers to bring the instruction format; // into its final stack form used thruout MC, and transition opcodes to; // their _S variant.; // We do this separate from the above code that still may need these; // registers for e.g. call_indirect signatures.; // See comments in lib/Target/WebAssembly/WebAssemblyInstrFormats.td for; // details.; // TODO: the code above creates new registers which are then removed here.; // That code could be slightly simplified by not doing that, though maybe; // it is simpler conceptually to keep the code above in ""register mode""; // until this transition point.; // FIXME: we are not processing inline assembly, which contains register; // operands, because it is used by later target generic code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp:1100,Energy Efficiency,reduce,reduce,1100,"//== WebAssemblyMemIntrinsicResults.cpp - Optimize memory intrinsic results ==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an optimization pass using memory intrinsic results.; ///; /// Calls to memory intrinsics (memcpy, memmove, memset) return the destination; /// address. They are in the form of; /// %dst_new = call @memcpy %dst, %src, %len; /// where %dst and %dst_new registers contain the same value.; ///; /// This is to enable an optimization wherein uses of the %dst register used in; /// the parameter can be replaced by uses of the %dst_new register used in the; /// result, making the %dst register more likely to be single-use, thus more; /// likely to be useful to register stackifying, and potentially also exposing; /// the call instruction itself to register stackifying. These both can reduce; /// local.get/local.set traffic.; ///; /// The LLVM intrinsics for these return void so they can't use the returned; /// attribute and consequently aren't handled by the OptimizeReturned pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp:42,Performance,Optimiz,Optimize,42,"//== WebAssemblyMemIntrinsicResults.cpp - Optimize memory intrinsic results ==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an optimization pass using memory intrinsic results.; ///; /// Calls to memory intrinsics (memcpy, memmove, memset) return the destination; /// address. They are in the form of; /// %dst_new = call @memcpy %dst, %src, %len; /// where %dst and %dst_new registers contain the same value.; ///; /// This is to enable an optimization wherein uses of the %dst register used in; /// the parameter can be replaced by uses of the %dst_new register used in the; /// result, making the %dst register more likely to be single-use, thus more; /// likely to be useful to register stackifying, and potentially also exposing; /// the call instruction itself to register stackifying. These both can reduce; /// local.get/local.set traffic.; ///; /// The LLVM intrinsics for these return void so they can't use the returned; /// attribute and consequently aren't handled by the OptimizeReturned pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp:420,Performance,optimiz,optimization,420,"//== WebAssemblyMemIntrinsicResults.cpp - Optimize memory intrinsic results ==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an optimization pass using memory intrinsic results.; ///; /// Calls to memory intrinsics (memcpy, memmove, memset) return the destination; /// address. They are in the form of; /// %dst_new = call @memcpy %dst, %src, %len; /// where %dst and %dst_new registers contain the same value.; ///; /// This is to enable an optimization wherein uses of the %dst register used in; /// the parameter can be replaced by uses of the %dst_new register used in the; /// result, making the %dst register more likely to be single-use, thus more; /// likely to be useful to register stackifying, and potentially also exposing; /// the call instruction itself to register stackifying. These both can reduce; /// local.get/local.set traffic.; ///; /// The LLVM intrinsics for these return void so they can't use the returned; /// attribute and consequently aren't handled by the OptimizeReturned pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp:734,Performance,optimiz,optimization,734,"//== WebAssemblyMemIntrinsicResults.cpp - Optimize memory intrinsic results ==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an optimization pass using memory intrinsic results.; ///; /// Calls to memory intrinsics (memcpy, memmove, memset) return the destination; /// address. They are in the form of; /// %dst_new = call @memcpy %dst, %src, %len; /// where %dst and %dst_new registers contain the same value.; ///; /// This is to enable an optimization wherein uses of the %dst register used in; /// the parameter can be replaced by uses of the %dst_new register used in the; /// result, making the %dst register more likely to be single-use, thus more; /// likely to be useful to register stackifying, and potentially also exposing; /// the call instruction itself to register stackifying. These both can reduce; /// local.get/local.set traffic.; ///; /// The LLVM intrinsics for these return void so they can't use the returned; /// attribute and consequently aren't handled by the OptimizeReturned pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp:1278,Performance,Optimiz,OptimizeReturned,1278,"//== WebAssemblyMemIntrinsicResults.cpp - Optimize memory intrinsic results ==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an optimization pass using memory intrinsic results.; ///; /// Calls to memory intrinsics (memcpy, memmove, memset) return the destination; /// address. They are in the form of; /// %dst_new = call @memcpy %dst, %src, %len; /// where %dst and %dst_new registers contain the same value.; ///; /// This is to enable an optimization wherein uses of the %dst register used in; /// the parameter can be replaced by uses of the %dst_new register used in the; /// result, making the %dst register more likely to be single-use, thus more; /// likely to be useful to register stackifying, and potentially also exposing; /// the call instruction itself to register stackifying. These both can reduce; /// local.get/local.set traffic.; ///; /// The LLVM intrinsics for these return void so they can't use the returned; /// attribute and consequently aren't handled by the OptimizeReturned pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp:3,Modifiability,Extend,Extend,3,// Extend ToReg's liveness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyNullifyDebugValueLists.cpp:167,Performance,optimiz,optimized,167,"// Our backend, including WebAssemblyDebugValueManager, currently cannot; // handle DBG_VALUE_LISTs correctly. So this makes them undefined, which will; // appear as ""optimized out"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyNullifyDebugValueLists.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyNullifyDebugValueLists.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp:846,Deployability,update,updates,846,"//===--- WebAssemblyOptimizeLiveIntervals.cpp - LiveInterval processing ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Optimize LiveIntervals for use in a post-RA context.; //; /// LiveIntervals normally runs before register allocation when the code is; /// only recently lowered out of SSA form, so it's uncommon for registers to; /// have multiple defs, and when they do, the defs are usually closely related.; /// Later, after coalescing, tail duplication, and other optimizations, it's; /// more common to see registers with multiple unrelated defs. This pass; /// updates LiveIntervals to distribute the value numbers across separate; /// LiveIntervals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp:396,Performance,Optimiz,Optimize,396,"//===--- WebAssemblyOptimizeLiveIntervals.cpp - LiveInterval processing ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Optimize LiveIntervals for use in a post-RA context.; //; /// LiveIntervals normally runs before register allocation when the code is; /// only recently lowered out of SSA form, so it's uncommon for registers to; /// have multiple defs, and when they do, the defs are usually closely related.; /// Later, after coalescing, tail duplication, and other optimizations, it's; /// more common to see registers with multiple unrelated defs. This pass; /// updates LiveIntervals to distribute the value numbers across separate; /// LiveIntervals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp:747,Performance,optimiz,optimizations,747,"//===--- WebAssemblyOptimizeLiveIntervals.cpp - LiveInterval processing ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Optimize LiveIntervals for use in a post-RA context.; //; /// LiveIntervals normally runs before register allocation when the code is; /// only recently lowered out of SSA form, so it's uncommon for registers to; /// have multiple defs, and when they do, the defs are usually closely related.; /// Later, after coalescing, tail duplication, and other optimizations, it's; /// more common to see registers with multiple unrelated defs. This pass; /// updates LiveIntervals to distribute the value numbers across separate; /// LiveIntervals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp:42,Performance,Optimiz,Optimize,42,"//===-- WebAssemblyOptimizeReturned.cpp - Optimize ""returned"" attributes --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Optimize calls with ""returned"" attributes for WebAssembly.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp:396,Performance,Optimiz,Optimize,396,"//===-- WebAssemblyOptimizeReturned.cpp - Optimize ""returned"" attributes --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Optimize calls with ""returned"" attributes for WebAssembly.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp:55,Performance,Optimiz,Optimiztions,55,"//===-- WebAssemblyPeephole.cpp - WebAssembly Peephole Optimiztions -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Late peephole optimizations for WebAssembly.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp:410,Performance,optimiz,optimizations,410,"//===-- WebAssemblyPeephole.cpp - WebAssembly Peephole Optimiztions -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Late peephole optimizations for WebAssembly.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp:18,Modifiability,rewrite,rewrite,18,"/// If desirable, rewrite NewReg to a drop register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp:3,Performance,Optimiz,Optimize,3,// Optimize away an explicit void return at the end of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:219,Energy Efficiency,Adapt,Adapted,219,"// Create a map of ""Register -> vector of <SlotIndex, DBG_VALUE>"".; // The SlotIndex is the slot index of the next non-debug instruction or the end; // of a BB, because DBG_VALUE's don't have slot index themselves.; // Adapted from RegisterCoalescer::buildVRegToDbgValueMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:219,Modifiability,Adapt,Adapted,219,"// Create a map of ""Register -> vector of <SlotIndex, DBG_VALUE>"".; // The SlotIndex is the slot index of the next non-debug instruction or the end; // of a BB, because DBG_VALUE's don't have slot index themselves.; // Adapted from RegisterCoalescer::buildVRegToDbgValueMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:693,Modifiability,variab,variable,693,"// This DBG_VALUE has 'Reg' (the current LiveInterval's register) as; // its operand. If this DBG_VALUE's slot index is within other; // registers' live ranges, this DBG_VALUE should be undefed. For; // example, suppose %0 and %1 are to be coalesced into %0.; // ; %0's live range starts; // %0 = value_0; // DBG_VALUE %0, !""a"", ... (a); // DBG_VALUE %1, !""b"", ... (b); // use %0; // ; %0's live range ends; // ...; // ; %1's live range starts; // %1 = value_1; // DBG_VALUE %0, !""c"", ... (c); // DBG_VALUE %1, !""d"", ... (d); // use %1; // ; %1's live range ends; //; // In this code, (b) and (c) should be set to undef. After the two; // registers are coalesced, (b) will incorrectly say the variable; // ""b""'s value is 'value_0', and (c) will also incorrectly say the; // variable ""c""'s value is value_1. Note it doesn't actually matter; // which register they are coalesced into (%0 or %1); (b) and (c); // should be set to undef as well if they are coalesced into %1.; //; // This happens DBG_VALUEs are not included when computing live; // ranges.; //; // Note that it is not possible for this DBG_VALUE to be; // simultaneously within 'Reg''s live range and one of other coalesced; // registers' live ranges because if their live ranges overlapped they; // would have not been selected as a coalescing candidate in the first; // place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:774,Modifiability,variab,variable,774,"// This DBG_VALUE has 'Reg' (the current LiveInterval's register) as; // its operand. If this DBG_VALUE's slot index is within other; // registers' live ranges, this DBG_VALUE should be undefed. For; // example, suppose %0 and %1 are to be coalesced into %0.; // ; %0's live range starts; // %0 = value_0; // DBG_VALUE %0, !""a"", ... (a); // DBG_VALUE %1, !""b"", ... (b); // use %0; // ; %0's live range ends; // ...; // ; %1's live range starts; // %1 = value_1; // DBG_VALUE %0, !""c"", ... (c); // DBG_VALUE %1, !""d"", ... (d); // use %1; // ; %1's live range ends; //; // In this code, (b) and (c) should be set to undef. After the two; // registers are coalesced, (b) will incorrectly say the variable; // ""b""'s value is 'value_0', and (c) will also incorrectly say the; // variable ""c""'s value is value_1. Note it doesn't actually matter; // which register they are coalesced into (%0 or %1); (b) and (c); // should be set to undef as well if they are coalesced into %1.; //; // This happens DBG_VALUEs are not included when computing live; // ranges.; //; // Note that it is not possible for this DBG_VALUE to be; // simultaneously within 'Reg''s live range and one of other coalesced; // registers' live ranges because if their live ranges overlapped they; // would have not been selected as a coalescing candidate in the first; // place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:52,Performance,perform,perform,52,"// If there are calls to setjmp or sigsetjmp, don't perform coloring. Virtual; // registers could be modified before the longjmp is executed, resulting in; // the wrong value being used afterwards.; // TODO: Does WebAssembly need to care about setjmp for register coloring?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:39,Deployability,update,update,39,"// If we reassigned the stack pointer, update the debug frame base info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite register operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegColoring.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegisterInfo.cpp:39,Performance,load,load,39,"// If this is the address operand of a load or store, make it relative to SP; // and fold the frame offset directly in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegisterInfo.cpp:168,Performance,optimiz,optimize,168,// TODO: For now we just opportunistically do this in the case where; // the CONST_I32/64 happens to have exactly one def and one use. We; // should generalize this to optimize in more cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegNumbering.cpp:75,Modifiability,variab,variables,75,// WebAssembly argument registers are in the same index space as local; // variables. Assign the numbers for them first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegNumbering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegNumbering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:774,Performance,optimiz,optimization,774,"//===-- WebAssemblyRegStackify.cpp - Register Stackification --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a register stacking pass.; ///; /// This pass reorders instructions to put register uses and defs in an order; /// such that they form single-use expression trees. Registers fitting this form; /// are then marked as ""stackified"", meaning references to them are replaced by; /// ""push"" and ""pop"" from the value stack.; ///; /// This is primarily a code size optimization, since temporary values on the; /// value stack don't need to be named.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:13,Performance,load,loads,13,// Check for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:19,Security,access,accesses,19,"// Record volatile accesses, unless it's a call, as calls are handled; // specially below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:214,Safety,safe,safe,214,"// These instructions have hasUnmodeledSideEffects() returning true; // because they trap on overflow and invalid so they can't be arbitrarily; // moved, however in the specific case of register stackifying, it is safe; // to move them because overflow and invalid are Undefined Behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:23,Safety,safe,safe,23,// Test whether Def is safe and profitable to rematerialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:3,Testability,Test,Test,3,// Test whether Def is safe and profitable to rematerialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:3,Testability,Test,Test,3,"// Test whether Reg, as defined at Def, has exactly one use. This is a; // generalization of MachineRegisterInfo::hasOneNonDBGUse that uses; // LiveIntervals to handle complex cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:86,Integrability,depend,dependencies,86,// Test whether it's safe to move Def to just before Insert.; // TODO: Compute memory dependencies in a way that doesn't require always; // walking the block.; // TODO: Compute memory dependencies in a way that uses AliasAnalysis to be; // more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:184,Integrability,depend,dependencies,184,// Test whether it's safe to move Def to just before Insert.; // TODO: Compute memory dependencies in a way that doesn't require always; // walking the block.; // TODO: Compute memory dependencies in a way that uses AliasAnalysis to be; // more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:21,Safety,safe,safe,21,// Test whether it's safe to move Def to just before Insert.; // TODO: Compute memory dependencies in a way that doesn't require always; // walking the block.; // TODO: Compute memory dependencies in a way that uses AliasAnalysis to be; // more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:3,Testability,Test,Test,3,// Test whether it's safe to move Def to just before Insert.; // TODO: Compute memory dependencies in a way that doesn't require always; // walking the block.; // TODO: Compute memory dependencies in a way that uses AliasAnalysis to be; // more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:22,Integrability,depend,dependencies,22,// Check for register dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:88,Availability,down,down,88,"// Ignore ARGUMENTS; it's just used to keep the ARGUMENT_* instructions; // from moving down, and we've already checked for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:95,Integrability,depend,dependencies,95,"// If the instruction does not access memory and has no side effects, it has; // no additional dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:31,Security,access,access,31,"// If the instruction does not access memory and has no side effects, it has; // no additional dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:4,Testability,Test,Test,4,"/// Test whether OneUse, a use of Reg, dominates all of Reg's other uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:3,Testability,Test,Test,3,// Test that the use is dominated by the one selected use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:46,Testability,Test,Test,46,"// Actually, dominating is over-conservative. Test that the use would; // happen after the one selected use in the stack evaluation order.; //; // This is needed as a consequence of using implicit local.gets for; // uses and implicit local.sets for defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:110,Availability,down,down,110,/// A single-use def in the same block with no intervening memory or register; /// dependencies; move the def down and nest it with the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:83,Integrability,depend,dependencies,83,/// A single-use def in the same block with no intervening memory or register; /// dependencies; move the def down and nest it with the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:112,Availability,down,down,112,"/// A multiple-use def in the same block with no intervening memory or register; /// dependencies; move the def down, nest it with the current instruction, and; /// insert a tee to satisfy the rest of the uses. As an illustration, rewrite; /// this:; ///; /// Reg = INST ... // Def; /// INST ..., Reg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// to this:; ///; /// DefReg = INST ... // Def (to become the new Insert); /// TeeReg, Reg = TEE_... DefReg; /// INST ..., TeeReg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// with DefReg and TeeReg stackified. This eliminates a local.get from the; /// resulting code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:85,Integrability,depend,dependencies,85,"/// A multiple-use def in the same block with no intervening memory or register; /// dependencies; move the def down, nest it with the current instruction, and; /// insert a tee to satisfy the rest of the uses. As an illustration, rewrite; /// this:; ///; /// Reg = INST ... // Def; /// INST ..., Reg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// to this:; ///; /// DefReg = INST ... // Def (to become the new Insert); /// TeeReg, Reg = TEE_... DefReg; /// INST ..., TeeReg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// with DefReg and TeeReg stackified. This eliminates a local.get from the; /// resulting code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:231,Modifiability,rewrite,rewrite,231,"/// A multiple-use def in the same block with no intervening memory or register; /// dependencies; move the def down, nest it with the current instruction, and; /// insert a tee to satisfy the rest of the uses. As an illustration, rewrite; /// this:; ///; /// Reg = INST ... // Def; /// INST ..., Reg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// to this:; ///; /// DefReg = INST ... // Def (to become the new Insert); /// TeeReg, Reg = TEE_... DefReg; /// INST ..., TeeReg, ... // Insert; /// INST ..., Reg, ...; /// INST ..., Reg, ...; ///; /// with DefReg and TeeReg stackified. This eliminates a local.get from the; /// resulting code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:4,Testability,Test,Test,4,/// Test whether Instr has operands remaining to be visited at the top of; /// the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:4,Testability,Test,Test,4,"/// Test whether the given register is present on the stack, indicating an; /// operand in the tree that we haven't visited yet. Moving a definition of; /// Reg to a point in the tree after that would change its value.; ///; /// This is needed as a consequence of using implicit local.gets for; /// uses and implicit local.sets for defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:225,Usability,simpl,simpler,225,"// Decide which strategy to take. Prefer to move a single-use value; // over cloning it, and prefer cloning over introducing a tee.; // For moving, we require the def to be in the same block as the use;; // this makes things simpler (LiveIntervals' handleMove function only; // supports intra-block moves) and it's MachineSink's job to catch all; // the sinking opportunities anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:35,Performance,perform,performed,35,// Verify that pushes and pops are performed in LIFO order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp:43,Integrability,rout,routines,43,// Floating-point.; // All F80 and PPCF128 routines are unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp:38,Integrability,rout,routines,38,// Conversion; // All F80 and PPCF128 routines are unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp:38,Integrability,rout,routines,38,// Comparison; // ALl F80 and PPCF128 routines are unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp:112,Modifiability,variab,variable,112,// Maps libcall names to their RTLIB::Libcall number. Builds the map in a; // constructor for use with a static variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp:111,Testability,log,logic,111,"// TODO: If the RTLIB::Libcall-taking flavor of GetSignature remains unused; // other than here, just roll its logic into this version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp:59,Performance,load,loads,59,"//=- WebAssemblySetP2AlignOperands.cpp - Set alignments on loads and stores -=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file sets the p2align operands on load and store instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp:435,Performance,load,load,435,"//=- WebAssemblySetP2AlignOperands.cpp - Set alignments on loads and stores -=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file sets the p2align operands on load and store instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySortRegion.h:3,Integrability,Wrap,Wrapper,3,// Wrapper for loops and exceptions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySortRegion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySortRegion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp:202,Performance,optimiz,optimizations,202,"// Disable the MachineScheduler for now. Even with ShouldTrackPressure set and; // enableMachineSchedDefaultSched overridden, it appears to have an overall; // negative effect for the kinds of register optimizations we're doing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:72,Testability,test,testing,72,"// A command-line option to keep implicit locals; // for the purpose of testing with lit/llc ONLY.; // This produces output which is not valid WebAssembly, and is not supported; // by assemblers/disassemblers and other MC based tools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:113,Integrability,interface,interface,113,//===----------------------------------------------------------------------===//; // WebAssembly Lowering public interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:138,Availability,failure,failure,138,"// WebAssembly type-checks instructions, but a noreturn function with a return; // type that doesn't match the context will cause a check failure. So we lower; // LLVM 'unreachable' to ISD::TRAP and then lower that to WebAssembly's; // 'unreachable' instructions which is meant for that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:74,Performance,optimiz,optimizations,74,"// Note that we don't use setRequiresStructuredCFG(true). It disables; // optimizations than we're ok with, and want, such as critical edge; // splitting and tail merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:3,Safety,Detect,Detect,3,"// Detect whether any atomics will be lowered, since there is no way to tell; // whether the LowerAtomic pass lowers e.g. stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:268,Safety,unsafe,unsafe,268,"// Code compiled without atomics or bulk-memory may have had its atomics or; // thread-local data lowered to nonatomic operations or non-thread-local; // data. In that case, we mark the pseudo-feature ""shared-mem"" as disallowed; // to tell the linker that it would be unsafe to allow this code ot be used; // in a module with shared memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:36,Deployability,Configurat,Configuration,36,/// WebAssembly Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:36,Modifiability,Config,Configuration,36,/// WebAssembly Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:590,Deployability,update,updated,590,"// Before checking, we make sure TargetOptions.ExceptionModel is the same as; // MCAsmInfo.ExceptionsType. Normally these have to be the same, because clang; // stores the exception model info in LangOptions, which is later transferred; // to TargetOptions and MCAsmInfo. But when clang compiles bitcode directly,; // clang's LangOptions is not used and thus the exception model info is not; // correctly transferred to TargetOptions and MCAsmInfo, so we make sure we; // have the correct exception model in WebAssemblyMCAsmInfo constructor.; // But in this case TargetOptions is still not updated, so we make sure they; // are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:109,Availability,error,error,109,"// Currently it is allowed to mix Wasm EH with Emscripten SjLj as an interim; // measure, but some code will error out at compile time in this combination.; // See WebAssemblyLowerEmscriptenEHSjLj pass for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize ""returned"" function attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:52,Energy Efficiency,Schedul,ScheduleDAG,52,// Run the argument-move pass immediately after the ScheduleDAG scheduler; // so that we can fix up the ARGUMENT instructions before anything else; // sees them in the wrong place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:64,Energy Efficiency,schedul,scheduler,64,// Run the argument-move pass immediately after the ScheduleDAG scheduler; // so that we can fix up the ARGUMENT instructions before anything else; // sees them in the wrong place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:132,Deployability,update,update,132,"// Set the p2align operands. This information is present during ISel, however; // it's inconvenient to collect. Collect it now, and update the immediate; // operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:246,Testability,benchmark,benchmarks,246,"// Currently RegisterCoalesce degrades wasm debug info quality by a; // significant margin. As a quick fix, disable this for -O1, which is often; // used for debugging large applications. Disabling this increases code size; // of Emscripten core benchmarks by ~5%, which is acceptable for -O1, which is; // usually not used for production builds.; // TODO Investigate why RegisterCoalesce degrades debug info quality and fix; // it properly",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:77,Performance,optimiz,optimizations,77,// Do various transformations for exception handling.; // Every CFG-changing optimizations should come before this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:20,Performance,optimiz,optimizations,20,// Preparations and optimizations related to register stackification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:3,Integrability,Depend,Depend,3,// Depend on LiveIntervals and perform some optimizations on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:31,Performance,perform,perform,31,// Depend on LiveIntervals and perform some optimizations on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:44,Performance,optimiz,optimizations,44,// Depend on LiveIntervals and perform some optimizations on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:37,Energy Efficiency,reduce,reduce,37,// Run the register coloring pass to reduce the total number of registers.; // This runs after stackification so that it doesn't consider registers; // that become stackified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:3,Performance,Perform,Perform,3,// Perform the very last peephole optimizations on the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:34,Performance,optimiz,optimizations,34,// Perform the very last peephole optimizations on the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp:24,Performance,optimiz,optimizing,24,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp:30,Performance,optimiz,optimized,30,"// Set number of instructions optimized when ""back edge""; // becomes ""fall through"" to default value of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyUtilities.cpp:4,Testability,Test,Test,4,/// Test whether MI is a child of some other node in an expression tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyUtilities.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyUtilities.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:9,Performance,load,load,9,// Parse load/store operands of the form: offset:p2align=align,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:9,Performance,load,load,9,"// v128.{load,store}{8,16,32,64}_lane has both a memarg and a lane; // index. We need to avoid parsing an extra alignment operand for the; // lane index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:89,Safety,avoid,avoid,89,"// v128.{load,store}{8,16,32,64}_lane has both a memarg and a lane; // index. We need to avoid parsing an extra alignment operand for the; // lane index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:3,Modifiability,Extend,Extend,3,// Extend name with /,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:43,Availability,error,error,43,"// We must now find another identifier, or error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:468,Safety,detect,detect,468,"// We push 'Function' either when a label is parsed or a .functype; // directive is parsed. The reason it is not easy to do this uniformly; // in a single place is,; // 1. We can't do this at label parsing time only because there are; // cases we don't have .functype directive before a function label,; // in which case we don't know if the label is a function at the time; // of parsing.; // 2. We can't do this at .functype parsing time only because we want to; // detect a function started with a label and not ended correctly; // without encountering a .functype directive after the label.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade 32-bit loads/stores to 64-bit. These mostly differ by having; // an offset64 arg instead of offset32, but to the assembler matcher; // they're both immediates so don't get selected for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:18,Performance,load,loads,18,"// Upgrade 32-bit loads/stores to 64-bit. These mostly differ by having; // an offset64 arg instead of offset32, but to the assembler matcher; // they're both immediates so don't get selected for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:272,Availability,error,error,272,"// We give the location of the label (IDLoc) here, because otherwise the; // lexer's next location will be used, which can be confusing. For; // example:; //; // test0: ; This function does not end properly; // ...; //; // test1: ; We would like to point to this line for error; // ... . Not this line, which can contain any instruction",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp:25,Availability,error,error,25,"// Once you get one type error in a function, it will likely trigger more; // which are mostly not helpful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp:55,Availability,error,errors,55,"// If we're currently in unreachable code, we suppress errors completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Disassembler/WebAssemblyDisassembler.cpp:17,Security,access,access,17,"// We don't have access to the signature, so create a symbol without one",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/Disassembler/WebAssemblyDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Disassembler/WebAssemblyDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:51,Testability,test,tests,51,// Skip type and table arguments when printing for tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:122,Availability,recover,recover,122,"// call_indirect instructions have a TYPEINDEX operand that we print; // as a signature here, such that the assembler can recover this; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:122,Safety,recover,recover,122,"// call_indirect instructions have a TYPEINDEX operand that we print; // as a signature here, such that the assembler can recover this; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h:26,Performance,load,load,26,/// p2align immediate for load and store address alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h:43,Performance,load,load,43,/// Return the default p2align value for a load or store with the given opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyTargetStreamer.h:34,Integrability,interface,interface,34,"/// WebAssembly-specific streamer interface, to implement support; /// WebAssembly-specific assembly directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Utils/WasmAddressSpaces.h:135,Performance,Load,Loads,135,"// A non-integral address space for pointers to named objects outside of; // linear memory: WebAssembly globals or WebAssembly locals. Loads and stores; // to these pointers are lowered to global.get / global.set or local.get /; // local.set, as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/WebAssembly/Utils/WasmAddressSpaces.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Utils/WasmAddressSpaces.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:792,Energy Efficiency,efficient,efficient,792,"//==========-- ImmutableGraph.h - A fast DAG implementation ---------=========//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Description: ImmutableGraph is a fast DAG implementation that cannot be; /// modified, except by creating a new ImmutableGraph. ImmutableGraph is; /// implemented as two arrays: one containing nodes, and one containing edges.; /// The advantages to this implementation are two-fold:; /// 1. Iteration and traversal operations benefit from cache locality.; /// 2. Operations on sets of nodes/edges are efficient, and representations of; /// those sets in memory are compact. For instance, a set of edges is; /// implemented as a bit vector, wherein each bit corresponds to one edge in; /// the edge array. This implies a lower bound of 64x spatial improvement; /// over, e.g., an llvm::DenseSet or llvm::SmallSet. It also means that; /// insert/erase/contains operations complete in negligible constant time:; /// insert and erase require one load and one store, and contains requires; /// just one load.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:730,Performance,cache,cache,730,"//==========-- ImmutableGraph.h - A fast DAG implementation ---------=========//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Description: ImmutableGraph is a fast DAG implementation that cannot be; /// modified, except by creating a new ImmutableGraph. ImmutableGraph is; /// implemented as two arrays: one containing nodes, and one containing edges.; /// The advantages to this implementation are two-fold:; /// 1. Iteration and traversal operations benefit from cache locality.; /// 2. Operations on sets of nodes/edges are efficient, and representations of; /// those sets in memory are compact. For instance, a set of edges is; /// implemented as a bit vector, wherein each bit corresponds to one edge in; /// the edge array. This implies a lower bound of 64x spatial improvement; /// over, e.g., an llvm::DenseSet or llvm::SmallSet. It also means that; /// insert/erase/contains operations complete in negligible constant time:; /// insert and erase require one load and one store, and contains requires; /// just one load.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:1233,Performance,load,load,1233,"//==========-- ImmutableGraph.h - A fast DAG implementation ---------=========//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Description: ImmutableGraph is a fast DAG implementation that cannot be; /// modified, except by creating a new ImmutableGraph. ImmutableGraph is; /// implemented as two arrays: one containing nodes, and one containing edges.; /// The advantages to this implementation are two-fold:; /// 1. Iteration and traversal operations benefit from cache locality.; /// 2. Operations on sets of nodes/edges are efficient, and representations of; /// those sets in memory are compact. For instance, a set of edges is; /// implemented as a bit vector, wherein each bit corresponds to one edge in; /// the edge array. This implies a lower bound of 64x spatial improvement; /// over, e.g., an llvm::DenseSet or llvm::SmallSet. It also means that; /// insert/erase/contains operations complete in negligible constant time:; /// insert and erase require one load and one store, and contains requires; /// just one load.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:1289,Performance,load,load,1289,"//==========-- ImmutableGraph.h - A fast DAG implementation ---------=========//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Description: ImmutableGraph is a fast DAG implementation that cannot be; /// modified, except by creating a new ImmutableGraph. ImmutableGraph is; /// implemented as two arrays: one containing nodes, and one containing edges.; /// The advantages to this implementation are two-fold:; /// 1. Iteration and traversal operations benefit from cache locality.; /// 2. Operations on sets of nodes/edges are efficient, and representations of; /// those sets in memory are compact. For instance, a set of edges is; /// implemented as a bit vector, wherein each bit corresponds to one edge in; /// the edge array. This implies a lower bound of 64x spatial improvement; /// over, e.g., an llvm::DenseSet or llvm::SmallSet. It also means that; /// insert/erase/contains operations complete in negligible constant time:; /// insert and erase require one load and one store, and contains requires; /// just one load.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:13,Energy Efficiency,allocate,allocated,13,// Nodes are allocated sequentially. Edges for a node are stored together.; // The end of this Node's edges is the beginning of the next node's edges.; // An extra node was allocated to hold the end pointer for the last real; // node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:173,Energy Efficiency,allocate,allocated,173,// Nodes are allocated sequentially. Edges for a node are stored together.; // The end of this Node's edges is the beginning of the next node's edges.; // An extra node was allocated to hold the end pointer for the last real; // node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:26,Integrability,interface,interface,26,"//===-- X86.h - Top-level interface for X86 representation ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the x86; // target library, as used by the LLVM JIT.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:91,Energy Efficiency,schedul,scheduling,91,"/// This pass converts a legalized DAG into a X86-specific DAG, ready for; /// instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:62,Modifiability,variab,variables,62,/// This pass combines multiple accesses to local-dynamic TLS variables so that; /// the TLS base address for the module is only fetched once per execution path; /// through the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:32,Security,access,accesses,32,/// This pass combines multiple accesses to local-dynamic TLS variables so that; /// the TLS base address for the module is only fetched once per execution path; /// through the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:70,Safety,avoid,avoid,70,/// This pass inserts AVX vzeroupper instructions before each call to avoid; /// transition penalty between functions encoded with AVX and SSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,Energy Efficiency,reduce,reduces,23,/// Return a pass that reduces the size of vector constant pool loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:64,Performance,load,loads,64,/// Return a pass that reduces the size of vector constant pool loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:31,Availability,redundant,redundant,31,/// Return a pass that removes redundant LEA instructions and redundant address; /// recalculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:62,Availability,redundant,redundant,62,/// Return a pass that removes redundant LEA instructions and redundant address; /// recalculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:31,Safety,redund,redundant,31,/// Return a pass that removes redundant LEA instructions and redundant address; /// recalculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:62,Safety,redund,redundant,62,/// Return a pass that removes redundant LEA instructions and redundant address; /// recalculations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,Safety,avoid,avoids,23,/// Return a pass that avoids creating store forward block issues in the hardware.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,Modifiability,config,config,23,/// Return a pass that config the tile registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,Modifiability,config,config,23,/// Return a pass that config the tile registers after fast reg allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:42,Modifiability,config,config,42,/// Return a pass that insert pseudo tile config instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,Performance,optimiz,optimizes,23,/// Return a pass that optimizes the code-size of x86 call sequences. This is; /// done by replacing esp-relative movs with pushes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:92,Deployability,update,updates,92,"/// Return an IR pass that inserts EH registration stack objects and explicit; /// EH state updates. This pass must run after EH preparation, which does; /// Windows-specific but architecture-neutral preparation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:187,Integrability,depend,dependences,187,"/// Return a Machine IR pass that selectively replaces; /// certain byte and word instructions by equivalent 32 bit instructions,; /// in order to eliminate partial register usage, false dependences on; /// the upper portions of registers, and to save code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:108,Energy Efficiency,reduce,reduce,108,/// This pass compress instructions from EVEX space to legacy/VEX/EVEX space when; /// possible in order to reduce code size or facilitate HW decoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:54,Performance,cache,cache,54,/// This pass applies profiling information to insert cache prefetches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:14,Performance,optimiz,optimizes,14,/// This pass optimizes arithmetic based on knowledge that is only used by; /// a reduction sequence and is therefore safe to reassociate in interesting; /// ways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:118,Safety,safe,safe,118,/// This pass optimizes arithmetic based on knowledge that is only used by; /// a reduction sequence and is therefore safe to reassociate in interesting; /// ways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- X86AsmPrinter.cpp - Convert X86 LLVM code to AT&T assembly --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to X86 machine code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:48,Availability,mask,mask,48,"// If the type hash matches an invalid pattern, mask the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:15,Security,hash,hash,15,"// If the type hash matches an invalid pattern, mask the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:78,Availability,mask,mask,78,"// LowerKCFI_CHECK emits -Value for indirect call checks, so we must also; // mask that. Note that -(Value + 1) == ~Value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:43,Deployability,patch,patchable-function-prefix,43,"// Keep the function entry aligned, taking patchable-function-prefix into; // account if set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:47,Safety,avoid,avoid,47,"// Emit a function symbol for the type data to avoid unreachable instruction; // warnings from binary validation tools, and use the same linkage as the; // parent function. Note that using local linkage would result in duplicate; // symbols for weak parent functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:102,Security,validat,validation,102,"// Emit a function symbol for the type data to avoid unreachable instruction; // warnings from binary validation tools, and use the same linkage as the; // parent function. Note that using local linkage would result in duplicate; // symbols for weak parent functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:58,Safety,avoid,avoid,58,// Embed the type hash in the X86::MOV32ri instruction to avoid special; // casing object file parsers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:18,Security,hash,hash,18,// Embed the type hash in the X86::MOV32ri instruction to avoid special; // casing object file parsers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:82,Safety,avoid,avoid,82,"// If the name begins with a dollar-sign, enclose it in parens. We do this; // to avoid having it look like an integer immediate to the assembler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:63,Availability,avail,available,63,"// Print 64-bit register names if 64-bit integer registers are available.; // Otherwise, print 32-bit register names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:352,Safety,safe,safe,352,"// According to the PE-COFF spec, the LSB of this value marks the object; // for ""registered SEH"". This means that all SEH handler entry points; // must be registered in .sxdata. Use of any unregistered handlers will; // cause the process to terminate immediately. LLVM does not know how to; // register any SEH handlers, so its object files should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:9,Testability,stub,stub,9,// L_foo$stub:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:10,Testability,stub,stubs,10,// Output stubs for dynamically-linked functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:47,Modifiability,variab,variables,47,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:10,Testability,stub,stubs,10,// Output stubs for external and common global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:31,Testability,stub,stubs,31,// Mach-O uses non-lazy symbol stubs to encode per-TU information into; // global table for symbol lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:8,Availability,fault,fault,8,// Emit fault map information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:212,Performance,perform,perform,212,"// This flag tells the linker that no global symbols contain code that fall; // through to other global symbols (e.g. an implementation of multiple entry; // points). If this doesn't occur, the linker can safely perform dead code; // stripping. Since LLVM never generates code that does this, it is always; // safe to set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:205,Safety,safe,safely,205,"// This flag tells the linker that no global symbols contain code that fall; // through to other global symbols (e.g. an implementation of multiple entry; // points). If this doesn't occur, the linker can safely perform dead code; // stripping. Since LLVM never generates code that does this, it is always; // safe to set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:310,Safety,safe,safe,310,"// This flag tells the linker that no global symbols contain code that fall; // through to other global symbols (e.g. an implementation of multiple entry; // points). If this doesn't occur, the linker can safely perform dead code; // stripping. Since LLVM never generates code that does this, it is always; // safe to set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:303,Integrability,rout,routines,303,"// In Windows' libcmt.lib, there is a file which is linked in only if the; // symbol _fltused is referenced. Linking this in causes some; // side-effects:; //; // 1. For x86-32, it will set the x87 rounding mode to 53-bit instead of; // 64-bit mantissas at program start.; //; // 2. It links in support routines for floating-point in scanf and printf.; //; // MSVC emits an undefined reference to _fltused when there are any; // floating point operations in the program (including calls). A program; // that only has: `scanf(""%f"", &global_float);` may fail to trigger this,; // but oh well...that's a documented issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h:190,Deployability,patch,patchpoints,190,"// This utility class tracks the length of a stackmap instruction's 'shadow'.; // It is used by the X86AsmPrinter to ensure that the stackmap shadow; // invariants (i.e. no other stackmaps, patchpoints, or control flow within; // the shadow) are met, while outputting a minimal number of NOPs for padding.; //; // To minimise the number of NOPs used, the shadow tracker counts the number; // of instruction bytes output since the last stackmap. Only if there are too; // few instruction bytes to cover the shadow are NOPs used for padding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h:32,Deployability,patch,patchpoint,32,"// Called before every stackmap/patchpoint, and at the end of basic blocks,; // to emit any necessary padding-NOPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h:11,Security,sanitiz,sanitizer,11,// Address sanitizer specific lowering for X86.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:388,Performance,load,load,388,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:563,Performance,load,load,563,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:626,Performance,load,load,626,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:698,Performance,cache,cache,698,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:803,Performance,load,load,803,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:940,Performance,load,load,940,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1176,Performance,load,load,1176,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1429,Performance,load,loads,1429,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1489,Performance,perform,performance,1489,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1525,Performance,load,loading,1525,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1673,Performance,optimiz,optimization,1673,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1781,Performance,load,load,1781,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:43,Safety,Avoid,Avoid,43,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:670,Security,access,accessing,670,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1733,Security,access,accesses,1733,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1918,Security,access,accesses,1918,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:23,Performance,Load,Load,23,/// Returns couples of Load then Store to memory which look; /// like a memcpy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:23,Performance,load,load,23,/// Break the memcpy's load and store into smaller copies; /// such that each memory load that was blocked by a smaller store; /// would now be copied separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:85,Performance,load,load,85,/// Break the memcpy's load and store into smaller copies; /// such that each memory load that was blocked by a smaller store; /// would now be copied separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:180,Performance,load,load,180,// Collect potentially blocking stores.; // Limit the number of instructions backwards we want to inspect; // since the effect of store block won't be visible if the store; // and load instructions have enough instructions in between to; // keep the core busy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:75,Energy Efficiency,reduce,reduce,75,"// If the load and store are consecutive, use the loadInst location to; // reduce register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:10,Performance,load,load,10,"// If the load and store are consecutive, use the loadInst location to; // reduce register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:50,Performance,load,loadInst,50,"// If the load and store are consecutive, use the loadInst location to; // reduce register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:138,Energy Efficiency,reduce,reduce,138,"// If the original load and store to xmm/ymm were consecutive; // then the partial copies were also created in; // a consecutive order to reduce register pressure,; // and the location of the last load is before the last store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:19,Performance,load,load,19,"// If the original load and store to xmm/ymm were consecutive; // then the partial copies were also created in; // a consecutive order to reduce register pressure,; // and the location of the last load is before the last store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:197,Performance,load,load,197,"// If the original load and store to xmm/ymm were consecutive; // then the partial copies were also created in; // a consecutive order to reduce register pressure,; // and the location of the last load is before the last store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:3,Safety,Avoid,Avoid,3,// Avoid copying overlapping areas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:39,Performance,load,load,39,// Keep track of all stores blocking a load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:14,Performance,load,load,14,// Look for a load then a store to XMM/YMM which look like a memcpy,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:210,Performance,perform,performance,210,"// This check doesn't cover all cases, but it will suffice for now.; // TODO: take branch probability into consideration, if the blocking; // store is in an unreached block, breaking the memcopy could lose; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:54,Performance,load,load,54,"// We found a store forward block, break the memcpy's load and store; // into smaller copies such that each smaller store that was causing; // a store block would now be copied separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidTrailingCall.cpp:513,Safety,detect,detect,513,"//===----- X86AvoidTrailingCall.cpp - Insert int3 after trailing calls ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The Windows x64 unwinder decodes the instruction stream during unwinding.; // The unwinder decodes forward from the current PC to detect epilogue code; // patterns.; //; // First, this means that there must be an instruction after every; // call instruction for the unwinder to decode. LLVM must maintain the invariant; // that the last instruction of a function or funclet is not a call, or the; // unwinder may decode into the next function. Similarly, a call may not; // immediately precede an epilogue code pattern. As of this writing, the; // SEH_Epilogue pseudo instruction takes care of that.; //; // Second, all non-tail call jump targets must be within the *half-open*; // interval of the bounds of the function. The unwinder distinguishes between; // internal jump instructions and tail calls in an epilogue sequence by checking; // the jump target against the function bounds from the .pdata section. This; // means that the last regular MBB of an LLVM function must not be empty if; // there are regular jumps targeting it.; //; // This pass upholds these invariants by ensuring that blocks at the end of a; // function or funclet are a) not empty and b) do not end in a CALL instruction.; //; // Unwinder implementation for reference:; // https://github.com/dotnet/coreclr/blob/a9f3fc16483eecfc47fb79c362811d870be02249/src/unwinder/amd64/unwinder_amd64.cpp#L1015; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidTrailingCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidTrailingCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidTrailingCall.cpp:127,Testability,log,logic,127,"// A real instruction is a non-meta, non-pseudo instruction. Some pseudos; // expand to nothing, and some expand to code. This logic conservatively assumes; // they might expand to nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidTrailingCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidTrailingCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:42,Performance,Optimiz,Optimize,42,"//===----- X86CallFrameOptimization.cpp - Optimize x86 call sequences -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that optimizes call sequences on x86.; // Currently, it converts movs of function parameters onto the stack into; // pushes. This is beneficial for two main reasons:; // 1) The push instruction encoding is much smaller than a stack-ptr-based mov.; // 2) It is possible to push memory arguments directly. So, if the; // the transformation is performed pre-reg-alloc, it can help relieve; // register pressure.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:413,Performance,optimiz,optimizes,413,"//===----- X86CallFrameOptimization.cpp - Optimize x86 call sequences -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that optimizes call sequences on x86.; // Currently, it converts movs of function parameters onto the stack into; // pushes. This is beneficial for two main reasons:; // 1) The push instruction encoding is much smaller than a stack-ptr-based mov.; // 2) It is possible to push memory arguments directly. So, if the; // the transformation is performed pre-reg-alloc, it can help relieve; // register pressure.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:749,Performance,perform,performed,749,"//===----- X86CallFrameOptimization.cpp - Optimize x86 call sequences -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that optimizes call sequences on x86.; // Currently, it converts movs of function parameters onto the stack into; // pushes. This is beneficial for two main reasons:; // 1) The push instruction encoding is much smaller than a stack-ptr-based mov.; // 2) It is possible to push memory arguments directly. So, if the; // the transformation is performed pre-reg-alloc, it can help relieve; // register pressure.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:498,Energy Efficiency,allocate,allocates,498,"// You would expect straight-line code between call-frame setup and; // call-frame destroy. You would be wrong. There are circumstances (e.g.; // CMOV_GR8 expansion of a select that feeds a function call!) where we can; // end up with the setup and the destroy in different basic blocks.; // This is bad, and breaks SP adjustment.; // So, check that all of the frames in the function are closed inside; // the same block, and, for good measure, that there are no nested frames.; //; // If any call allocates more argument stack memory than the stack; // probe size, don't do this optimization. Otherwise, this pass; // would need to synthesize additional stack probe calls to allocate; // memory for arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:676,Energy Efficiency,allocate,allocate,676,"// You would expect straight-line code between call-frame setup and; // call-frame destroy. You would be wrong. There are circumstances (e.g.; // CMOV_GR8 expansion of a select that feeds a function call!) where we can; // end up with the setup and the destroy in different basic blocks.; // This is bad, and breaks SP adjustment.; // So, check that all of the frames in the function are closed inside; // the same block, and, for good measure, that there are no nested frames.; //; // If any call allocates more argument stack memory than the stack; // probe size, don't do this optimization. Otherwise, this pass; // would need to synthesize additional stack probe calls to allocate; // memory for arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:580,Performance,optimiz,optimization,580,"// You would expect straight-line code between call-frame setup and; // call-frame destroy. You would be wrong. There are circumstances (e.g.; // CMOV_GR8 expansion of a select that feeds a function call!) where we can; // end up with the setup and the destroy in different basic blocks.; // This is bad, and breaks SP adjustment.; // So, check that all of the frames in the function are closed inside; // the same block, and, for good measure, that there are no nested frames.; //; // If any call allocates more argument stack memory than the stack; // probe size, don't do this optimization. Otherwise, this pass; // would need to synthesize additional stack probe calls to allocate; // memory for arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:185,Integrability,depend,depending,185,"// If we don't use pushes for a particular call site,; // we pay for not having a reserved call frame with an; // additional sub/add esp pair. The cost is ~3 bytes per instruction,; // depending on the size of the constant.; // TODO: Callee-pop functions should have a smaller penalty, because; // an add is needed even with a reserved call frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:110,Availability,toler,tolerate,110,"// Not all calling conventions have only stack MOVs between the stack; // adjust and the call.; // We want to tolerate other instructions, to cover more cases.; // In particular:; // a) PCrel calls, where we expect an additional COPY of the basereg.; // b) Passing frame-index addresses.; // c) Calling conventions that have inreg parameters. These generate; // both copies and movs into registers.; // To avoid creating lots of special cases, allow any instruction; // that does not write into memory, does not def or use the stack; // pointer, and does not def any register that was used by a preceding; // push.; // (Reading from memory is allowed, even if referenced through a; // frame index, since these will get adjusted properly in PEI); // The reason for the last condition is that the pushes can't replace; // the movs in place, because the order must be reversed.; // So if we have a MOV32mr that uses EDX, then an instruction that defs; // EDX, and then the call, after the transformation the push will use; // the modified version of EDX, and not the original one.; // Since we are still in SSA form at this point, we only need to; // make sure we don't clobber any *physical* registers that were; // used by an earlier mov that will become a push.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:406,Safety,avoid,avoid,406,"// Not all calling conventions have only stack MOVs between the stack; // adjust and the call.; // We want to tolerate other instructions, to cover more cases.; // In particular:; // a) PCrel calls, where we expect an additional COPY of the basereg.; // b) Passing frame-index addresses.; // c) Calling conventions that have inreg parameters. These generate; // both copies and movs into registers.; // To avoid creating lots of special cases, allow any instruction; // that does not write into memory, does not def or use the stack; // pointer, and does not def any register that was used by a preceding; // push.; // (Reading from memory is allowed, even if referenced through a; // frame index, since these will get adjusted properly in PEI); // The reason for the last condition is that the pushes can't replace; // the movs in place, because the order must be reversed.; // So if we have a MOV32mr that uses EDX, then an instruction that defs; // EDX, and then the call, after the transformation the push will use; // the modified version of EDX, and not the original one.; // Since we are still in SSA form at this point, we only need to; // make sure we don't clobber any *physical* registers that were; // used by an earlier mov that will become a push.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:112,Modifiability,Extend,Extend,112,"// Skip over DEBUG_VALUE.; // For globals in PIC mode, we can have some LEAs here. Skip them as well.; // TODO: Extend this to something that covers more cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:223,Safety,safe,safely,223,"// SelectionDAG (but not FastISel) inserts a copy of ESP into a virtual; // register. If it's there, use that virtual register as stack pointer; // instead. Also, we need to locate this instruction so that we can later; // safely ignore it while doing the conservative processing of the call chain.; // The COPY can be located anywhere between the call-frame setup; // instruction and its first use. We use the call instruction as a boundary; // because it is usually cheaper to check if an instruction is a call than; // checking if an instruction uses a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:88,Usability,simpl,simple,88,"// Scan the call setup sequence for the pattern we're looking for.; // We only handle a simple case - a sequence of store instructions that; // push a sequence of stack-slot-aligned values onto the stack, with; // no gaps between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:47,Modifiability,extend,extend,47,"// If storing a 32-bit vreg on 64-bit targets, extend to a 64-bit vreg; // in preparation for the PUSH64. The upper 32 bits can be undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:38,Performance,load,load,38,"// Do an extremely restricted form of load folding.; // ISel will often create patterns like:; // movl 4(%edi), %eax; // movl 8(%edi), %ecx; // movl 12(%edi), %edx; // movl %edx, 8(%esp); // movl %ecx, 4(%esp); // movl %eax, (%esp); // call; // Get rid of those with prejudice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:97,Performance,load,load,97,// Make sure we don't have any instructions between DefMI and the; // push that make folding the load illegal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:429,Integrability,rout,routines,429,"//=== X86CallingConv.cpp - X86 Custom Calling Convention Impl -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of custom routines for the X86; // Calling Convention that aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:107,Availability,mask,masks,107,"/// When regcall calling convention compiled to 32 bit arch, special treatment; /// is required for 64 bit masks.; /// The value should be assigned to two GPRs.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:197,Energy Efficiency,allocate,allocated,197,"/// When regcall calling convention compiled to 32 bit arch, special treatment; /// is required for 64 bit masks.; /// The value should be assigned to two GPRs.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:34,Availability,avail,available,34,// List of GPR registers that are available to store values in regcall; // calling convention.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:32,Availability,avail,available,32,// The vector will save all the available registers for allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:21,Availability,avail,available,21,// searching for the available registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:71,Availability,avail,available,71,// Not enough free registers - continue the search.; // Allocating the available registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:54,Availability,avail,available,54,// Since we previously made sure that 2 registers are available; // we expect that a real register number will be returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:27,Energy Efficiency,allocate,allocated,27,// Assign the value to the allocated register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:36,Energy Efficiency,allocate,allocated,36,// If the register is not marked as allocated - assign to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:39,Energy Efficiency,allocate,allocated,39,// If the register is marked as shadow allocated - assign to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:141,Energy Efficiency,allocate,allocated,141,"/// Vectorcall calling convention has special handling for vector types or; /// HVA for 64 bit arch.; /// For HVAs shadow registers might be allocated on the first pass; /// and actual XMM registers are allocated on the second pass.; /// For vector types, actual XMM registers are allocated on the first pass.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:203,Energy Efficiency,allocate,allocated,203,"/// Vectorcall calling convention has special handling for vector types or; /// HVA for 64 bit arch.; /// For HVAs shadow registers might be allocated on the first pass; /// and actual XMM registers are allocated on the second pass.; /// For vector types, actual XMM registers are allocated on the first pass.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:281,Energy Efficiency,allocate,allocated,281,"/// Vectorcall calling convention has special handling for vector types or; /// HVA for 64 bit arch.; /// For HVAs shadow registers might be allocated on the first pass; /// and actual XMM registers are allocated on the second pass.; /// For vector types, actual XMM registers are allocated on the first pass.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:346,Energy Efficiency,allocate,allocated,346,"/// Vectorcall calling convention has special handling for vector types or; /// HVA for 64 bit arch.; /// For HVAs shadow registers might be allocated on the first pass; /// and actual XMM registers are allocated on the second pass.; /// For vector types, actual XMM registers are allocated on the first pass.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:137,Energy Efficiency,allocate,allocate,137,"// If R9 was already assigned it means that we are after the fourth element; // and because this is not an HVA / Vector type, we need to allocate; // shadow XMM register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:255,Energy Efficiency,allocate,allocated,255,"// In Vectorcall Calling convention, additional shadow stack can be; // created on top of the basic 32 bytes of win64.; // It can happen if the fifth or sixth argument is vector type or HVA.; // At that case for each argument a shadow stack of 8 bytes is allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:3,Energy Efficiency,Allocate,Allocated,3,// Allocated a register - Stop the search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:140,Energy Efficiency,allocate,allocated,140,"/// Vectorcall calling convention has special handling for vector types or; /// HVA for 32 bit arch.; /// For HVAs actual XMM registers are allocated on the second pass.; /// For vector types, actual XMM registers are allocated on the first pass.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:218,Energy Efficiency,allocate,allocated,218,"/// Vectorcall calling convention has special handling for vector types or; /// HVA for 32 bit arch.; /// For HVAs actual XMM registers are allocated on the second pass.; /// For vector types, actual XMM registers are allocated on the first pass.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:283,Energy Efficiency,allocate,allocated,283,"/// Vectorcall calling convention has special handling for vector types or; /// HVA for 32 bit arch.; /// For HVAs actual XMM registers are allocated on the second pass.; /// For vector types, actual XMM registers are allocated on the first pass.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:30,Availability,avail,available,30,"// In case we did not find an available XMM register for a vector -; // pass it indirectly.; // It is similar to CCPassIndirect, with the addition of inreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:54,Deployability,Release,Release,54,// gracefully fallback to X86 C calling convention on Release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:59,Availability,error,error,59,"// If we have two arguments, the stack slot is *after* the error code; // argument. Pretend it doesn't consume stack space, and account for it when; // we assign the second argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:58,Availability,error,error,58,"// If this is the second of two arguments, it must be the error code. It; // appears first on the stack, and is then followed by the five slot; // interrupt struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.h:55,Integrability,Rout,Routines,55,"//=== X86CallingConv.h - X86 Custom Calling Convention Routines -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the X86 Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.h:413,Integrability,rout,routines,413,"//=== X86CallingConv.h - X86 Custom Calling Convention Routines -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the X86 Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:1419,Energy Efficiency,reduce,reduce,1419,"ect, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements a pass that converts X86 cmov instructions into; /// branches when profitable. This pass is conservative. It transforms if and; /// only if it can guarantee a gain with high confidence.; ///; /// Thus, the optimization applies under the following conditions:; /// 1. Consider as candidates only CMOVs in innermost loops (assume that; /// most hotspots are represented by these loops).; /// 2. Given a group of CMOV instructions that are using the same EFLAGS def; /// instruction:; /// a. Consider them as candidates only if all have the same code condition; /// or the opposite one to prevent generating more than one conditional; /// jump per EFLAGS def instruction.; /// b. Consider them as candidates only if all are profitable to be; /// converted (assume that one bad conversion may cause a degradation).; /// 3. Apply conversion only for loops that are found profitable and only for; /// CMOV candidates that were found profitable.; /// a. A loop is considered profitable only if conversion will reduce its; /// depth cost by some threshold.; /// b. CMOV is considered profitable if the cost of its condition is higher; /// than the average cost of its true-value and false-value by 25% of; /// branch-misprediction-penalty. This assures no degradation even with; /// 25% branch misprediction.; ///; /// Note: This pass is assumed to run on SSA machine code.; //; //===----------------------------------------------------------------------===//; //; // External interfaces:; // FunctionPass *llvm::createX86CmovConverterPass();; // bool X86CmovConverterPass::runOnMachineFunction(MachineFunction &MF);; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:1885,Integrability,interface,interfaces,1885,"ect, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements a pass that converts X86 cmov instructions into; /// branches when profitable. This pass is conservative. It transforms if and; /// only if it can guarantee a gain with high confidence.; ///; /// Thus, the optimization applies under the following conditions:; /// 1. Consider as candidates only CMOVs in innermost loops (assume that; /// most hotspots are represented by these loops).; /// 2. Given a group of CMOV instructions that are using the same EFLAGS def; /// instruction:; /// a. Consider them as candidates only if all have the same code condition; /// or the opposite one to prevent generating more than one conditional; /// jump per EFLAGS def instruction.; /// b. Consider them as candidates only if all are profitable to be; /// converted (assume that one bad conversion may cause a degradation).; /// 3. Apply conversion only for loops that are found profitable and only for; /// CMOV candidates that were found profitable.; /// a. A loop is considered profitable only if conversion will reduce its; /// depth cost by some threshold.; /// b. CMOV is considered profitable if the cost of its condition is higher; /// than the average cost of its true-value and false-value by 25% of; /// branch-misprediction-penalty. This assures no degradation even with; /// 25% branch misprediction.; ///; /// Note: This pass is assumed to run on SSA machine code.; //; //===----------------------------------------------------------------------===//; //; // External interfaces:; // FunctionPass *llvm::createX86CmovConverterPass();; // bool X86CmovConverterPass::runOnMachineFunction(MachineFunction &MF);; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:622,Performance,optimiz,optimization,622,"//====- X86CmovConversion.cpp - Convert Cmov to Branch --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements a pass that converts X86 cmov instructions into; /// branches when profitable. This pass is conservative. It transforms if and; /// only if it can guarantee a gain with high confidence.; ///; /// Thus, the optimization applies under the following conditions:; /// 1. Consider as candidates only CMOVs in innermost loops (assume that; /// most hotspots are represented by these loops).; /// 2. Given a group of CMOV instructions that are using the same EFLAGS def; /// instruction:; /// a. Consider them as candidates only if all have the same code condition; /// or the opposite one to prevent generating more than one conditional; /// jump per EFLAGS def instruction.; /// b. Consider them as candidates only if all are profitable to be; /// converted (assume that one bad conversion may cause a degradation).; /// 3. Apply conversion only for loops that are found profitable and only for; /// CMOV candidates that were found profitable.; /// a. A loop is considered profitable only if conversion will reduce its; /// depth cost by some threshold.; /// b. CMOV is considered profitable if the cost of its condition is higher; /// than the average cost of its true-value and false-value by 25% of; /// branch-misprediction-penalty. This assures no degradation even with; /// 25% branch misprediction.; ///; /// Note: This pass is assumed to run on SSA machine code.; //; //===----------------------------------------------------------------------===//; //; // External interfaces:; // FunctionPass *llvm::createX86CmovConverterPass();; // bool X86CmovConverterPass::runOnMachineFunctio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:64,Performance,optimiz,optimization,64,// This internal switch can be used to turn off the cmov/branch optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:57,Deployability,update,update,57,/// Collect all CMOV-group-candidates in \p CurrLoop and update \p; /// CmovInstGroups accordingly.; ///; /// \param Blocks List of blocks to process.; /// \param CmovInstGroups List of consecutive CMOV instructions in CurrLoop.; /// \returns true iff it found any CMOV-group-candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:66,Performance,optimiz,optimized,66,"// If the SelectOptimize pass is enabled, cmovs have already been optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:271,Performance,load,load,271,"// Before we handle the more subtle cases of register-register CMOVs inside; // of potentially hot loops, we want to quickly remove all CMOVs (ForceAll) or; // the ones with a memory operand (ForceMemOperand option). The latter CMOV; // will risk a stall waiting for the load to complete that speculative; // execution behind a branch is better suited to handle on modern x86 chips.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:242,Safety,risk,risk,242,"// Before we handle the more subtle cases of register-register CMOVs inside; // of potentially hot loops, we want to quickly remove all CMOVs (ForceAll) or; // the ones with a memory operand (ForceMemOperand option). The latter CMOV; // will risk a stall waiting for the load to complete that speculative; // execution behind a branch is better suited to handle on modern x86 chips.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:32,Modifiability,rewrite,rewrite,32,"// For CMOV groups which we can rewrite and which contain a memory load,; // always rewrite them. On x86, a CMOV will dramatically amplify any; // memory latency by blocking speculative execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:84,Modifiability,rewrite,rewrite,84,"// For CMOV groups which we can rewrite and which contain a memory load,; // always rewrite them. On x86, a CMOV will dramatically amplify any; // memory latency by blocking speculative execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:67,Performance,load,load,67,"// For CMOV groups which we can rewrite and which contain a memory load,; // always rewrite them. On x86, a CMOV will dramatically amplify any; // memory latency by blocking speculative execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:154,Performance,latency,latency,154,"// For CMOV groups which we can rewrite and which contain a memory load,; // always rewrite them. On x86, a CMOV will dramatically amplify any; // memory latency by blocking speculative execution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:316,Performance,optimiz,optimized-loop-depth,316,"//===--------------------------------------------------------------------===//; // Register-operand Conversion Algorithm; // ---------; // For each innermost loop; // collectCmovCandidates() {; // Find all CMOV-group-candidates.; // }; //; // checkForProfitableCmovCandidates() {; // * Calculate both loop-depth and optimized-loop-depth.; // * Use these depth to check for loop transformation profitability.; // * Check for CMOV-group-candidate transformation profitability.; // }; //; // For each profitable CMOV-group-candidate; // convertCmovInstsToBranches() {; // * Create FalseBB, SinkBB, Conditional branch to SinkBB.; // * Replace each CMOV instruction with a PHI instruction in SinkBB.; // }; //; // Note: For more details, see each function description.; //===--------------------------------------------------------------------===//; // Build up the loops in pre-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:3,Performance,Optimiz,Optimize,3,// Optimize only innermost loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:3,Usability,Clear,Clear,3,// Clear out the prior group's memory operand CC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:36,Modifiability,extend,extending,36,// Check if we were relying on zero-extending behavior of the CMOV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:13,Performance,optimiz,optimized,13,/// Depth of optimized loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:139,Performance,Optimiz,Optimized-Loop,139,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:259,Performance,latency,latency,259,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:318,Performance,optimiz,optimized,318,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:370,Performance,latency,latency,370,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:473,Performance,latency,latency,473,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:538,Performance,latency,latency,538,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:925,Performance,optimiz,optimizing,925,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:3,Usability,Clear,Clear,3,// Clear physical registers Def map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:241,Integrability,depend,dependency,241,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:596,Integrability,depend,dependent,596,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:617,Integrability,depend,dependency,617,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:117,Performance,optimiz,optimized,117,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:138,Performance,Optimiz,Optimize-Loop,138,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:435,Performance,optimiz,optimized,435,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:1070,Performance,optimiz,optimize,1070,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:1288,Performance,optimiz,optimizing,1288,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:145,Performance,optimiz,optimized,145,"//===--------------------------------------------------------------------===//; // Step 3: Check for each CMOV-group-candidate if it worth to be optimized.; // Worth-Optimize-Group:; // Iff it is worth to optimize all CMOV instructions in the group.; //; // Worth-Optimize-CMOV:; // Predicted branch is faster than CMOV by the difference between depth of; // condition operand and depth of taken (predicted) value operand.; // To be conservative, the gain of such CMOV transformation should cover at; // at least 25% of branch-misprediction-penalty.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:166,Performance,Optimiz,Optimize-Group,166,"//===--------------------------------------------------------------------===//; // Step 3: Check for each CMOV-group-candidate if it worth to be optimized.; // Worth-Optimize-Group:; // Iff it is worth to optimize all CMOV instructions in the group.; //; // Worth-Optimize-CMOV:; // Predicted branch is faster than CMOV by the difference between depth of; // condition operand and depth of taken (predicted) value operand.; // To be conservative, the gain of such CMOV transformation should cover at; // at least 25% of branch-misprediction-penalty.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:205,Performance,optimiz,optimize,205,"//===--------------------------------------------------------------------===//; // Step 3: Check for each CMOV-group-candidate if it worth to be optimized.; // Worth-Optimize-Group:; // Iff it is worth to optimize all CMOV instructions in the group.; //; // Worth-Optimize-CMOV:; // Predicted branch is faster than CMOV by the difference between depth of; // condition operand and depth of taken (predicted) value operand.; // To be conservative, the gain of such CMOV transformation should cover at; // at least 25% of branch-misprediction-penalty.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:264,Performance,Optimiz,Optimize-CMOV,264,"//===--------------------------------------------------------------------===//; // Step 3: Check for each CMOV-group-candidate if it worth to be optimized.; // Worth-Optimize-Group:; // Iff it is worth to optimize all CMOV instructions in the group.; //; // Worth-Optimize-CMOV:; // Predicted branch is faster than CMOV by the difference between depth of; // condition operand and depth of taken (predicted) value operand.; // To be conservative, the gain of such CMOV transformation should cover at; // at least 25% of branch-misprediction-penalty.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:283,Safety,Predict,Predicted,283,"//===--------------------------------------------------------------------===//; // Step 3: Check for each CMOV-group-candidate if it worth to be optimized.; // Worth-Optimize-Group:; // Iff it is worth to optimize all CMOV instructions in the group.; //; // Worth-Optimize-CMOV:; // Predicted branch is faster than CMOV by the difference between depth of; // condition operand and depth of taken (predicted) value operand.; // To be conservative, the gain of such CMOV transformation should cover at; // at least 25% of branch-misprediction-penalty.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:397,Safety,predict,predicted,397,"//===--------------------------------------------------------------------===//; // Step 3: Check for each CMOV-group-candidate if it worth to be optimized.; // Worth-Optimize-Group:; // Iff it is worth to optimize all CMOV instructions in the group.; //; // Worth-Optimize-CMOV:; // Predicted branch is faster than CMOV by the difference between depth of; // condition operand and depth of taken (predicted) value operand.; // To be conservative, the gain of such CMOV transformation should cover at; // at least 25% of branch-misprediction-penalty.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:62,Performance,load,load,62,"// Avoid CMOV instruction which value is used as a pointer to load from.; // This is another conservative check to avoid converting CMOV instruction; // used with tree-search like algorithm, where the branch is unpredicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:3,Safety,Avoid,Avoid,3,"// Avoid CMOV instruction which value is used as a pointer to load from.; // This is another conservative check to avoid converting CMOV instruction; // used with tree-search like algorithm, where the branch is unpredicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:115,Safety,avoid,avoid,115,"// Avoid CMOV instruction which value is used as a pointer to load from.; // This is another conservative check to avoid converting CMOV instruction; // used with tree-search like algorithm, where the branch is unpredicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:39,Performance,load,load,39,"// First we need to insert an explicit load on the false path for any memory; // operand. We also need to potentially do register rewriting here, but it is; // simpler as the memory operands are always on the false path so we can; // simply take that input, whatever it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:160,Usability,simpl,simpler,160,"// First we need to insert an explicit load on the false path for any memory; // operand. We also need to potentially do register rewriting here, but it is; // simpler as the memory operands are always on the false path so we can; // simply take that input, whatever it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:234,Usability,simpl,simply,234,"// First we need to insert an explicit load on the false path for any memory; // operand. We also need to potentially do register rewriting here, but it is; // simpler as the memory operands are always on the false path so we can; // simply take that input, whatever it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:44,Performance,load,load,44,// Skip any CMOVs in this group which don't load from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:117,Performance,load,load,117,// The condition must be the *opposite* of the one we've decided to branch; // on as the branch will go *around* the load and the load should happen; // when the CMOV condition is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:130,Performance,load,load,130,// The condition must be the *opposite* of the one we've decided to branch; // on as the branch will go *around* the load and the load should happen; // when the CMOV condition is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:18,Modifiability,rewrite,rewrite,18,"// The goal is to rewrite the cmov from:; //; // MBB:; // %A = CMOVcc %B (tied), (mem); //; // to; //; // MBB:; // %A = CMOVcc %B (tied), %C; // FalseMBB:; // %C = MOV (mem); //; // Which will allow the next loop to rewrite the CMOV in terms of a PHI:; //; // MBB:; // JMP!cc SinkMBB; // FalseMBB:; // %C = MOV (mem); // SinkMBB:; // %A = PHI [ %C, FalseMBB ], [ %B, MBB]; // Get a fresh register to use as the destination of the MOV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:216,Modifiability,rewrite,rewrite,216,"// The goal is to rewrite the cmov from:; //; // MBB:; // %A = CMOVcc %B (tied), (mem); //; // to; //; // MBB:; // %A = CMOVcc %B (tied), %C; // FalseMBB:; // %C = MOV (mem); //; // Which will allow the next loop to rewrite the CMOV in terms of a PHI:; //; // MBB:; // JMP!cc SinkMBB; // FalseMBB:; // %C = MOV (mem); // SinkMBB:; // %A = PHI [ %C, FalseMBB ], [ %B, MBB]; // Get a fresh register to use as the destination of the MOV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:23,Modifiability,rewrite,rewrite,23,// Add this PHI to the rewrite table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:23,Modifiability,rewrite,rewrite,23,// Add this PHI to the rewrite table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:109,Testability,test,testing,109,// Reset the NoPHIs property if a PHI was inserted to prevent a conflict with; // the MachineVerifier during testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CodeGenPassBuilder.cpp:422,Deployability,pipeline,pipeline,422,"//===-- X86CodeGenPassBuilder.cpp ---------------------------------*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file contains X86 CodeGen pipeline builder.; /// TODO: Port CodeGen passes to new pass manager.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CodeGenPassBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CodeGenPassBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp:1292,Deployability,install,install,1292,"//===- X86CompressEVEX.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass compresses instructions from EVEX space to legacy/VEX/EVEX space; // when possible in order to reduce code size or facilitate HW decoding.; //; // Possible compression:; // a. AVX512 instruction (EVEX) -> AVX instruction (VEX); // b. Promoted instruction (EVEX) -> pre-promotion instruction (legacy/VEX); // c. NDD (EVEX) -> non-NDD (legacy); // d. NF_ND (EVEX) -> NF (EVEX); //; // Compression a, b and c can always reduce code size, with some exceptions; // such as promoted 16-bit CRC32 which is as long as the legacy version.; //; // legacy:; // crc32w %si, %eax ## encoding: [0x66,0xf2,0x0f,0x38,0xf1,0xc6]; // promoted:; // crc32w %si, %eax ## encoding: [0x62,0xf4,0x7d,0x08,0xf1,0xc6]; //; // From performance perspective, these should be same (same uops and same EXE; // ports). From a FMV perspective, an older legacy encoding is preferred b/c it; // can execute in more places (broader HW install base). So we will still do; // the compression.; //; // Compression d can help hardware decode (HW may skip reading the NDD; // register) although the instruction length remains unchanged.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp:488,Energy Efficiency,reduce,reduce,488,"//===- X86CompressEVEX.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass compresses instructions from EVEX space to legacy/VEX/EVEX space; // when possible in order to reduce code size or facilitate HW decoding.; //; // Possible compression:; // a. AVX512 instruction (EVEX) -> AVX instruction (VEX); // b. Promoted instruction (EVEX) -> pre-promotion instruction (legacy/VEX); // c. NDD (EVEX) -> non-NDD (legacy); // d. NF_ND (EVEX) -> NF (EVEX); //; // Compression a, b and c can always reduce code size, with some exceptions; // such as promoted 16-bit CRC32 which is as long as the legacy version.; //; // legacy:; // crc32w %si, %eax ## encoding: [0x66,0xf2,0x0f,0x38,0xf1,0xc6]; // promoted:; // crc32w %si, %eax ## encoding: [0x62,0xf4,0x7d,0x08,0xf1,0xc6]; //; // From performance perspective, these should be same (same uops and same EXE; // ports). From a FMV perspective, an older legacy encoding is preferred b/c it; // can execute in more places (broader HW install base). So we will still do; // the compression.; //; // Compression d can help hardware decode (HW may skip reading the NDD; // register) although the instruction length remains unchanged.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp:810,Energy Efficiency,reduce,reduce,810,"//===- X86CompressEVEX.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass compresses instructions from EVEX space to legacy/VEX/EVEX space; // when possible in order to reduce code size or facilitate HW decoding.; //; // Possible compression:; // a. AVX512 instruction (EVEX) -> AVX instruction (VEX); // b. Promoted instruction (EVEX) -> pre-promotion instruction (legacy/VEX); // c. NDD (EVEX) -> non-NDD (legacy); // d. NF_ND (EVEX) -> NF (EVEX); //; // Compression a, b and c can always reduce code size, with some exceptions; // such as promoted 16-bit CRC32 which is as long as the legacy version.; //; // legacy:; // crc32w %si, %eax ## encoding: [0x66,0xf2,0x0f,0x38,0xf1,0xc6]; // promoted:; // crc32w %si, %eax ## encoding: [0x62,0xf4,0x7d,0x08,0xf1,0xc6]; //; // From performance perspective, these should be same (same uops and same EXE; // ports). From a FMV perspective, an older legacy encoding is preferred b/c it; // can execute in more places (broader HW install base). So we will still do; // the compression.; //; // Compression d can help hardware decode (HW may skip reading the NDD; // register) although the instruction length remains unchanged.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp:1098,Performance,perform,performance,1098,"//===- X86CompressEVEX.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass compresses instructions from EVEX space to legacy/VEX/EVEX space; // when possible in order to reduce code size or facilitate HW decoding.; //; // Possible compression:; // a. AVX512 instruction (EVEX) -> AVX instruction (VEX); // b. Promoted instruction (EVEX) -> pre-promotion instruction (legacy/VEX); // c. NDD (EVEX) -> non-NDD (legacy); // d. NF_ND (EVEX) -> NF (EVEX); //; // Compression a, b and c can always reduce code size, with some exceptions; // such as promoted 16-bit CRC32 which is as long as the legacy version.; //; // legacy:; // crc32w %si, %eax ## encoding: [0x66,0xf2,0x0f,0x38,0xf1,0xc6]; // promoted:; // crc32w %si, %eax ## encoding: [0x62,0xf4,0x7d,0x08,0xf1,0xc6]; //; // From performance perspective, these should be same (same uops and same EXE; // ports). From a FMV perspective, an older legacy encoding is preferred b/c it; // can execute in more places (broader HW install base). So we will still do; // the compression.; //; // Compression d can help hardware decode (HW may skip reading the NDD; // register) although the instruction length remains unchanged.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp:21,Availability,mask,mask,21,// Instructions with mask or 512-bit vector can't be converted to VEX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:415,Performance,cache,cache,415,"//===- X86DiscriminateMemOps.cpp - Unique IDs for Mem Ops -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass aids profile-driven cache prefetch insertion by ensuring all; /// instructions that have a memory operand are distinguishible from each other.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:116,Safety,avoid,avoid,116,"// Figure out the largest discriminator issued for each Location. When we; // issue new discriminators, we can thus avoid issuing discriminators; // belonging to instructions that don't have memops. This isn't a requirement; // for the goals of this pass, however, it avoids unnecessary ambiguity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:268,Safety,avoid,avoids,268,"// Figure out the largest discriminator issued for each Location. When we; // issue new discriminators, we can thus avoid issuing discriminators; // belonging to instructions that don't have memops. This isn't a requirement; // for the goals of this pass, however, it avoids unnecessary ambiguity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:22,Deployability,release,release,22,// Silence warning in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:28,Safety,avoid,avoid,28,// Bump the reference DI to avoid cramming discriminators on line 0.; // FIXME(mtrofin): pin ReferenceDI on blocks or first instruction with DI; // in a block. It's more consistent than just relying on the last memop; // instruction we happened to see.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:108,Safety,safe,safely,108,"/// An Instruction Converter which ignores the given instruction.; /// For example, PHI instructions can be safely ignored since only the registers; /// need to change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:617,Performance,load,loaded,617,"/// A closure is a set of virtual register representing all of the edges in; /// the closure, as well as all of the instructions connected by those edges.; ///; /// A closure may encompass virtual registers in the same register bank that; /// have different widths. For example, it may contain 32-bit GPRs as well as; /// 64-bit GPRs.; ///; /// A closure that computes an address (i.e. defines a virtual register that is; /// used in a memory operand) excludes the instructions that contain memory; /// operands using the address. Such an instruction will be included in a; /// different closure that manipulates the loaded or stored value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:13,Availability,avail,available,13,/// A map of available Instruction Converters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:51,Safety,avoid,avoid,51,"// Instruction already belongs to another closure, avoid conflicts between; // closure and mark this closure as illegal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:20,Safety,avoid,avoid,20,"// We would like to avoid converting closures which calculare addresses,; // as this should remain in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:40,Testability,TEST,TEST,40,"// TODO: KTEST is not a replacement for TEST due to flag differences. Need; // to prove only Z flag is used.; // createReplacer(X86::TEST32rr, X86::KTESTDrr);; // createReplacer(X86::TEST64rr, X86::KTESTQrr);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:40,Testability,TEST,TEST,40,"// TODO: KTEST is not a replacement for TEST due to flag differences. Need; // to prove only Z flag is used.; // createReplacer(X86::TEST8rr, X86::KTESTBrr);; // createReplacer(X86::TEST16rr, X86::KTESTWrr);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:463,Performance,perform,performs,463,"//===----- X86DynAllocaExpander.cpp - Expand DynAlloca pseudo instruction -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that expands DynAlloca pseudo-instructions.; //; // It performs a conservative analysis to determine whether each allocation; // falls within a region of the stack that is safe to use, or whether stack; // probes must be emitted.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:580,Safety,safe,safe,580,"//===----- X86DynAllocaExpander.cpp - Expand DynAlloca pseudo instruction -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that expands DynAlloca pseudo-instructions.; //; // It performs a conservative analysis to determine whether each allocation; // falls within a region of the stack that is safe to use, or whether stack; // probes must be emitted.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:25,Safety,safe,safe,25,"// If it fits within the safe region of the stack, just subtract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:167,Integrability,depend,depends,167,"// Note: we don't know the offset at the start of the entry block since the; // prologue hasn't been inserted yet, and how much that will adjust the stack; // pointer depends on register spills, which have not been computed yet.; // Compute the reverse post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:13,Modifiability,variab,variables,13,"// These two variables differ on x32, which is a 64-bit target with a; // 32-bit alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:487,Energy Efficiency,schedul,scheduling,487,"//===------- X86ExpandPseudo.cpp - Expand pseudo instructions -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, other late; // optimizations, or simply the encoding of the instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:529,Performance,optimiz,optimizations,529,"//===------- X86ExpandPseudo.cpp - Expand pseudo instructions -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, other late; // optimizations, or simply the encoding of the instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:547,Usability,simpl,simply,547,"//===------- X86ExpandPseudo.cpp - Expand pseudo instructions -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, other late; // optimizations, or simply the encoding of the instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:98,Usability,simpl,simplify,98,/// This function expands pseudos which affects control flow.; /// It is done in separate pass to simplify blocks navigation in main; /// pass(calling ExpandMBB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:24,Integrability,wrap,wrap,24,"// On Darwin platforms, wrap the expanded sequence in a bundle to prevent; // later optimizations from breaking up the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:84,Performance,optimiz,optimizations,84,"// On Darwin platforms, wrap the expanded sequence in a bundle to prevent; // later optimizations from breaking up the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:25,Availability,error,error,25,// Adjust stack to erase error code,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:25,Availability,error,error,25,// Adjust stack to erase error code,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:3,Performance,Perform,Perform,3,"// Perform the following transformation.; // SaveRbx = pseudocmpxchg Addr, <4 opds for the address>, InArg, SaveRbx; // =>; // RBX = InArg; // actualcmpxchg Addr; // RBX = SaveRbx",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:19,Availability,mask,mask,19,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:198,Availability,mask,masks,198,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:217,Availability,mask,masks,217,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:369,Integrability,wrap,wrap,369,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:3,Performance,Load,Loading,3,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:299,Performance,load,loaded,299,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:401,Testability,assert,asserts,401,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:3,Performance,Perform,Perform,3,"// Perform the following transformation.; // SaveRbx = pseudomwaitx InArg, SaveRbx; // =>; // [E|R]BX = InArg; // actualmwaitx; // [E|R]BX = SaveRbx",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:160,Performance,perform,performed,160,"// Create the new basic blocks. One block contains all the XMM stores,; // and another block is the final destination regardless of whether any; // stores were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:105,Performance,load,load,105,"/// The specified machine instr operand is a vreg, and that; /// vreg is being provided by the specified load instruction. If possible,; /// try to fold the load as an operand to the instruction, returning true if; /// possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:157,Performance,load,load,157,"/// The specified machine instr operand is a vreg, and that; /// vreg is being provided by the specified load instruction. If possible,; /// try to fold the load as an operand to the instruction, returning true if; /// possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:273,Deployability,update,updated,273,"/// Adds a complex addressing mode to the given machine instr builder.; /// Note, this will constrain the index register. If its not possible to; /// constrain the given index register, then a new one will be created. The; /// IndexReg field of the addressing mode will be updated to match in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:126,Deployability,update,updated,126,/// Check if it is possible to fold the condition from the XALU intrinsic; /// into the user. The condition code will only be updated on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:33,Performance,perform,performing,33,"// For now, require SSE/SSE2 for performing floating-point operations,; // since x87 requires additional work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:52,Performance,load,load,52,"/// X86FastEmitLoad - Emit a machine instruction to load a value of type VT.; /// The address is either pre-computed, i.e. Ptr, or a GlobalAddress, i.e. GV.; /// Return true and the result register by reference if it is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:40,Availability,Mask,Masking,40,// Treat i1 loads the same as i8 loads. Masking will be done when storing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:12,Performance,load,loads,12,// Treat i1 loads the same as i8 loads. Masking will be done when storing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:33,Performance,load,loads,33,// Treat i1 loads the same as i8 loads. Masking will be done when storing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:55,Performance,load,load,55,// Get opcode and regclass of the output for the given load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:122,Availability,mask,masked,122,"// Note: There are a lot more choices based on type with AVX-512, but; // there's really no advantage when the load isn't masked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:111,Performance,load,load,111,"// Note: There are a lot more choices based on type with AVX-512, but; // there's really no advantage when the load isn't masked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Availability,Mask,Mask,3,// Mask out all but lowest bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:123,Availability,mask,masked,123,"// Note: There are a lot more choices based on type with AVX-512, but; // there's really no advantage when the store isn't masked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:27,Usability,simpl,simple,27,"// If this is a store of a simple constant, fold the constant into the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:25,Modifiability,extend,extended,25,// Must be a 32-bit sign extended value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:54,Modifiability,extend,extend,54,/// X86FastEmitExtend - Emit a machine instruction to extend a value Src of; /// type SrcVT to type DstVT using the specified extension opcode Opc (e.g.; /// ISD::SIGN_EXTEND).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:36,Performance,load,load,36,"// Unless the ABI requires an extra load, return a direct reference to; // the global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:23,Performance,load,load,23,"// Ok, we need to do a load from a stub. If we've already loaded from; // this stub, reuse the loaded pointer, otherwise emit the load now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:58,Performance,load,loaded,58,"// Ok, we need to do a load from a stub. If we've already loaded from; // this stub, reuse the loaded pointer, otherwise emit the load now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:95,Performance,load,loaded,95,"// Ok, we need to do a load from a stub. If we've already loaded from; // this stub, reuse the loaded pointer, otherwise emit the load now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:130,Performance,load,load,130,"// Ok, we need to do a load from a stub. If we've already loaded from; // this stub, reuse the loaded pointer, otherwise emit the load now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:35,Testability,stub,stub,35,"// Ok, we need to do a load from a stub. If we've already loaded from; // this stub, reuse the loaded pointer, otherwise emit the load now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:79,Testability,stub,stub,79,"// Ok, we need to do a load from a stub. If we've already loaded from; // this stub, reuse the loaded pointer, otherwise emit the load now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:9,Performance,load,load,9,// Issue load from stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:19,Testability,stub,stub,19,// Issue load from stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:11,Performance,load,loading,11,// Prevent loading GV stub multiple times in same MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:22,Testability,stub,stub,22,// Prevent loading GV stub multiple times in same MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:17,Usability,simpl,simple,17,// Pattern-match simple GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:11,Modifiability,variab,variable,11,// A array/variable index is always of the form i*S where S is the; // constant scale size. See if we can push the scale into immediates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:88,Deployability,Update,Update,88,"// Ok, the GEP indices were covered by constant-offset and scaled-index; // addressing. Update the address state and move on to examining the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:499,Availability,alive,alive,499,"// Record if the value is defined in the same basic block.; //; // This information is crucial to know whether or not folding an; // operand is valid.; // Indeed, FastISel generates or reuses a virtual register for all; // operands of all instructions it selects. Obviously, the definition and; // its uses must use the same virtual register otherwise the produced; // code is incorrect.; // Before instruction selection, FunctionLoweringInfo::set sets the virtual; // registers for values that are alive across basic blocks. This ensures; // that the values are consistently set between across basic block, even; // if different instruction selection mechanisms are used (e.g., a mix of; // SDISel and FastISel).; // For values local to a basic block, the instruction selection process; // generates these virtual registers with whatever method is appropriate; // for its needs. In particular, FastISel and SDISel do not share the way; // local virtual registers are set.; // Therefore, this is impossible (or at least unsafe) to share values; // between basic blocks unless they use the same instruction selection; // method, which is not guarantee for X86.; // Moreover, things like hasOneUse could not be used accurately, if we; // allow to reference values across basic blocks whereas they are not; // alive across basic blocks initially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:1307,Availability,alive,alive,1307,"// Record if the value is defined in the same basic block.; //; // This information is crucial to know whether or not folding an; // operand is valid.; // Indeed, FastISel generates or reuses a virtual register for all; // operands of all instructions it selects. Obviously, the definition and; // its uses must use the same virtual register otherwise the produced; // code is incorrect.; // Before instruction selection, FunctionLoweringInfo::set sets the virtual; // registers for values that are alive across basic blocks. This ensures; // that the values are consistently set between across basic block, even; // if different instruction selection mechanisms are used (e.g., a mix of; // SDISel and FastISel).; // For values local to a basic block, the instruction selection process; // generates these virtual registers with whatever method is appropriate; // for its needs. In particular, FastISel and SDISel do not share the way; // local virtual registers are set.; // Therefore, this is impossible (or at least unsafe) to share values; // between basic blocks unless they use the same instruction selection; // method, which is not guarantee for X86.; // Moreover, things like hasOneUse could not be used accurately, if we; // allow to reference values across basic blocks whereas they are not; // alive across basic blocks initially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:1020,Safety,unsafe,unsafe,1020,"// Record if the value is defined in the same basic block.; //; // This information is crucial to know whether or not folding an; // operand is valid.; // Indeed, FastISel generates or reuses a virtual register for all; // operands of all instructions it selects. Obviously, the definition and; // its uses must use the same virtual register otherwise the produced; // code is incorrect.; // Before instruction selection, FunctionLoweringInfo::set sets the virtual; // registers for values that are alive across basic blocks. This ensures; // that the values are consistently set between across basic block, even; // if different instruction selection mechanisms are used (e.g., a mix of; // SDISel and FastISel).; // For values local to a basic block, the instruction selection process; // generates these virtual registers with whatever method is appropriate; // for its needs. In particular, FastISel and SDISel do not share the way; // local virtual registers are set.; // Therefore, this is impossible (or at least unsafe) to share values; // between basic blocks unless they use the same instruction selection; // method, which is not guarantee for X86.; // Moreover, things like hasOneUse could not be used accurately, if we; // allow to reference values across basic blocks whereas they are not; // alive across basic blocks initially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:100,Performance,load,loads,100,"// Return a direct reference to the global. Fastisel can handle calls to; // functions that require loads, such as dllimport and nonlazybind; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:78,Performance,optimiz,optimization,78,// fastcc with -tailcallopt is intended to provide a guaranteed; // tail call optimization. Fastisel doesn't know how to do that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:24,Modifiability,extend,extended,24,// Special handling for extended integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Safety,Avoid,Avoid,3,// Avoid a cross-class copy. This is very unlikely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:253,Integrability,depend,depending,253,"// Swift calling convention does not require we copy the sret argument; // into %rax/%eax for the return, and SRetReturnReg is not set for Swift.; // All x86 ABIs require that for returning structs by value we copy; // the sret argument into %rax/%eax (depending on ABI) for the return.; // We saved the argument into a virtual register in the entry block,; // so now we copy the value out and into %rax/%eax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:54,Performance,load,load,54,/// X86SelectLoad - Select and emit code to implement load instructions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:10,Performance,load,loads,10,// Atomic loads need special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:10,Performance,optimiz,optimize,10,// Try to optimize or fold the cmp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:7,Performance,optimiz,optimizer,7,"// The optimizer might have replaced fcmp oeq %x, %x with fcmp ord %x, 0.0.; // We don't have to materialize a zero constant for this case and can just use; // %x again on the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:110,Availability,down,down,110,// i8->i16 doesn't exist in the autogenerated isel table. Need to zero; // extend to 32-bits and then extract down to 16-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:75,Modifiability,extend,extend,75,// i8->i16 doesn't exist in the autogenerated isel table. Need to zero; // extend to 32-bits and then extract down to 16-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:43,Modifiability,extend,extended,43,// Negate the result to make an 8-bit sign extended value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:110,Availability,down,down,110,// i8->i16 doesn't exist in the autogenerated isel table. Need to sign; // extend to 32-bits and then extract down to 16-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:75,Modifiability,extend,extend,75,// i8->i16 doesn't exist in the autogenerated isel table. Need to sign; // extend to 32-bits and then extract down to 16-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:10,Performance,optimiz,optimize,10,// Try to optimize or fold the cmp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:7,Performance,optimiz,optimizer,7,"// The optimizer might have replaced fcmp oeq %x, %x with fcmp ord %x,; // 0.0.; // We don't have to materialize a zero constant for this case and can just; // use %x again on the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:79,Performance,optimiz,optimized,79,"// Fake request the condition, otherwise the intrinsic might be completely; // optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:38,Testability,test,test,38,"// Otherwise do a clumsy setcc and re-test it.; // Note that i1 essentially gets ANY_EXTEND'ed to i8 where it isn't used; // in an explicit cast, so make sure to handle that correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:310,Modifiability,extend,extended,310,"// For the X86 DIV/IDIV instruction, in most cases the dividend; // (numerator) must be in a specific register pair highreg:lowreg,; // producing the quotient in lowreg and the remainder in highreg.; // For most data types, to set up the instruction, the dividend is; // copied into lowreg, and lowreg is sign-extended or zero-extended; // into highreg. The exception is i8, where the dividend is defined; // as a single register rather than a register pair, and we; // therefore directly sign-extend or zero-extend the dividend into; // lowreg, instead of copying, and ignore the highreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:327,Modifiability,extend,extended,327,"// For the X86 DIV/IDIV instruction, in most cases the dividend; // (numerator) must be in a specific register pair highreg:lowreg,; // producing the quotient in lowreg and the remainder in highreg.; // For most data types, to set up the instruction, the dividend is; // copied into lowreg, and lowreg is sign-extended or zero-extended; // into highreg. The exception is i8, where the dividend is defined; // as a single register rather than a register pair, and we; // therefore directly sign-extend or zero-extend the dividend into; // lowreg, instead of copying, and ignore the highreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:494,Modifiability,extend,extend,494,"// For the X86 DIV/IDIV instruction, in most cases the dividend; // (numerator) must be in a specific register pair highreg:lowreg,; // producing the quotient in lowreg and the remainder in highreg.; // For most data types, to set up the instruction, the dividend is; // copied into lowreg, and lowreg is sign-extended or zero-extended; // into highreg. The exception is i8, where the dividend is defined; // as a single register rather than a register pair, and we; // therefore directly sign-extend or zero-extend the dividend into; // lowreg, instead of copying, and ignore the highreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:509,Modifiability,extend,extend,509,"// For the X86 DIV/IDIV instruction, in most cases the dividend; // (numerator) must be in a specific register pair highreg:lowreg,; // producing the quotient in lowreg and the remainder in highreg.; // For most data types, to set up the instruction, the dividend is; // copied into lowreg, and lowreg is sign-extended or zero-extended; // into highreg. The exception is i8, where the dividend is defined; // as a single register rather than a register pair, and we; // therefore directly sign-extend or zero-extend the dividend into; // lowreg, instead of copying, and ignore the highreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:25,Integrability,depend,depends,25,// The following portion depends only on the data type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:60,Integrability,depend,depends,60,// high part of the register pair; // The following portion depends on both the data type and the operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:19,Modifiability,extend,extending,19,"// Opcode for sign-extending lowreg into; // highreg, or copying a zero into highreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:61,Modifiability,extend,extending,61,"// Opcode for copying dividend into lowreg, or; // zero/sign-extending into lowreg for i8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:8,Modifiability,extend,extend,8,// Zero-extend or sign-extend into high-order input register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:23,Modifiability,extend,extend,23,// Zero-extend or sign-extend into high-order input register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:391,Availability,robust,robust,391,"// For i8 remainder, we can't reference ah directly, as we'll end; // up with bogus copies like %r9b = COPY %ah. Reference ax; // instead to prevent ah references in a rex instruction.; //; // The current assumption of the fast register allocator is that isel; // won't generate explicit references to the GR8_NOREX registers. If; // the allocator and/or the backend get enhanced to be more robust in; // that regard, this can be, and should be, removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:371,Modifiability,enhance,enhanced,371,"// For i8 remainder, we can't reference ah directly, as we'll end; // up with bogus copies like %r9b = COPY %ah. Reference ax; // instead to prevent ah references in a rex instruction.; //; // The current assumption of the fast register allocator is that isel; // won't generate explicit references to the GR8_NOREX registers. If; // the allocator and/or the backend get enhanced to be more robust in; // that regard, this can be, and should be, removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Performance,Optimiz,Optimize,3,// Optimize conditions coming from a compare if both instructions are in the; // same basic block (values defined in other basic blocks may not have; // initialized registers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:79,Performance,optimiz,optimized,79,"// Fake request the condition, otherwise the intrinsic might be completely; // optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:324,Performance,perform,performing,324,"// Selects operate on i1, however, CondReg is 8 bits width and may contain; // garbage. Indeed, only the less significant bit is supposed to be; // accurate. If we read more than the lsb, we may see non-zero values; // whereas lsb is zero. Therefore, we have to truncate Op0Reg to i1 for; // the select. This is achieved by performing TEST against 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:335,Testability,TEST,TEST,335,"// Selects operate on i1, however, CondReg is 8 bits width and may contain; // garbage. Indeed, only the less significant bit is supposed to be; // accurate. If we read more than the lsb, we may see non-zero values; // whereas lsb is zero. Therefore, we have to truncate Op0Reg to i1 for; // the select. This is achieved by performing TEST against 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:242,Availability,avail,available,242,"/// Emit SSE or AVX instructions to lower the select.; ///; /// Try to use SSE1/SSE2 instructions to simulate a select without branches.; /// This lowers fp selects into a CMP/AND/ANDN/OR sequence when the necessary; /// SSE instructions are available. If AVX is available, try to use a VBLENDV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:263,Availability,avail,available,263,"/// Emit SSE or AVX instructions to lower the select.; ///; /// Try to use SSE1/SSE2 instructions to simulate a select without branches.; /// This lowers fp selects into a CMP/AND/ANDN/OR sequence when the necessary; /// SSE instructions are available. If AVX is available, try to use a VBLENDV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Performance,Optimiz,Optimize,3,// Optimize conditions coming from a compare if both instructions are in the; // same basic block (values defined in other basic blocks may not have; // initialized registers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:7,Performance,optimiz,optimizer,7,"// The optimizer might have replaced fcmp oeq %x, %x with fcmp ord %x, 0.0.; // We don't have to materialize a zero constant for this case and can just use; // %x again on the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:34,Availability,mask,mask,34,// If we have AVX512 we can use a mask compare and masked movss/sd.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:51,Availability,mask,masked,51,// If we have AVX512 we can use a mask compare and masked movss/sd.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:39,Availability,mask,masked,39,// Place RHSReg is the passthru of the masked movss/sd operation and put; // LHS in the input. The mask input comes from the compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:99,Availability,mask,mask,99,// Place RHSReg is the passthru of the masked movss/sd operation and put; // LHS in the input. The mask input comes from the compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:48,Testability,log,logic,48,"// If we have AVX, create 1 blendv instead of 3 logic instructions.; // Blendv was introduced with SSE 4.1, but the 2 register form implicitly; // uses XMM0 as the selection register. That may need just as many; // instructions as the AND/ANDN/OR sequence due to register moves, so; // don't bother.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Performance,Optimiz,Optimize,3,// Optimize conditions coming from a compare if both instructions are in the; // same basic block (values defined in other basic blocks may not have; // initialized registers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:23,Modifiability,extend,extend,23,// TODO: We could sign extend narrower types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:65,Security,access,accesses,65,// We don't care about alignment here since we just emit integer accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:19,Modifiability,extend,extend,19,// Explicitly zero-extend the input to 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:19,Performance,load,load,19,"// Now recursively load from the frame address.; // movq (%rbp), %rax; // movq (%rax), %rax; // movq (%rax), %rax; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:28,Modifiability,variab,variable,28,// Don't handle volatile or variable length memcpys.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:124,Deployability,Update,Update,124,"// Unfortunately we can't use fastEmit_r, because the AVX version of FSQRT; // is not generated by FastISel yet.; // FIXME: Update this code once tablegen can handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple cases. i.e. Up to 6 i32/i64 scalar arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:78,Performance,optimiz,optimization,78,// fastcc with -tailcallopt is intended to provide a guaranteed; // tail call optimization. Fastisel doesn't know how to do that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:63,Safety,avoid,avoid,63,"// If this is a constant i1/i8/i16 argument, promote to i32 to avoid an extra; // instruction. This is safe because it is common to all FastISel supported; // calling conventions on x86.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:103,Safety,safe,safe,103,"// If this is a constant i1/i8/i16 argument, promote to i32 to avoid an extra; // instruction. This is safe because it is common to all FastISel supported; // calling conventions on x86.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate shadow area for Win64,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:32,Modifiability,extend,extending,32,"// FIXME: Indirect doesn't need extending, but fast-isel doesn't fully; // support this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:23,Usability,simpl,simple,23,"// If this is a really simple value, emit this with the Value* version; // of X86FastEmitStore. If it isn't simple, we don't want to do this,; // as it can cause us to reevaluate the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:108,Usability,simpl,simple,108,"// If this is a really simple value, emit this with the Value* version; // of X86FastEmitStore. If it isn't simple, we don't want to do this,; // as it can cause us to reevaluate the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:487,Energy Efficiency,allocate,allocated,487,"// From AMD64 ABI document:; // For calls that may call functions that use varargs or stdargs; // (prototype-less calls or calls to functions containing ellipsis (...) in; // the declaration) %al is used as hidden argument to specify the number; // of SSE registers used. The contents of %al do not need to match exactly; // the number of registers, but must be an ubound on the number of SSE; // registers used and is in the range 0 - 8 inclusive.; // Count the number of XMM registers allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.; // Proper defs for return values will be added by setPhysRegsDeadExcept().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:162,Performance,load,loading,162,"// Round the f80 to the right size, which also moves it to the appropriate; // xmm register. This is accomplished by storing the f80 value in memory; // and then loading it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:45,Performance,cache,cached,45,// Emit a reg-reg copy so we don't propagate cached known bits information; // with the wrong VT if we fall out of fast isel after selecting this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:55,Performance,load,load,55,// Get opcode and regclass of the output for the given load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:14,Performance,load,load,14,// Create the load from the constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:351,Safety,avoid,avoid,351,"// Fail on dynamic allocas. At this point, getRegForValue has already; // checked its CSE maps, so if we're here trying to handle a dynamic; // alloca, we're not going to succeed. X86SelectAddress has a; // check for dynamic allocas, because it's called directly from; // various places, but targetMaterializeAlloca also needs a check; // in order to avoid recursion between getRegForValue,; // X86SelectAddrss, and targetMaterializeAlloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:35,Modifiability,rewrite,rewrite,35,"// Found the index reg, now try to rewrite it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:54,Modifiability,Config,Configure,54,"//===-- X86FastPreTileConfig.cpp - Fast Tile Register Configure------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to preconfig the shape of physical tile registers; /// It inserts ldtilecfg ahead of each group of tile registers. The algorithm; /// walk each instruction of basic block in reverse order. All the tile; /// registers that live out the basic block would be spilled and reloaded; /// before its user. It also check the depenedency of the shape to ensure; /// the shape is defined before ldtilecfg.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:88,Availability,alive,alive,88,/// Has a bit set for tile virtual register for which it was determined; /// that it is alive across blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:26,Modifiability,config,configure,26,/// Perform tile register configure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:4,Performance,Perform,Perform,4,/// Perform tile register configure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:9,Energy Efficiency,allocate,allocates,9,/// This allocates space for the specified virtual register to be held on the; /// stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:21,Energy Efficiency,allocate,allocated,21,// Already has space allocated?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new stack object for this spill location...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:72,Modifiability,config,config,72,"/// Returns false if \p VirtReg is known to not live out of the current config.; /// If \p VirtReg live out of the current MBB, it must live out of the current; /// config",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:165,Modifiability,config,config,165,"/// Returns false if \p VirtReg is known to not live out of the current config.; /// If \p VirtReg live out of the current MBB, it must live out of the current; /// config",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:77,Deployability,Update,Update,77,/// Insert spill instruction for \p AssignedReg before \p Before.; /// TODO: Update DBG_VALUEs with \p VirtReg operands with the stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:9,Deployability,update,update,9,// TODO: update DBG_VALUEs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:18,Performance,load,loadRegFromStackSlot,18,"// Can't use TII->loadRegFromStackSlot(), because we need the shape; // information for reload.; // tileloadd (%sp, %idx), %tmm",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:20,Integrability,depend,depends,20,// Current phi node depends on previous phi node. Break the; // dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:64,Integrability,depend,dependency,64,// Current phi node depends on previous phi node. Break the; // dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:24,Modifiability,config,configure,24,// PreTileConfig should configure the tile registers based on basic; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:39,Modifiability,config,configuring,39,// We have transformed phi node before configuring BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:58,Modifiability,config,config,58,"// According to AMX ABI, all the tile registers including config register; // are volatile. Caller need to save/restore config register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:120,Modifiability,config,config,120,"// According to AMX ABI, all the tile registers including config register; // are volatile. Caller need to save/restore config register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:165,Modifiability,config,config,165,"//; //---------------------------------------------------------------------; // Don't handle COPY instruction. If the src and dst of the COPY can be; // in the same config in below case, we just check the shape of t0.; // def row0; // def col0; // ldtilecfg; // t0 = tielzero(row0, col0); // t1 = copy t0; // ...; // If the src and dst of the COPY can NOT be in the same config in below; // case. Reload would be generated befor the copy instruction.; // def row0; // def col0; // t0 = tielzero(row0, col0); // spill t0; // ...; // def row1; // def col1; // ldtilecfg; // t1 = tilezero(row1, col1); // reload t0; // t1 = copy t0; //---------------------------------------------------------------------; //; // If MI dominate the last shape def instruction, we need insert; // ldtilecfg after LastShapeMI now. The config doesn't include; // current MI.; // def row0; // def col0; // tilezero(row0, col0) <- MI; // def row1; // def col1; // ldtilecfg <- insert; // tilezero(row1, col1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:371,Modifiability,config,config,371,"//; //---------------------------------------------------------------------; // Don't handle COPY instruction. If the src and dst of the COPY can be; // in the same config in below case, we just check the shape of t0.; // def row0; // def col0; // ldtilecfg; // t0 = tielzero(row0, col0); // t1 = copy t0; // ...; // If the src and dst of the COPY can NOT be in the same config in below; // case. Reload would be generated befor the copy instruction.; // def row0; // def col0; // t0 = tielzero(row0, col0); // spill t0; // ...; // def row1; // def col1; // ldtilecfg; // t1 = tilezero(row1, col1); // reload t0; // t1 = copy t0; //---------------------------------------------------------------------; //; // If MI dominate the last shape def instruction, we need insert; // ldtilecfg after LastShapeMI now. The config doesn't include; // current MI.; // def row0; // def col0; // tilezero(row0, col0) <- MI; // def row1; // def col1; // ldtilecfg <- insert; // tilezero(row1, col1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:813,Modifiability,config,config,813,"//; //---------------------------------------------------------------------; // Don't handle COPY instruction. If the src and dst of the COPY can be; // in the same config in below case, we just check the shape of t0.; // def row0; // def col0; // ldtilecfg; // t0 = tielzero(row0, col0); // t1 = copy t0; // ...; // If the src and dst of the COPY can NOT be in the same config in below; // case. Reload would be generated befor the copy instruction.; // def row0; // def col0; // t0 = tielzero(row0, col0); // spill t0; // ...; // def row1; // def col1; // ldtilecfg; // t1 = tilezero(row1, col1); // reload t0; // t1 = copy t0; //---------------------------------------------------------------------; //; // If MI dominate the last shape def instruction, we need insert; // ldtilecfg after LastShapeMI now. The config doesn't include; // current MI.; // def row0; // def col0; // tilezero(row0, col0) <- MI; // def row1; // def col1; // ldtilecfg <- insert; // tilezero(row1, col1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:3,Modifiability,Config,Configure,3,// Configure tile registers at the head of the MBB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:49,Modifiability,config,config,49,// Abandon early if there is no tile register to config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:34,Modifiability,config,config,34,// We will create register during config. *3 is to make sure; // the virtual register number doesn't exceed the size of; // the bit vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:872,Energy Efficiency,allocate,allocated,872,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:51,Modifiability,Config,Configure,51,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:398,Modifiability,config,config,398,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:470,Modifiability,config,configured,470,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:891,Modifiability,config,config,891,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:911,Modifiability,config,config,911,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:886,Performance,load,load,886,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:4,Performance,Perform,Perform,4,/// Perform register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:24,Modifiability,config,configure,24,// PreTileConfig should configure the tile registers based on basic; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:19,Modifiability,Rewrite,Rewrite,19,// PLDTILECFGV; // Rewrite the shape information to memory. Stack slot should have; // been initialized to zero in pre config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:119,Modifiability,config,config,119,// PLDTILECFGV; // Rewrite the shape information to memory. Stack slot should have; // been initialized to zero in pre config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:8,Modifiability,config,config,8,// tile config stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:40,Modifiability,config,config,40,"// Here is the data format for the tile config.; // 0 palette; // 1 start_row; // 2-15 reserved, must be zero; // 16-17 tile0.colsb Tile 0 bytes per row.; // 18-19 tile1.colsb Tile 1 bytes per row.; // 20-21 tile2.colsb Tile 2 bytes per row.; // ... (sequence continues); // 30-31 tile7.colsb Tile 7 bytes per row.; // 32-47 reserved, must be zero; // 48 tile0.rows Tile 0 rows.; // 49 tile1.rows Tile 1 rows.; // 50 tile2.rows Tile 2 rows.; // ... (sequence continues); // 55 tile7.rows Tile 7 rows.; // 56-63 reserved, must be zero",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:752,Integrability,depend,dependences,752,"//===-- X86FixupBWInsts.cpp - Fixup Byte or Word instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines the pass that looks through the machine instructions; /// late in the compilation, and finds byte or word instructions that; /// can be profitably replaced with 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:1064,Integrability,depend,dependence,1064,"s.cpp - Fixup Byte or Word instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines the pass that looks through the machine instructions; /// late in the compilation, and finds byte or word instructions that; /// can be profitably replaced with 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:1509,Integrability,depend,dependence,1509," /// This file defines the pass that looks through the machine instructions; /// late in the compilation, and finds byte or word instructions that; /// can be profitably replaced with 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only partially written earlier. On older; /// Intel processors this can be quite a performance penalty, so this should; /// probably only be done when it can be proven that a new partial dependence; /// wouldn't be created, or when ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:1863,Integrability,depend,dependences,1863,"ith 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only partially written earlier. On older; /// Intel processors this can be quite a performance penalty, so this should; /// probably only be done when it can be proven that a new partial dependence; /// wouldn't be created, or when your know a newer processor is being; /// targeted, or when optimizing for minimum code size.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:2339,Integrability,depend,dependence,2339,"ith 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only partially written earlier. On older; /// Intel processors this can be quite a performance penalty, so this should; /// probably only be done when it can be proven that a new partial dependence; /// wouldn't be created, or when your know a newer processor is being; /// targeted, or when optimizing for minimum code size.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:1153,Performance,load,load,1153,"ions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines the pass that looks through the machine instructions; /// late in the compilation, and finds byte or word instructions that; /// can be profitably replaced with 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only pa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:2235,Performance,perform,performance,2235,"ith 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only partially written earlier. On older; /// Intel processors this can be quite a performance penalty, so this should; /// probably only be done when it can be proven that a new partial dependence; /// wouldn't be created, or when your know a newer processor is being; /// targeted, or when optimizing for minimum code size.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:2444,Performance,optimiz,optimizing,2444,"ith 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only partially written earlier. On older; /// Intel processors this can be quite a performance penalty, so this should; /// probably only be done when it can be proven that a new partial dependence; /// wouldn't be created, or when your know a newer processor is being; /// targeted, or when optimizing for minimum code size.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:740,Safety,avoid,avoid,740,"//===-- X86FixupBWInsts.cpp - Fixup Byte or Word instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines the pass that looks through the machine instructions; /// late in the compilation, and finds byte or word instructions that; /// can be profitably replaced with 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:24,Performance,optimiz,optimization,24,// Option to allow this optimization pass to have fine-grained control.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:54,Modifiability,extend,extending,54,"/// Change the MachineInstr \p MI into the equivalent extending load to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:64,Performance,load,load,64,"/// Change the MachineInstr \p MI into the equivalent extending load to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:102,Safety,safe,safe,102,"/// Change the MachineInstr \p MI into the equivalent extending load to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:80,Safety,safe,safe,80,"/// Change the MachineInstr \p MI into the equivalent 32-bit copy if it is; /// safe to do so. Return the replacement instruction if OK, otherwise return; /// nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:54,Modifiability,extend,extend,54,"/// Change the MachineInstr \p MI into the equivalent extend to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:94,Safety,safe,safe,94,"/// Change the MachineInstr \p MI into the equivalent extend to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:36,Usability,guid,guide,36,// Machine loop info is used to; // guide some heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:121,Performance,perform,performance,121,"/// Loop over all of the basic blocks, replacing byte and word instructions by; /// equivalent 32 bit instructions where performance or code size can be; /// improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:31,Usability,guid,guiding,31,/// Machine loop info used for guiding some heruistics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:118,Availability,alive,alive,118,"/// Check if after \p OrigMI the only portion of super register; /// of the destination register of \p OrigMI that is alive is that; /// destination register.; ///; /// If so, return that super register in \p SuperDestReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:138,Safety,safe,safe,138,// Test all regunits of the super register that are not part of the; // sub register. If none of them are live then the super register is safe to; // use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:3,Testability,Test,Test,3,// Test all regunits of the super register that are not part of the; // sub register. If none of them are live then the super register is safe to; // use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:26,Modifiability,rewrite,rewrite,26,"// We are going to try to rewrite this load to a larger zero-extending; // load. This is safe if all portions of the 32 bit super-register; // of the original destination register, except for the original destination; // register are dead. getSuperRegDestIfDead checks that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:61,Modifiability,extend,extending,61,"// We are going to try to rewrite this load to a larger zero-extending; // load. This is safe if all portions of the 32 bit super-register; // of the original destination register, except for the original destination; // register are dead. getSuperRegDestIfDead checks that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:39,Performance,load,load,39,"// We are going to try to rewrite this load to a larger zero-extending; // load. This is safe if all portions of the 32 bit super-register; // of the original destination register, except for the original destination; // register are dead. getSuperRegDestIfDead checks that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:75,Performance,load,load,75,"// We are going to try to rewrite this load to a larger zero-extending; // load. This is safe if all portions of the 32 bit super-register; // of the original destination register, except for the original destination; // register are dead. getSuperRegDestIfDead checks that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:89,Safety,safe,safe,89,"// We are going to try to rewrite this load to a larger zero-extending; // load. This is safe if all portions of the 32 bit super-register; // of the original destination register, except for the original destination; // register are dead. getSuperRegDestIfDead checks that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:3,Safety,Safe,Safe,3,// Safe to change the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:30,Security,access,access,30,"// This is only correct if we access the same subregister index: otherwise,; // we could try to replace ""movb %ah, %al"" with ""movl %eax, %eax"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:3,Safety,Safe,Safe,3,"// Safe to change the instruction.; // Don't set src flags, as we don't know if we're also killing the superreg.; // However, the superregister might not be defined; make it explicit that; // we don't care about the higher bits by reading it as Undef, and adding; // an imp-use on the original subregister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:36,Availability,redundant,redundant,36,// Drop imp-defs/uses that would be redundant with the new def/use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:36,Safety,redund,redundant,36,// Drop imp-defs/uses that would be redundant with the new def/use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:3,Safety,Safe,Safe,3,// Safe to change the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:37,Modifiability,extend,extending,37,"// Replace 8-bit loads with the zero-extending version if not optimizing; // for size. The extending op is cheaper across a wide range of uarch and; // it avoids a potentially expensive partial register stall. It takes an; // extra byte to encode, however, so don't do this when optimizing for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:91,Modifiability,extend,extending,91,"// Replace 8-bit loads with the zero-extending version if not optimizing; // for size. The extending op is cheaper across a wide range of uarch and; // it avoids a potentially expensive partial register stall. It takes an; // extra byte to encode, however, so don't do this when optimizing for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:17,Performance,load,loads,17,"// Replace 8-bit loads with the zero-extending version if not optimizing; // for size. The extending op is cheaper across a wide range of uarch and; // it avoids a potentially expensive partial register stall. It takes an; // extra byte to encode, however, so don't do this when optimizing for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:62,Performance,optimiz,optimizing,62,"// Replace 8-bit loads with the zero-extending version if not optimizing; // for size. The extending op is cheaper across a wide range of uarch and; // it avoids a potentially expensive partial register stall. It takes an; // extra byte to encode, however, so don't do this when optimizing for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:279,Performance,optimiz,optimizing,279,"// Replace 8-bit loads with the zero-extending version if not optimizing; // for size. The extending op is cheaper across a wide range of uarch and; // it avoids a potentially expensive partial register stall. It takes an; // extra byte to encode, however, so don't do this when optimizing for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:155,Safety,avoid,avoids,155,"// Replace 8-bit loads with the zero-extending version if not optimizing; // for size. The extending op is cheaper across a wide range of uarch and; // it avoids a potentially expensive partial register stall. It takes an; // extra byte to encode, however, so don't do this when optimizing for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:161,Integrability,depend,dependence,161,"// Always try to replace 16 bit load with 32 bit zero extending.; // Code size is the same, and there is sometimes a perf advantage; // from eliminating a false dependence on the upper portion of; // the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:54,Modifiability,extend,extending,54,"// Always try to replace 16 bit load with 32 bit zero extending.; // Code size is the same, and there is sometimes a perf advantage; // from eliminating a false dependence on the upper portion of; // the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:32,Performance,load,load,32,"// Always try to replace 16 bit load with 32 bit zero extending.; // Code size is the same, and there is sometimes a perf advantage; // from eliminating a false dependence on the upper portion of; // the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:178,Integrability,depend,dependence,178,"// Always try to replace 8/16 bit copies with a 32 bit copy.; // Code size is either less (16) or equal (8), and there is sometimes a; // perf advantage from eliminating a false dependence on the upper portion; // of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:86,Deployability,update,update,86,// Start computing liveness for this block. We iterate from the end to be able; // to update this for each instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:37,Deployability,update,update,37,"// We're done with this instruction, update liveness for the next one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp:912,Availability,mask,mask,912,"//===-- X86FixupInstTunings.cpp - replace instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file does a tuning pass replacing slower machine instructions; // with faster ones. We do this here, as opposed to during normal ISel, as; // attempting to get the ""right"" instruction can break patterns. This pass; // is not meant search for special cases where an instruction can be transformed; // to another, it is only meant to do transformations where the old instruction; // is always replacable with the new instructions. For example:; //; // `vpermq ymm` -> `vshufd ymm`; // -- BAD, not always valid (lane cross/non-repeated mask); //; // `vpermilps ymm` -> `vshufd ymm`; // -- GOOD, always replaceable; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp:81,Availability,down,downside,81,"// TODO it may be worth it to set ReplaceInTie to `true` as there is no real; // downside to the integer unpck, but if someone doesn't specify exact; // target we won't find it faster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp:51,Testability,test,test,51,// TODO: See if there is a more generic way we can test if the replacement; // instruction is supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:495,Deployability,pipeline,pipeline,495,"//===-- X86FixupLEAs.cpp - use or replace LEA instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass that finds instructions that can be; // re-written as LEA instructions in order to reduce pipeline delays.; // It replaces LEAs with ADD/INC/DEC when that is better for size/speed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:488,Energy Efficiency,reduce,reduce,488,"//===-- X86FixupLEAs.cpp - use or replace LEA instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass that finds instructions that can be; // re-written as LEA instructions in order to reduce pipeline delays.; // It replaces LEAs with ADD/INC/DEC when that is better for size/speed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:19,Security,access,access,19,"/// Given a memory access or LEA instruction; /// whose address mode uses a base and/or index register, look for; /// an opportunity to replace the instruction which sets the base or index; /// register with an equivalent LEA instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:132,Performance,Optimiz,Optimization,132,"/// Given a LEA instruction which is unprofitable; /// on SNB+ try to replace it with other instructions.; /// According to Intel's Optimization Reference Manual:; /// "" For LEA instructions with three source operands and some specific; /// situations, instruction latency has increased to 3 cycles, and must; /// dispatch via port 1:; /// - LEA that has all three source operands: base, index, and offset; /// - LEA that uses base and index registers where the base is EBP, RBP,; /// or R13; /// - LEA that uses RIP relative addressing mode; /// - LEA that uses 16-bit addressing mode ""; /// This function currently handles the first 2 cases only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:265,Performance,latency,latency,265,"/// Given a LEA instruction which is unprofitable; /// on SNB+ try to replace it with other instructions.; /// According to Intel's Optimization Reference Manual:; /// "" For LEA instructions with three source operands and some specific; /// situations, instruction latency has increased to 3 cycles, and must; /// dispatch via port 1:; /// - LEA that has all three source operands: base, index, and offset; /// - LEA that uses base and index registers where the base is EBP, RBP,; /// or R13; /// - LEA that uses RIP relative addressing mode; /// - LEA that uses 16-bit addressing mode ""; /// This function currently handles the first 2 cases only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:153,Performance,optimiz,optimize,153,"/// Look for and transform the sequence; /// lea (reg1, reg2), reg3; /// sub reg3, reg4; /// to; /// sub reg1, reg4; /// sub reg2, reg4; /// It can also optimize the sequence lea/add similarly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:160,Performance,latency,latency,160,"/// Step backwards through a basic block, looking; /// for an instruction which writes a register within; /// a maximum of INSTR_DISTANCE_THRESHOLD instruction latency cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:53,Safety,safe,safe,53,// Only convert instructions that we've verified are safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:32,Performance,optimiz,optimize,32,// First pass. Try to remove or optimize existing LEAs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:148,Integrability,wrap,wrapping,148,"/// getPreviousInstr - Given a reference to an instruction in a basic; /// block, return a reference to the previous instruction in the block,; /// wrapping around to the last instruction of the block if the block; /// branches to itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:157,Energy Efficiency,schedul,scheduling,157,"/// Returns true if this LEA uses base and index registers, and the base; /// register is known to be inefficient for the subtarget.; // TODO: use a variant scheduling class to model the latency profile; // of LEA instructions, and implement this logic as a scheduling predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:258,Energy Efficiency,schedul,scheduling,258,"/// Returns true if this LEA uses base and index registers, and the base; /// register is known to be inefficient for the subtarget.; // TODO: use a variant scheduling class to model the latency profile; // of LEA instructions, and implement this logic as a scheduling predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:187,Performance,latency,latency,187,"/// Returns true if this LEA uses base and index registers, and the base; /// register is known to be inefficient for the subtarget.; // TODO: use a variant scheduling class to model the latency profile; // of LEA instructions, and implement this logic as a scheduling predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:247,Testability,log,logic,247,"/// Returns true if this LEA uses base and index registers, and the base; /// register is known to be inefficient for the subtarget.; // TODO: use a variant scheduling class to model the latency profile; // of LEA instructions, and implement this logic as a scheduling predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:12,Safety,safe,safe,12,// Now it's safe to change instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:3,Usability,Clear,Clear,3,// Clear the old Kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:13,Performance,load,load,13,"// Process a load, store, or LEA instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp:30,Performance,optimiz,optimize,30,"//===---- X86FixupSetCC.cpp - optimize usage of LEA instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that fixes zero-extension of setcc patterns.; // X86 setcc instructions are modeled to have no input arguments, and a single; // GR8 output argument. This is consistent with other similar instructions; // (e.g. movb), but means it is impossible to directly generate a setcc into; // the lower GR8 of a specified GR32.; // This means that ISel must select (zext (setcc)) into something like; // seta %al; movzbl %al, %eax.; // Unfortunately, this can cause a stall due to the partial register write; // performed by the setcc. Instead, we can use:; // xor %eax, %eax; seta %al; // This both avoids the stall, and encodes shorter.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp:910,Performance,perform,performed,910,"//===---- X86FixupSetCC.cpp - optimize usage of LEA instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that fixes zero-extension of setcc patterns.; // X86 setcc instructions are modeled to have no input arguments, and a single; // GR8 output argument. This is consistent with other similar instructions; // (e.g. movb), but means it is impossible to directly generate a setcc into; // the lower GR8 of a specified GR32.; // This means that ISel must select (zext (setcc)) into something like; // seta %al; movzbl %al, %eax.; // Unfortunately, this can cause a stall due to the partial register write; // performed by the setcc. Instead, we can use:; // xor %eax, %eax; seta %al; // This both avoids the stall, and encodes shorter.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp:998,Safety,avoid,avoids,998,"//===---- X86FixupSetCC.cpp - optimize usage of LEA instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that fixes zero-extension of setcc patterns.; // X86 setcc instructions are modeled to have no input arguments, and a single; // GR8 output argument. This is consistent with other similar instructions; // (e.g. movb), but means it is impossible to directly generate a setcc into; // the lower GR8 of a specified GR32.; // This means that ISel must select (zext (setcc)) into something like; // seta %al; movzbl %al, %eax.; // Unfortunately, this can cause a stall due to the partial register write; // performed by the setcc. Instead, we can use:; // xor %eax, %eax; seta %al; // This both avoids the stall, and encodes shorter.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp:104,Safety,safe,safe,104,"// Find a setcc that is used by a zext.; // This doesn't have to be the only use, the transformation is safe; // regardless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:38,Performance,optimiz,optimize,38,"//===-- X86FixupVectorConstants.cpp - optimize constant generation -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file examines all full size vector constant pool loads and attempts to; // replace them with smaller constant pool entries, including:; // * Converting AVX512 memory-fold instructions to their broadcast-fold form; // * Broadcasting of full width loads.; // * TODO: Sign/Zero extension of full width loads.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:436,Performance,load,loads,436,"//===-- X86FixupVectorConstants.cpp - optimize constant generation -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file examines all full size vector constant pool loads and attempts to; // replace them with smaller constant pool entries, including:; // * Converting AVX512 memory-fold instructions to their broadcast-fold form; // * Broadcasting of full width loads.; // * TODO: Sign/Zero extension of full width loads.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:633,Performance,load,loads,633,"//===-- X86FixupVectorConstants.cpp - optimize constant generation -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file examines all full size vector constant pool loads and attempts to; // replace them with smaller constant pool entries, including:; // * Converting AVX512 memory-fold instructions to their broadcast-fold form; // * Broadcasting of full width loads.; // * TODO: Sign/Zero extension of full width loads.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:686,Performance,load,loads,686,"//===-- X86FixupVectorConstants.cpp - optimize constant generation -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file examines all full size vector constant pool loads and attempts to; // replace them with smaller constant pool entries, including:; // * Converting AVX512 memory-fold instructions to their broadcast-fold form; // * Broadcasting of full width loads.; // * TODO: Sign/Zero extension of full width loads.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:3,Safety,Detect,Detect,3,// Detect general splats with undefs.; // TODO: Do we need to handle NumEltsBits > SplatBitWidth splitting?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:14,Safety,detect,detect,14,// Attempt to detect a suitable splat from increasing splat widths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:40,Performance,load,loads,40,// Attempt to convert full width vector loads into broadcast loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:61,Performance,load,loads,61,// Attempt to convert full width vector loads into broadcast loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:6,Performance,Load,Loads,6,/* FP Loads */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:11,Performance,Load,Loads,11,/* Integer Loads */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:64,Testability,log,logic,64,// Reverse the X86InstrInfo::setExecutionDomainCustom EVEX->VEX logic; // conversion to see if we can convert to a broadcasted (integer) logic op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:137,Testability,log,logic,137,// Reverse the X86InstrInfo::setExecutionDomainCustom EVEX->VEX logic; // conversion to see if we can convert to a broadcasted (integer) logic op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:692,Energy Efficiency,efficient,efficiently,692,"//====- X86FlagsCopyLowering.cpp - Lowers COPY nodes of EFLAGS ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Lowers COPY nodes of EFLAGS by directly extracting and preserving individual; /// flag bits.; ///; /// We have to do this by carefully analyzing and rewriting the usage of the; /// copied EFLAGS register because there is no general way to rematerialize the; /// entire EFLAGS register safely and efficiently. Using `popf` both forces; /// dynamic stack adjustment and can create correctness issues due to IF, TF,; /// and other non-status flags being overwritten. Using sequences involving; /// SAHF don't work on all x86 processors and are often quite slow compared to; /// directly testing a single status preserved in its own GPR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:681,Safety,safe,safely,681,"//====- X86FlagsCopyLowering.cpp - Lowers COPY nodes of EFLAGS ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Lowers COPY nodes of EFLAGS by directly extracting and preserving individual; /// flag bits.; ///; /// We have to do this by carefully analyzing and rewriting the usage of the; /// copied EFLAGS register because there is no general way to rematerialize the; /// entire EFLAGS register safely and efficiently. Using `popf` both forces; /// dynamic stack adjustment and can create correctness issues due to IF, TF,; /// and other non-status flags being overwritten. Using sequences involving; /// SAHF don't work on all x86 processors and are often quite slow compared to; /// directly testing a single status preserved in its own GPR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:980,Testability,test,testing,980,"//====- X86FlagsCopyLowering.cpp - Lowers COPY nodes of EFLAGS ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Lowers COPY nodes of EFLAGS by directly extracting and preserving individual; /// flag bits.; ///; /// We have to do this by carefully analyzing and rewriting the usage of the; /// copied EFLAGS register because there is no general way to rematerialize the; /// entire EFLAGS register safely and efficiently. Using `popf` both forces; /// dynamic stack adjustment and can create correctness issues due to IF, TF,; /// and other non-status flags being overwritten. Using sequences involving; /// SAHF don't work on all x86 processors and are often quite slow compared to; /// directly testing a single status preserved in its own GPR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:7,Deployability,update,update,7,// Now update all the PHIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:180,Testability,test,testing,180,// Collect the copies in RPO so that when there are chains where a copy is in; // turn copied again we visit the first one first. This ensures we can find; // viable locations for testing the original EFLAGS that dominate all the; // uses across complex CFGs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:229,Safety,avoid,avoid,229,"// FIXME: The big likely candidate here are PHI nodes. We could in theory; // handle PHI nodes, but it gets really, really hard. Insanely hard. Hard; // enough that it is probably better to change every other part of LLVM; // to avoid creating them. The issue is that once we have PHIs we won't; // know which original EFLAGS value we need to capture with our setCCs; // below. The end result will be computing a complete set of setCCs that; // we *might* want, computing them in every place where we copy *out* of; // EFLAGS and then doing SSA formation on all of them to insert necessary; // PHI nodes and consume those here. Then hoping that somehow we DCE the; // unnecessary ones. This DCE seems very unlikely to be successful and so; // we will almost certainly end up with a glut of dead setCC; // instructions. Until we have a motivating test case and fail to avoid; // it by changing other parts of LLVM's lowering, we refuse to handle; // this complex case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:868,Safety,avoid,avoid,868,"// FIXME: The big likely candidate here are PHI nodes. We could in theory; // handle PHI nodes, but it gets really, really hard. Insanely hard. Hard; // enough that it is probably better to change every other part of LLVM; // to avoid creating them. The issue is that once we have PHIs we won't; // know which original EFLAGS value we need to capture with our setCCs; // below. The end result will be computing a complete set of setCCs that; // we *might* want, computing them in every place where we copy *out* of; // EFLAGS and then doing SSA formation on all of them to insert necessary; // PHI nodes and consume those here. Then hoping that somehow we DCE the; // unnecessary ones. This DCE seems very unlikely to be successful and so; // we will almost certainly end up with a glut of dead setCC; // instructions. Until we have a motivating test case and fail to avoid; // it by changing other parts of LLVM's lowering, we refuse to handle; // this complex case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:846,Testability,test,test,846,"// FIXME: The big likely candidate here are PHI nodes. We could in theory; // handle PHI nodes, but it gets really, really hard. Insanely hard. Hard; // enough that it is probably better to change every other part of LLVM; // to avoid creating them. The issue is that once we have PHIs we won't; // know which original EFLAGS value we need to capture with our setCCs; // below. The end result will be computing a complete set of setCCs that; // we *might* want, computing them in every place where we copy *out* of; // EFLAGS and then doing SSA formation on all of them to insert necessary; // PHI nodes and consume those here. Then hoping that somehow we DCE the; // unnecessary ones. This DCE seems very unlikely to be successful and so; // we will almost certainly end up with a glut of dead setCC; // instructions. Until we have a motivating test case and fail to avoid; // it by changing other parts of LLVM's lowering, we refuse to handle; // this complex case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:41,Testability,test,test,41,"// We found a viable location, hoist our test position to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:3,Usability,Clear,Clear,3,// Clear the debug location as it would just be confusing after hoisting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:45,Modifiability,rewrite,rewrite,45,"// While rewriting uses, we buffer jumps and rewrite them in a second pass; // because doing so will perturb the CFG that we are walking to find the; // uses in the first place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:431,Integrability,rout,routine,431,"// In most cases, we walk from the beginning to the end of the block. But; // when the block is the same block as the copy is from, we will visit it; // twice. The first time we start from the copy and go to the end. The; // second time we start from the beginning and go to the copy. This lets; // us handle copies inside of cycles.; // FIXME: This loop is *super* confusing. This is at least in part; // a symptom of all of this routine needing to be refactored into; // documentable components. Once done, there may be a better way to write; // this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:453,Modifiability,refactor,refactored,453,"// In most cases, we walk from the beginning to the end of the block. But; // when the block is the same block as the copy is from, we will visit it; // twice. The first time we start from the copy and go to the end. The; // second time we start from the beginning and go to the copy. This lets; // us handle copies inside of cycles.; // FIXME: This loop is *super* confusing. This is at least in part; // a symptom of all of this routine needing to be refactored into; // documentable components. Once done, there may be a better way to write; // this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:258,Deployability,update,updated,258,"// If EFLAGS are defined, it's as-if they were killed. We can stop; // scanning here.; //; // NB!!! Many instructions only modify some flags. LLVM currently; // models this as clobbering all flags, but if that ever changes; // this will need to be carefully updated to handle that more; // complex logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:298,Testability,log,logic,298,"// If EFLAGS are defined, it's as-if they were killed. We can stop; // scanning here.; //; // NB!!! Many instructions only modify some flags. LLVM currently; // models this as clobbering all flags, but if that ever changes; // this will need to be carefully updated to handle that more; // complex logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:33,Modifiability,rewrite,rewrite,33,// Check the kill flag before we rewrite as that may change it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:96,Modifiability,rewrite,rewrite,96,"// Once we encounter a branch, the rest of the instructions must also be; // branches. We can't rewrite in place here, so we handle them below.; //; // Note that we don't have to handle tail calls here, even conditional; // tail calls, as those are not introduced into the X86 MI until post-RA; // branch folding or black placement. As a consequence, we get to deal; // with the simpler formulation of conditional branches followed by tail; // calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:379,Usability,simpl,simpler,379,"// Once we encounter a branch, the rest of the instructions must also be; // branches. We can't rewrite in place here, so we handle them below.; //; // Note that we don't have to handle tail calls here, even conditional; // tail calls, as those are not introduced into the X86 MI until post-RA; // branch folding or black placement. As a consequence, we get to deal; // with the simpler formulation of conditional branches followed by tail; // calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:25,Modifiability,rewrite,rewrite,25,// Otherwise we can just rewrite in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:58,Deployability,update,update,58,"// NB!!! Several arithmetic instructions only *partially* update; // flags. Theoretically, we could generate MI code sequences that; // would rely on this fact and observe different flags independently.; // But currently LLVM models all of these instructions as clobbering; // all the flags in an undef way. We rely on that to simplify the; // logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:344,Testability,log,logic,344,"// NB!!! Several arithmetic instructions only *partially* update; // flags. Theoretically, we could generate MI code sequences that; // would rely on this fact and observe different flags independently.; // But currently LLVM models all of these instructions as clobbering; // all the flags in an undef way. We rely on that to simplify the; // logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:327,Usability,simpl,simplify,327,"// NB!!! Several arithmetic instructions only *partially* update; // flags. Theoretically, we could generate MI code sequences that; // would rely on this fact and observe different flags independently.; // But currently LLVM models all of these instructions as clobbering; // all the flags in an undef way. We rely on that to simplify the; // logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:81,Performance,queue,queue,81,// Otherwise we need to scan successors for ones where the flags live-in; // and queue those up for processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:74,Testability,test,test,74,"// We currently don't do any PHI insertion and so we require that the; // test basic block dominates all of the use basic blocks. Further, we; // can't have a cycle from the test block back to itself as that would; // create a cycle requiring a PHI to break it.; //; // We could in theory do PHI insertion here if it becomes useful by; // just taking undef values in along every edge that we don't trace; // this EFLAGS copy along. This isn't as bad as fully general PHI; // insertion, but still seems like a great deal of complexity.; //; // Because it is theoretically possible that some earlier MI pass or; // other lowering transformation could induce this to happen, we do; // a hard check even in non-debug builds here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:174,Testability,test,test,174,"// We currently don't do any PHI insertion and so we require that the; // test basic block dominates all of the use basic blocks. Further, we; // can't have a cycle from the test block back to itself as that would; // create a cycle requiring a PHI to break it.; //; // We could in theory do PHI insertion here if it becomes useful by; // just taking undef values in along every edge that we don't trace; // this EFLAGS copy along. This isn't as bad as fully general PHI; // insertion, but still seems like a great deal of complexity.; //; // Because it is theoretically possible that some earlier MI pass or; // other lowering transformation could induce this to happen, we do; // a hard check even in non-debug builds here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:7,Modifiability,rewrite,rewrite,7,// Now rewrite the jumps that use the flags. These we handle specially; // because if there are multiple jumps in a single basic block we'll have; // to do surgery on the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:108,Availability,avail,available,108,// CF == 1; // Set up an addend that when one is added will need a carry due to not; // having a higher bit available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:119,Usability,simpl,simplify,119,// Now get a register that contains the value of the flag input to the; // arithmetic. We require exactly this flag to simplify the arithmetic; // required to materialize it back into the flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:19,Testability,test,test,19,// Insert a direct test of the saved register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the CMov to use the !ZF flag from the test, and then kill its use; // of the flags afterward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:49,Testability,test,test,49,"// Rewrite the CMov to use the !ZF flag from the test, and then kill its use; // of the flags afterward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:19,Testability,test,test,19,// Insert a direct test of the saved register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the CMov to use the !ZF flag from the test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:49,Testability,test,test,49,// Rewrite the CMov to use the !ZF flag from the test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:19,Testability,test,test,19,// Insert a direct test of the saved register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the jump to use the !ZF flag from the test, and kill its use of; // flags afterward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:49,Testability,test,test,49,"// Rewrite the jump to use the !ZF flag from the test, and kill its use of; // flags afterward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:31,Modifiability,rewrite,rewrite,31,// Note that we can't usefully rewrite this to the inverse without complex; // analysis of the users of the setCC. Largely we rely on duplicates which; // could have been avoided already being avoided here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:171,Safety,avoid,avoided,171,// Note that we can't usefully rewrite this to the inverse without complex; // analysis of the users of the setCC. Largely we rely on duplicates which; // could have been avoided already being avoided here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:193,Safety,avoid,avoided,193,// Note that we can't usefully rewrite this to the inverse without complex; // analysis of the users of the setCC. Largely we rely on duplicates which; // could have been avoided already being avoided here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:537,Modifiability,variab,variable,537,"//===-- X86FloatingPoint.cpp - Floating point Reg -> Stack converter ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which converts floating point instructions from; // pseudo registers into register stack instructions. This pass uses live; // variable information to indicate where the FPn registers are used and their; // lifetimes.; //; // The x87 hardware tracks liveness of the stack registers, so it is necessary; // to implement exact liveness tracking between basic blocks. The CFG edges are; // partitioned into bundles where the same FP registers must be live in; // identical stack positions. Instructions are inserted at the end of each basic; // block to rearrange the live registers to match the outgoing bundle.; //; // This approach avoids splitting critical edges at the potential cost of more; // live register shuffling instructions when critical edges are present.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:1042,Safety,avoid,avoids,1042,"//===-- X86FloatingPoint.cpp - Floating point Reg -> Stack converter ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which converts floating point instructions from; // pseudo registers into register stack instructions. This pass uses live; // variable information to indicate where the FPn registers are used and their; // lifetimes.; //; // The x87 hardware tracks liveness of the stack registers, so it is necessary; // to implement exact liveness tracking between basic blocks. The CFG edges are; // partitioned into bundles where the same FP registers must be live in; // identical stack positions. Instructions are inserted at the end of each basic; // block to rearrange the live registers to match the outgoing bundle.; //; // This approach avoids splitting critical edges at the potential cost of more; // live register shuffling instructions when critical edges are present.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:55,Testability,log,logic,55,// This is really only to keep valgrind quiet.; // The logic in isLive() is too much for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:272,Energy Efficiency,allocate,allocated,272,"// Machine instruction info.; // Two CFG edges are related if they leave the same block, or enter the same; // block. The transitive closure of an edge under this relation is a; // LiveBundle. It represents a set of CFG edges where the live FP stack; // registers must be allocated identically in the x87 stack.; //; // A LiveBundle is usually all the edges leaving a block, or all the edges; // entering a block, but it can contain more edges if critical edges are; // present.; //; // The set of live FP registers in a LiveBundle is calculated by bundleCFG,; // but the exact mapping of FP registers to stack slots is fixed later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:7,Availability,mask,mask,7,"// Bit mask of live FP registers. Bit 0 = FP0, bit 1 = FP1, &c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:3,Deployability,Update,Update,3,// Update state,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:19,Deployability,update,update,19,// Emit an fxch to update the runtime processors version of the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:47,Availability,Mask,Mask,47,/// Adjust the live registers to be the set in Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:120,Availability,mask,mask,120,"// In the register calling convention, up to one FP argument could be; // saved in the first FP register.; // If bundle.mask is non-zero and Bundle.FixCount is zero, it means; // that the FP registers contain arguments.; // The actual value is passed in FP0.; // Here we fix the stack and mark FP0 as pre-assigned register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:29,Availability,mask,masks,29,// Gather the actual live-in masks for all MBBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:29,Availability,mask,mask,29,// Update MBB ingoing bundle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:3,Deployability,Update,Update,3,// Update MBB ingoing bundle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:3,Energy Efficiency,Efficient,Efficiently,3,// Efficiently ignore non-fp insts!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:12,Modifiability,variab,variables,12,// Get dead variables list now because the MI pointer may be deleted as part; // of processing!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:85,Energy Efficiency,Efficient,Efficient,85,//===----------------------------------------------------------------------===//; // Efficient Lookup Table Support; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:101,Availability,Mask,Mask,101,/// adjustLiveRegs - Kill and revive registers such that exactly the FP; /// registers with a bit in Mask are live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:3,Performance,Load,Load,3,// Load zeros for all the imp-defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:44,Modifiability,variab,variable,44,"// If this call has been modified, drop all variable values defined by it.; // We can't track them once they've been stackified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:3,Testability,Assert,Assert,3,// Assert that the top of stack contains the right FP register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:92,Testability,assert,assertion,92,"// Ok, everything is good, mark the value as not being on the stack; // anymore so that our assertion about the stack being empty at end of; // block doesn't fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:116,Usability,simpl,simplified,116,"/// handleTwoArgFP - Handle instructions like FADD and friends which are virtual; /// instructions which need to be simplified and possibly transformed.; ///; /// Result: ST(0) = fsub ST(0), ST(i); /// ST(i) = fsub ST(0), ST(i); /// ST(0) = fsubr ST(0), ST(i); /// ST(i) = fsubr ST(0), ST(i); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:182,Deployability,update,update,182,"// No operand at TOS?; // We can choose to move either operand to the top of the stack. If one of; // the operands is killed by this instruction, we want that one so that we; // can update right on top of the old version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:82,Deployability,update,update,82,"// All of the operands are live after this instruction executes, so we; // cannot update on top of any operand. Because of this, we must; // duplicate one of the stack elements to the top. It doesn't matter; // which one we pick.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:3,Deployability,Update,Update,3,// Update stack information so that we know the destination register is now on; // the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:51,Performance,load,load,51,"// All FP registers must be explicitly defined, so load a 0 instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:32,Modifiability,rewrite,rewrite,32,"// With the stack layout fixed, rewrite the FP registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Performance,Cache,Cache,3,// Cache a bunch of frame-related predicates for this subtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:104,Usability,simpl,simplified,104,"/// canSimplifyCallFramePseudos - If there is a reserved call frame, the; /// call frame pseudos can be simplified. Having a FP, as in the default; /// implementation, is not sufficient here since we can't always use it.; /// Use a more nuanced condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:45,Performance,perform,perform,45,"// needsFrameIndexResolution - Do we need to perform FI resolution for; // this function. Normally, this is required only when the function; // has any stack objects. However, FI resolution actually has another job,; // not apparent from the title - it resolves callframesetup/destroy; // that were not simplified earlier.; // So, this is required for x86 functions that have push sequences even; // when there are no stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:303,Usability,simpl,simplified,303,"// needsFrameIndexResolution - Do we need to perform FI resolution for; // this function. Normally, this is required only when the function; // has any stack objects. However, FI resolution actually has another job,; // not apparent from the title - it resolves callframesetup/destroy; // that were not simplified earlier.; // So, this is required for x86 functions that have push sequences even; // when there are no stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:136,Modifiability,variab,variable,136,/// hasFP - Return true if the specified function should have a dedicated frame; /// pointer register. This is true if the function has variable sized allocas; /// or if frame pointer elimination is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:392,Energy Efficiency,efficient,efficient,392,"// Push-Pop Acceleration (PPX) hint is used to indicate that the POP reads the; // value written by the PUSH from the stack. The processor tracks these marked; // instructions internally and fast-forwards register data between matching PUSH; // and POP instructions, without going through memory or through the training; // loop of the Fast Store Forwarding Predictor (FSFP). Instead, a more efficient; // memory-renaming optimization can be used.; //; // The PPX hint is purely a performance hint. Instructions with this hint have; // the same functional semantics as those without. PPX hints set by the; // compiler that violate the balancing rule may turn off the PPX optimization,; // but they will not affect program semantics.; //; // Hence, PPX is used for balanced spill/reloads (Exceptions and setjmp/longjmp; // are not considered).; //; // PUSH2 and POP2 are instructions for (respectively) pushing/popping 2; // GPRs at a time to/from the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:422,Performance,optimiz,optimization,422,"// Push-Pop Acceleration (PPX) hint is used to indicate that the POP reads the; // value written by the PUSH from the stack. The processor tracks these marked; // instructions internally and fast-forwards register data between matching PUSH; // and POP instructions, without going through memory or through the training; // loop of the Fast Store Forwarding Predictor (FSFP). Instead, a more efficient; // memory-renaming optimization can be used.; //; // The PPX hint is purely a performance hint. Instructions with this hint have; // the same functional semantics as those without. PPX hints set by the; // compiler that violate the balancing rule may turn off the PPX optimization,; // but they will not affect program semantics.; //; // Hence, PPX is used for balanced spill/reloads (Exceptions and setjmp/longjmp; // are not considered).; //; // PUSH2 and POP2 are instructions for (respectively) pushing/popping 2; // GPRs at a time to/from the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:481,Performance,perform,performance,481,"// Push-Pop Acceleration (PPX) hint is used to indicate that the POP reads the; // value written by the PUSH from the stack. The processor tracks these marked; // instructions internally and fast-forwards register data between matching PUSH; // and POP instructions, without going through memory or through the training; // loop of the Fast Store Forwarding Predictor (FSFP). Instead, a more efficient; // memory-renaming optimization can be used.; //; // The PPX hint is purely a performance hint. Instructions with this hint have; // the same functional semantics as those without. PPX hints set by the; // compiler that violate the balancing rule may turn off the PPX optimization,; // but they will not affect program semantics.; //; // Hence, PPX is used for balanced spill/reloads (Exceptions and setjmp/longjmp; // are not considered).; //; // PUSH2 and POP2 are instructions for (respectively) pushing/popping 2; // GPRs at a time to/from the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:671,Performance,optimiz,optimization,671,"// Push-Pop Acceleration (PPX) hint is used to indicate that the POP reads the; // value written by the PUSH from the stack. The processor tracks these marked; // instructions internally and fast-forwards register data between matching PUSH; // and POP instructions, without going through memory or through the training; // loop of the Fast Store Forwarding Predictor (FSFP). Instead, a more efficient; // memory-renaming optimization can be used.; //; // The PPX hint is purely a performance hint. Instructions with this hint have; // the same functional semantics as those without. PPX hints set by the; // compiler that violate the balancing rule may turn off the PPX optimization,; // but they will not affect program semantics.; //; // Hence, PPX is used for balanced spill/reloads (Exceptions and setjmp/longjmp; // are not considered).; //; // PUSH2 and POP2 are instructions for (respectively) pushing/popping 2; // GPRs at a time to/from the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:358,Safety,Predict,Predictor,358,"// Push-Pop Acceleration (PPX) hint is used to indicate that the POP reads the; // value written by the PUSH from the stack. The processor tracks these marked; // instructions internally and fast-forwards register data between matching PUSH; // and POP instructions, without going through memory or through the training; // loop of the Fast Store Forwarding Predictor (FSFP). Instead, a more efficient; // memory-renaming optimization can be used.; //; // The PPX hint is purely a performance hint. Instructions with this hint have; // the same functional semantics as those without. PPX hints set by the; // compiler that violate the balancing rule may turn off the PPX optimization,; // but they will not affect program semantics.; //; // Hence, PPX is used for balanced spill/reloads (Exceptions and setjmp/longjmp; // are not considered).; //; // PUSH2 and POP2 are instructions for (respectively) pushing/popping 2; // GPRs at a time to/from the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:73,Performance,load,load,73,"// Rather than emit a long series of instructions for large offsets,; // load the offset into a register and do one sub/add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Performance,Load,Load,3,// Load new SP from the top of the stack into RSP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:55,Performance,optimiz,optimization,55,// Use push / pop for slot sized adjustments as a size optimization. We; // need to find a dead register when using pop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:277,Performance,optimiz,optimization,277,"// If we can use LEA for SP but we shouldn't, check that none; // of the terminators uses the eflags. Otherwise we will insert; // a ADD that will redefine the eflags and break the condition.; // Alternatively, we could move the ADD, but this may not be possible; // and is an optimization anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:11,Testability,assert,assert,11,"// If that assert breaks, that means we do not do the right thing; // in canUseAsEpilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:29,Usability,clear,clear,29,"// For GPRs, we only care to clear out the 32-bit register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:35,Integrability,depend,depending,35,"// Synthesize a loop or unroll it, depending on the number of iterations.; // BuildStackAlignAND ensures that only MaxAlign % StackProbeSize bits left; // between the unaligned rsp and current rsp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:114,Testability,log,logic,114,"// For the next N - 1 pages, just probe. I tried to take advantage of; // natural probes but it implies much more logic and there was very few; // interesting natural probes to interleave.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:49,Performance,optimiz,optimization,49,"// Use push for slot sized adjustments as a size optimization,; // like emitSPUpdate does when not probing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Performance,Perform,Perform,3,// Perform a first smaller allocation followed by a probe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Energy Efficiency,allocate,allocate,3,// allocate a page,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Deployability,Update,Update,3,// Update Live In information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:123,Deployability,update,updated,123,"// RAX contains the number of bytes of desired stack adjustment.; // The handling here assumes this value has already been updated so as to; // maintain stack alignment.; //; // We need to exit with RSP modified by this amount and execute suitable; // page touches to notify the OS that we're growing the stack responsibly.; // All stack probing must be done without modifying RSP.; //; // MBB:; // SizeReg = RAX;; // ZeroReg = 0; // CopyReg = RSP; // Flags, TestReg = CopyReg - SizeReg; // FinalReg = !Flags.Ovf ? TestReg : ZeroReg; // LimitReg = gs magic thread env access; // if FinalReg >= LimitReg goto ContinueMBB; // RoundBB:; // RoundReg = page address of FinalReg; // LoopMBB:; // LoopReg = PHI(LimitReg,ProbeReg); // ProbeReg = LoopReg - PageSize; // [ProbeReg] = 0; // if (ProbeReg > RoundReg) goto LoopMBB; // ContinueMBB:; // RSP = RSP - RAX; // [rest of original MBB]; // Set up the new basic blocks",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:568,Security,access,access,568,"// RAX contains the number of bytes of desired stack adjustment.; // The handling here assumes this value has already been updated so as to; // maintain stack alignment.; //; // We need to exit with RSP modified by this amount and execute suitable; // page touches to notify the OS that we're growing the stack responsibly.; // All stack probing must be done without modifying RSP.; //; // MBB:; // SizeReg = RAX;; // ZeroReg = 0; // CopyReg = RSP; // Flags, TestReg = CopyReg - SizeReg; // FinalReg = !Flags.Ovf ? TestReg : ZeroReg; // LimitReg = gs magic thread env access; // if FinalReg >= LimitReg goto ContinueMBB; // RoundBB:; // RoundReg = page address of FinalReg; // LoopMBB:; // LoopReg = PHI(LimitReg,ProbeReg); // ProbeReg = LoopReg - PageSize; // [ProbeReg] = 0; // if (ProbeReg > RoundReg) goto LoopMBB; // ContinueMBB:; // RSP = RSP - RAX; // [rest of original MBB]; // Set up the new basic blocks",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:459,Testability,Test,TestReg,459,"// RAX contains the number of bytes of desired stack adjustment.; // The handling here assumes this value has already been updated so as to; // maintain stack alignment.; //; // We need to exit with RSP modified by this amount and execute suitable; // page touches to notify the OS that we're growing the stack responsibly.; // All stack probing must be done without modifying RSP.; //; // MBB:; // SizeReg = RAX;; // ZeroReg = 0; // CopyReg = RSP; // Flags, TestReg = CopyReg - SizeReg; // FinalReg = !Flags.Ovf ? TestReg : ZeroReg; // LimitReg = gs magic thread env access; // if FinalReg >= LimitReg goto ContinueMBB; // RoundBB:; // RoundReg = page address of FinalReg; // LoopMBB:; // LoopReg = PHI(LimitReg,ProbeReg); // ProbeReg = LoopReg - PageSize; // [ProbeReg] = 0; // if (ProbeReg > RoundReg) goto LoopMBB; // ContinueMBB:; // RSP = RSP - RAX; // [rest of original MBB]; // Set up the new basic blocks",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:515,Testability,Test,TestReg,515,"// RAX contains the number of bytes of desired stack adjustment.; // The handling here assumes this value has already been updated so as to; // maintain stack alignment.; //; // We need to exit with RSP modified by this amount and execute suitable; // page touches to notify the OS that we're growing the stack responsibly.; // All stack probing must be done without modifying RSP.; //; // MBB:; // SizeReg = RAX;; // ZeroReg = 0; // CopyReg = RSP; // Flags, TestReg = CopyReg - SizeReg; // FinalReg = !Flags.Ovf ? TestReg : ZeroReg; // LimitReg = gs magic thread env access; // if FinalReg >= LimitReg goto ContinueMBB; // RoundBB:; // RoundReg = page address of FinalReg; // LoopMBB:; // LoopReg = PHI(LimitReg,ProbeReg); // ProbeReg = LoopReg - PageSize; // [ProbeReg] = 0; // if (ProbeReg > RoundReg) goto LoopMBB; // ContinueMBB:; // RSP = RSP - RAX; // [rest of original MBB]; // Set up the new basic blocks",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:39,Availability,down,down,39,// Split MBB and move the tail portion down to ContinueMBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:318,Performance,optimiz,optimization,318,"// FinalReg now holds final stack pointer value, or zero if; // allocation would overflow. Compare against the current stack; // limit from the thread environment block. Note this limit is the; // lowest touched page on the stack, not the point at which the OS; // will cause an overflow exception, so this is just an optimization; // to avoid unnecessarily touching pages that are below the current; // SP but already committed to the stack by the OS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:338,Safety,avoid,avoid,338,"// FinalReg now holds final stack pointer value, or zero if; // allocation would overflow. Compare against the current stack; // limit from the thread environment block. Note this limit is the; // lowest touched page on the stack, not the point at which the OS; // will cause an overflow exception, so this is just an optimization; // to avoid unnecessarily touching pages that are below the current; // SP but already committed to the stack by the OS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:60,Deployability,update,update,60,"// Now that the probing is done, add code to continueMBB to update; // the stack pointer for real.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:13,Modifiability,variab,variable,13,"// DebugInfo variable locations -- if there's an instruction number for the; // allocation (i.e., DYN_ALLOC_*), substitute it for the instruction that; // modifies SP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:856,Availability,MASK,MASK,856,"/// emitPrologue - Push callee-saved registers onto the stack, which; /// automatically adjust the stack pointer. Adjust the stack pointer to allocate; /// space for local variables. Also emit labels used by the exception handler to; /// generate the exception handling frames.; /*; Here's a gist of what gets emitted:. ; Establish frame pointer, if needed; [if needs FP]; push %rbp; .cfi_def_cfa_offset 16; .cfi_offset %rbp, -16; .seh_pushreg %rpb; mov %rsp, %rbp; .cfi_def_cfa_register %rbp. ; Spill general-purpose registers; [for all callee-saved GPRs]; pushq %<reg>; [if not needs FP]; .cfi_def_cfa_offset (offset from RETADDR); .seh_pushreg %<reg>. ; If the required stack alignment > default stack alignment; ; rsp needs to be re-aligned. This creates a ""re-alignment gap""; ; of unknown size in the stack frame.; [if stack needs re-alignment]; and $MASK, %rsp. ; Allocate space for locals; [if target is Windows and allocated space > 4096 bytes]; ; Windows needs special care for allocations larger; ; than one page.; mov $NNN, %rax; call ___chkstk_ms/___chkstk; sub %rax, %rsp; [else]; sub $NNN, %rsp. [if needs FP]; .seh_stackalloc (size of XMM spill slots); .seh_setframe %rbp, SEHFrameOffset ; = size of all spill slots; [else]; .seh_stackalloc NNN. ; Spill XMMs; ; Note, that while only Windows 64 ABI specifies XMMs as callee-preserved,; ; they may get spilled on any platform, if the current function; ; calls @llvm.eh.unwind.init; [if needs FP]; [for all callee-saved XMM registers]; movaps %<xmm reg>, -MMM(%rbp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, (-MMM + SEHFrameOffset); ; i.e. the offset relative to (%rbp - SEHFrameOffset); [else]; [for all callee-saved XMM registers]; movaps %<xmm reg>, KKK(%rsp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, KKK. .seh_endprologue. [if needs base pointer]; mov %rsp, %rbx; [if needs to restore base pointer]; mov %rsp, -MMM(%rbp). ; Emit CFI info; [if needs FP]; [for all callee-saved registers]; .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:142,Energy Efficiency,allocate,allocate,142,"/// emitPrologue - Push callee-saved registers onto the stack, which; /// automatically adjust the stack pointer. Adjust the stack pointer to allocate; /// space for local variables. Also emit labels used by the exception handler to; /// generate the exception handling frames.; /*; Here's a gist of what gets emitted:. ; Establish frame pointer, if needed; [if needs FP]; push %rbp; .cfi_def_cfa_offset 16; .cfi_offset %rbp, -16; .seh_pushreg %rpb; mov %rsp, %rbp; .cfi_def_cfa_register %rbp. ; Spill general-purpose registers; [for all callee-saved GPRs]; pushq %<reg>; [if not needs FP]; .cfi_def_cfa_offset (offset from RETADDR); .seh_pushreg %<reg>. ; If the required stack alignment > default stack alignment; ; rsp needs to be re-aligned. This creates a ""re-alignment gap""; ; of unknown size in the stack frame.; [if stack needs re-alignment]; and $MASK, %rsp. ; Allocate space for locals; [if target is Windows and allocated space > 4096 bytes]; ; Windows needs special care for allocations larger; ; than one page.; mov $NNN, %rax; call ___chkstk_ms/___chkstk; sub %rax, %rsp; [else]; sub $NNN, %rsp. [if needs FP]; .seh_stackalloc (size of XMM spill slots); .seh_setframe %rbp, SEHFrameOffset ; = size of all spill slots; [else]; .seh_stackalloc NNN. ; Spill XMMs; ; Note, that while only Windows 64 ABI specifies XMMs as callee-preserved,; ; they may get spilled on any platform, if the current function; ; calls @llvm.eh.unwind.init; [if needs FP]; [for all callee-saved XMM registers]; movaps %<xmm reg>, -MMM(%rbp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, (-MMM + SEHFrameOffset); ; i.e. the offset relative to (%rbp - SEHFrameOffset); [else]; [for all callee-saved XMM registers]; movaps %<xmm reg>, KKK(%rsp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, KKK. .seh_endprologue. [if needs base pointer]; mov %rsp, %rbx; [if needs to restore base pointer]; mov %rsp, -MMM(%rbp). ; Emit CFI info; [if needs FP]; [for all callee-saved registers]; .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:870,Energy Efficiency,Allocate,Allocate,870,"/// emitPrologue - Push callee-saved registers onto the stack, which; /// automatically adjust the stack pointer. Adjust the stack pointer to allocate; /// space for local variables. Also emit labels used by the exception handler to; /// generate the exception handling frames.; /*; Here's a gist of what gets emitted:. ; Establish frame pointer, if needed; [if needs FP]; push %rbp; .cfi_def_cfa_offset 16; .cfi_offset %rbp, -16; .seh_pushreg %rpb; mov %rsp, %rbp; .cfi_def_cfa_register %rbp. ; Spill general-purpose registers; [for all callee-saved GPRs]; pushq %<reg>; [if not needs FP]; .cfi_def_cfa_offset (offset from RETADDR); .seh_pushreg %<reg>. ; If the required stack alignment > default stack alignment; ; rsp needs to be re-aligned. This creates a ""re-alignment gap""; ; of unknown size in the stack frame.; [if stack needs re-alignment]; and $MASK, %rsp. ; Allocate space for locals; [if target is Windows and allocated space > 4096 bytes]; ; Windows needs special care for allocations larger; ; than one page.; mov $NNN, %rax; call ___chkstk_ms/___chkstk; sub %rax, %rsp; [else]; sub $NNN, %rsp. [if needs FP]; .seh_stackalloc (size of XMM spill slots); .seh_setframe %rbp, SEHFrameOffset ; = size of all spill slots; [else]; .seh_stackalloc NNN. ; Spill XMMs; ; Note, that while only Windows 64 ABI specifies XMMs as callee-preserved,; ; they may get spilled on any platform, if the current function; ; calls @llvm.eh.unwind.init; [if needs FP]; [for all callee-saved XMM registers]; movaps %<xmm reg>, -MMM(%rbp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, (-MMM + SEHFrameOffset); ; i.e. the offset relative to (%rbp - SEHFrameOffset); [else]; [for all callee-saved XMM registers]; movaps %<xmm reg>, KKK(%rsp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, KKK. .seh_endprologue. [if needs base pointer]; mov %rsp, %rbx; [if needs to restore base pointer]; mov %rsp, -MMM(%rbp). ; Emit CFI info; [if needs FP]; [for all callee-saved registers]; .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:923,Energy Efficiency,allocate,allocated,923,"/// emitPrologue - Push callee-saved registers onto the stack, which; /// automatically adjust the stack pointer. Adjust the stack pointer to allocate; /// space for local variables. Also emit labels used by the exception handler to; /// generate the exception handling frames.; /*; Here's a gist of what gets emitted:. ; Establish frame pointer, if needed; [if needs FP]; push %rbp; .cfi_def_cfa_offset 16; .cfi_offset %rbp, -16; .seh_pushreg %rpb; mov %rsp, %rbp; .cfi_def_cfa_register %rbp. ; Spill general-purpose registers; [for all callee-saved GPRs]; pushq %<reg>; [if not needs FP]; .cfi_def_cfa_offset (offset from RETADDR); .seh_pushreg %<reg>. ; If the required stack alignment > default stack alignment; ; rsp needs to be re-aligned. This creates a ""re-alignment gap""; ; of unknown size in the stack frame.; [if stack needs re-alignment]; and $MASK, %rsp. ; Allocate space for locals; [if target is Windows and allocated space > 4096 bytes]; ; Windows needs special care for allocations larger; ; than one page.; mov $NNN, %rax; call ___chkstk_ms/___chkstk; sub %rax, %rsp; [else]; sub $NNN, %rsp. [if needs FP]; .seh_stackalloc (size of XMM spill slots); .seh_setframe %rbp, SEHFrameOffset ; = size of all spill slots; [else]; .seh_stackalloc NNN. ; Spill XMMs; ; Note, that while only Windows 64 ABI specifies XMMs as callee-preserved,; ; they may get spilled on any platform, if the current function; ; calls @llvm.eh.unwind.init; [if needs FP]; [for all callee-saved XMM registers]; movaps %<xmm reg>, -MMM(%rbp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, (-MMM + SEHFrameOffset); ; i.e. the offset relative to (%rbp - SEHFrameOffset); [else]; [for all callee-saved XMM registers]; movaps %<xmm reg>, KKK(%rsp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, KKK. .seh_endprologue. [if needs base pointer]; mov %rsp, %rbx; [if needs to restore base pointer]; mov %rsp, -MMM(%rbp). ; Emit CFI info; [if needs FP]; [for all callee-saved registers]; .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:172,Modifiability,variab,variables,172,"/// emitPrologue - Push callee-saved registers onto the stack, which; /// automatically adjust the stack pointer. Adjust the stack pointer to allocate; /// space for local variables. Also emit labels used by the exception handler to; /// generate the exception handling frames.; /*; Here's a gist of what gets emitted:. ; Establish frame pointer, if needed; [if needs FP]; push %rbp; .cfi_def_cfa_offset 16; .cfi_offset %rbp, -16; .seh_pushreg %rpb; mov %rsp, %rbp; .cfi_def_cfa_register %rbp. ; Spill general-purpose registers; [for all callee-saved GPRs]; pushq %<reg>; [if not needs FP]; .cfi_def_cfa_offset (offset from RETADDR); .seh_pushreg %<reg>. ; If the required stack alignment > default stack alignment; ; rsp needs to be re-aligned. This creates a ""re-alignment gap""; ; of unknown size in the stack frame.; [if stack needs re-alignment]; and $MASK, %rsp. ; Allocate space for locals; [if target is Windows and allocated space > 4096 bytes]; ; Windows needs special care for allocations larger; ; than one page.; mov $NNN, %rax; call ___chkstk_ms/___chkstk; sub %rax, %rsp; [else]; sub $NNN, %rsp. [if needs FP]; .seh_stackalloc (size of XMM spill slots); .seh_setframe %rbp, SEHFrameOffset ; = size of all spill slots; [else]; .seh_stackalloc NNN. ; Spill XMMs; ; Note, that while only Windows 64 ABI specifies XMMs as callee-preserved,; ; they may get spilled on any platform, if the current function; ; calls @llvm.eh.unwind.init; [if needs FP]; [for all callee-saved XMM registers]; movaps %<xmm reg>, -MMM(%rbp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, (-MMM + SEHFrameOffset); ; i.e. the offset relative to (%rbp - SEHFrameOffset); [else]; [for all callee-saved XMM registers]; movaps %<xmm reg>, KKK(%rsp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, KKK. .seh_endprologue. [if needs base pointer]; mov %rsp, %rbx; [if needs to restore base pointer]; mov %rsp, -MMM(%rbp). ; Emit CFI info; [if needs FP]; [for all callee-saved registers]; .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:22,Energy Efficiency,allocate,allocate,22,// Number of bytes to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:91,Availability,error,error,91,"// Re-align the stack on 64-bit if the x86-interrupt calling convention is; // used and an error code was pushed, since the x86-64 ABI requires a 16-byte; // stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Deployability,Update,Update,3,// Update the stack pointer by pushing a register. This is the instruction; // emitted that would be end up being emitted by a call to `emitSPUpdate`.; // Hard-coding the update to a push avoids emitting a second; // `STACKALLOC_W_PROBING` instruction in the save block: We know that stack; // probing isn't needed anyways for an 8-byte update.; // Pushing a register leaves us in a similar situation to a regular; // function call where we know that the address at (rsp-8) is writeable.; // That way we avoid any off-by-ones with stack probing for additional; // stack pointer updates later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:171,Deployability,update,update,171,// Update the stack pointer by pushing a register. This is the instruction; // emitted that would be end up being emitted by a call to `emitSPUpdate`.; // Hard-coding the update to a push avoids emitting a second; // `STACKALLOC_W_PROBING` instruction in the save block: We know that stack; // probing isn't needed anyways for an 8-byte update.; // Pushing a register leaves us in a similar situation to a regular; // function call where we know that the address at (rsp-8) is writeable.; // That way we avoid any off-by-ones with stack probing for additional; // stack pointer updates later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:337,Deployability,update,update,337,// Update the stack pointer by pushing a register. This is the instruction; // emitted that would be end up being emitted by a call to `emitSPUpdate`.; // Hard-coding the update to a push avoids emitting a second; // `STACKALLOC_W_PROBING` instruction in the save block: We know that stack; // probing isn't needed anyways for an 8-byte update.; // Pushing a register leaves us in a similar situation to a regular; // function call where we know that the address at (rsp-8) is writeable.; // That way we avoid any off-by-ones with stack probing for additional; // stack pointer updates later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:578,Deployability,update,updates,578,// Update the stack pointer by pushing a register. This is the instruction; // emitted that would be end up being emitted by a call to `emitSPUpdate`.; // Hard-coding the update to a push avoids emitting a second; // `STACKALLOC_W_PROBING` instruction in the save block: We know that stack; // probing isn't needed anyways for an 8-byte update.; // Pushing a register leaves us in a similar situation to a regular; // function call where we know that the address at (rsp-8) is writeable.; // That way we avoid any off-by-ones with stack probing for additional; // stack pointer updates later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:188,Safety,avoid,avoids,188,// Update the stack pointer by pushing a register. This is the instruction; // emitted that would be end up being emitted by a call to `emitSPUpdate`.; // Hard-coding the update to a push avoids emitting a second; // `STACKALLOC_W_PROBING` instruction in the save block: We know that stack; // probing isn't needed anyways for an 8-byte update.; // Pushing a register leaves us in a similar situation to a regular; // function call where we know that the address at (rsp-8) is writeable.; // That way we avoid any off-by-ones with stack probing for additional; // stack pointer updates later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:504,Safety,avoid,avoid,504,// Update the stack pointer by pushing a register. This is the instruction; // emitted that would be end up being emitted by a call to `emitSPUpdate`.; // Hard-coding the update to a push avoids emitting a second; // `STACKALLOC_W_PROBING` instruction in the save block: We know that stack; // probing isn't needed anyways for an 8-byte update.; // Pushing a register leaves us in a similar situation to a regular; // function call where we know that the address at (rsp-8) is writeable.; // That way we avoid any off-by-ones with stack probing for additional; // stack pointer updates later on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:98,Performance,optimiz,optimized,98,// Insert stack pointer adjustment for later moving of return addr. Only; // applies to tail call optimized functions where the callee argument stack; // size is bigger than the callers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:13,Deployability,update,update,13,"// Before we update the live frame pointer we have to ensure there's a; // valid (or null) asynchronous context in its slot just before FP in; // the frame record, so store it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Deployability,Update,Update,3,// Update EBP with the new base value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Deployability,Update,Update,3,"// Update the offset adjustment, which is mainly used by codeview to translate; // from ESP to VFRAME relative local variable offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:117,Modifiability,variab,variable,117,"// Update the offset adjustment, which is mainly used by codeview to translate; // from ESP to VFRAME relative local variable offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:25,Energy Efficiency,allocate,allocate,25,"// For EH funclets, only allocate enough space for outgoing calls. Save the; // NumBytes value that we would've used for the parent frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:605,Energy Efficiency,allocate,allocated,605,// Adjust stack pointer: ESP -= numbytes.; // Windows and cygwin/mingw require a prologue helper routine when allocating; // more than 4K bytes on the stack. Windows uses __chkstk and cygwin/mingw; // uses __alloca. __alloca and the 32-bit version of __chkstk will probe the; // stack and adjust the stack pointer in one go. The 64-bit version of; // __chkstk is only responsible for probing the stack. The 64-bit prologue is; // responsible for adjusting the stack pointer. Touching the stack at 4K; // increments is necessary to ensure that the guard pages used by the OS; // virtual memory manager are allocated in correct sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:97,Integrability,rout,routine,97,// Adjust stack pointer: ESP -= numbytes.; // Windows and cygwin/mingw require a prologue helper routine when allocating; // more than 4K bytes on the stack. Windows uses __chkstk and cygwin/mingw; // uses __alloca. __alloca and the 32-bit version of __chkstk will probe the; // stack and adjust the stack pointer in one go. The 64-bit version of; // __chkstk is only responsible for probing the stack. The 64-bit prologue is; // responsible for adjusting the stack pointer. Touching the stack at 4K; // increments is necessary to ensure that the guard pages used by the OS; // virtual memory manager are allocated in correct sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate NumBytes-4 bytes on stack in case of isEAXAlive.; // We'll also use 4 already allocated bytes for EAX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:90,Energy Efficiency,allocate,allocated,90,// Allocate NumBytes-4 bytes on stack in case of isEAXAlive.; // We'll also use 4 already allocated bytes for EAX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:200,Performance,load,loading,200,// The establisher parameter passed to a CLR funclet is actually a pointer; // to the (mostly empty) frame of its nearest enclosing funclet; we have; // to find the root function establisher frame by loading the PSPSym from; // the intermediate frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:157,Availability,recover,recover,157,// Save the so-called Initial-SP (i.e. the value of the stack pointer; // immediately after the prolog) into the PSPSlot so that funclets; // and the GC can recover it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:157,Safety,recover,recover,157,// Save the so-called Initial-SP (i.e. the value of the stack pointer; // immediately after the prolog) into the PSPSlot so that funclets; // and the GC can recover it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:151,Energy Efficiency,allocate,allocated,151,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:117,Modifiability,variab,variable,117,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Deployability,Update,Update,3,// Update the base pointer with the current stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:71,Integrability,depend,dependence,71,// Stash value of base pointer. Saving RSP instead of EBP shortens; // dependence chain. Used by SjLj EH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:155,Availability,recover,recovers,155,"// Stash the value of the frame pointer relative to the base pointer for; // Win32 EH. This supports Win32 EH, which does the inverse of the above:; // it recovers the frame pointer from the base pointer rather than the; // other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:155,Safety,recover,recovers,155,"// Stash the value of the frame pointer relative to the base pointer for; // Win32 EH. This supports Win32 EH, which does the inverse of the above:; // it recovers the frame pointer from the base pointer rather than the; // other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:112,Usability,Clear,Clear,112,"// X86 Interrupt handling function cannot assume anything about the direction; // flag (DF in EFLAGS register). Clear this flag by creating ""cld"" instruction; // in each prologue of interrupt handler function.; //; // FIXME: Create ""cld"" instruction only in these cases:; // 1. The interrupt handling function uses any of the ""rep"" instructions.; // 2. Interrupt handling function calls another function.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:335,Security,access,access,335,"// CLR funclets use a special ""Previous Stack Pointer Symbol"" slot on the; // stack. It holds a pointer to the bottom of the root function frame. The; // establisher frame pointer passed to a nested funclet may point to the; // (mostly empty) frame of its parent funclet, but it will need to find; // the frame of the root function to access locals. To facilitate this,; // every funclet copies the pointer to the bottom of the root function; // frame into a PSPSym slot in its own (mostly empty) stack frame. Using the; // same offset for the PSPSym in the root function frame that's used in the; // funclets' frames allows each funclet to dynamically accept any ancestor; // frame as its establisher argument (the runtime doesn't guarantee the; // immediate parent for some reason lost to history), and also allows the GC,; // which uses the PSPSym for some bookkeeping, to find it in any funclet's; // frame with only a single offset reported for the entire method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:50,Energy Efficiency,allocate,allocate,50,// This is the amount of stack a funclet needs to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:127,Energy Efficiency,allocate,allocate,127,"// RBP is not included in the callee saved register block. After pushing RBP,; // everything is 16 byte aligned. Everything we allocate before an outgoing; // call must also be 16 byte aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:101,Energy Efficiency,allocate,allocate,101,// Subtract out the size of the callee saved registers. This is how much stack; // each funclet will allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:112,Modifiability,extend,extended,112,// We need to reset FP to its untagged state on return. Bit 60 is currently; // used to show the presence of an extended frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:313,Safety,safe,safely,313,"// There are only two legal forms of epilogue:; // - add SEHAllocationSize, %rsp; // - lea SEHAllocationSize(%FramePtr), %rsp; //; // 'mov %FramePtr, %rsp' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:323,Usability,undo,undone,323,"// There are only two legal forms of epilogue:; // - add SEHAllocationSize, %rsp; // - lea SEHAllocationSize(%FramePtr), %rsp; //; // 'mov %FramePtr, %rsp' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:205,Integrability,depend,depending,205,"// Offset will hold the offset from the stack pointer at function entry to the; // object.; // We need to factor in additional offsets applied during the prologue to the; // frame, base, and stack pointer depending on which is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:111,Energy Efficiency,allocate,allocated,111,"// In an x86 interrupt, remove the offset we added to account for the return; // address from any stack object allocated in the caller's frame. Interrupts; // do not have a standard return address. Fixed objects in the current frame,; // such as SSE register spills, should not get this treatment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:961,Modifiability,variab,variables,961,"// LLVM arranges the stack as follows:; // ...; // ARG2; // ARG1; // RETADDR; // PUSH RBP <-- RBP points here; // PUSH CSRs; // ~~~~~~~ <-- possible stack realignment (non-win64); // ...; // STACK OBJECTS; // ... <-- RSP after prologue points here; // ~~~~~~~ <-- possible stack realignment (win64); //; // if (hasVarSizedObjects()):; // ... <-- ""base pointer"" (ESI/RBX) points here; // DYNAMIC ALLOCAS; // ... <-- RSP points here; //; // Case 1: In the simple case of no stack realignment and no dynamic; // allocas, both ""fixed"" stack objects (arguments and CSRs) are addressable; // with fixed offsets from RSP.; //; // Case 2: In the case of stack realignment with no dynamic allocas, fixed; // stack objects are addressed with RBP and regular stack objects with RSP.; //; // Case 3: In the case of dynamic allocas and stack realignment, RSP is used; // to address stack arguments for outgoing calls and nothing else. The ""base; // pointer"" points to local variables, and RBP points to fixed objects.; //; // In cases 2 and 3, we can only answer for non-fixed stack objects, and the; // answer we give is relative to the SP after the prologue, and not the; // SP in the middle of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:454,Usability,simpl,simple,454,"// LLVM arranges the stack as follows:; // ...; // ARG2; // ARG1; // RETADDR; // PUSH RBP <-- RBP points here; // PUSH CSRs; // ~~~~~~~ <-- possible stack realignment (non-win64); // ...; // STACK OBJECTS; // ... <-- RSP after prologue points here; // ~~~~~~~ <-- possible stack realignment (win64); //; // if (hasVarSizedObjects()):; // ... <-- ""base pointer"" (ESI/RBX) points here; // DYNAMIC ALLOCAS; // ... <-- RSP points here; //; // Case 1: In the simple case of no stack realignment and no dynamic; // allocas, both ""fixed"" stack objects (arguments and CSRs) are addressable; // with fixed offsets from RSP.; //; // Case 2: In the case of stack realignment with no dynamic allocas, fixed; // stack objects are addressed with RBP and regular stack objects with RSP.; //; // Case 3: In the case of dynamic allocas and stack realignment, RSP is used; // to address stack arguments for outgoing calls and nothing else. The ""base; // pointer"" points to local variables, and RBP points to fixed objects.; //; // In cases 2 and 3, we can only answer for non-fixed stack objects, and the; // answer we give is relative to the SP after the prologue, and not the; // SP in the middle of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:135,Integrability,depend,depends,135,"// If !hasReservedCallFrame the function might have SP adjustement in the; // body. So, even though the offset is statically known, it depends on where; // we are in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:587,Availability,down,down,587,"// This is how the math works out:; //; // %rsp grows (i.e. gets lower) left to right. Each box below is; // one word (eight bytes). Obj0 is the stack slot we're trying to; // get to.; //; // ----------------------------------; // | BP | Obj0 | Obj1 | ... | ObjN |; // ----------------------------------; // ^ ^ ^ ^; // A B C E; //; // A is the incoming stack pointer.; // (B - A) is the local area offset (-8 for x86-64) [1]; // (C - A) is the Offset returned by MFI.getObjectOffset for Obj0 [2]; //; // |(E - B)| is the StackSize (absolute value, positive). For a; // stack that grown down, this works out to be (B - E). [3]; //; // E is also the value of %rsp after stack has been set up, and we; // want (C - E) -- the value we can add to %rsp to get to Obj0. Now; // (C - E) == (C - A) - (B - A) + (B - E); // { Using [1], [2] and [3] above }; // == getObjectOffset - LocalAreaOffset + StackSize",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a spill slot for EBP if we have a base pointer and EH funclets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:73,Energy Efficiency,allocate,allocate,73,"// The async context lives directly before the frame pointer, and we; // allocate a second slot to preserve stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:164,Safety,avoid,avoiding,164,"// Since emitPrologue and emitEpilogue will handle spilling and restoring of; // the frame register, we can delete it from CSI list and not have to worry; // about avoiding it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Deployability,Update,Update,3,// Update LiveIn of the basic block and decide whether we can add a kill flag; // to the use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Usability,Clear,Clear,3,// Clear the stack slot for spill base pointer register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:129,Integrability,Depend,Depending,129,"/// GetScratchRegister - Get a temp register for performing work in the; /// segmented stack and the Erlang/HiPE stack prologue. Depending on platform; /// and the properties of the function either one or two registers will be; /// needed. Set primary to true for the first register, false for the second.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:49,Performance,perform,performing,49,"/// GetScratchRegister - Get a temp register for performing work in the; /// segmented stack and the Erlang/HiPE stack prologue. Depending on platform; /// and the properties of the function either one or two registers will be; /// needed. Set primary to true for the first register, false for the second.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:96,Deployability,update,update,96,// To support shrink-wrapping we would need to insert the new blocks; // at the right place and update the branches to PrologueMBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:21,Integrability,wrap,wrapping,21,// To support shrink-wrapping we would need to insert the new blocks; // at the right place and update the branches to PrologueMBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:125,Integrability,inject,injected,125,// Eventually StackSize will be calculated by a link-time pass; which will; // also decide whether checking code needs to be injected into this particular; // prologue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:125,Security,inject,injected,125,// Eventually StackSize will be calculated by a link-time pass; which will; // also decide whether checking code needs to be injected into this particular; // prologue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:35,Availability,avail,available,35,// The primary scratch register is available for holding the TLS offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:814,Availability,error,error,814,"// Under the large code model, we cannot assume that __morestack lives; // within 2^31 bytes of the call site, so we cannot use pc-relative; // addressing. We cannot perform the call via a temporary register,; // as the rax register may be used to store the static chain, and all; // other suitable registers may be either callee-save or used for; // parameter passing. We cannot use the stack at this point either; // because __morestack manipulates the stack directly.; //; // To avoid these issues, perform an indirect call via a read-only memory; // location containing the address.; //; // This solution is not perfect, as it assumes that the .rodata section; // is laid out within 2^31 bytes of each function body, but this seems; // to be sufficient for JIT.; // FIXME: Add retpoline support and remove the error here..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:166,Performance,perform,perform,166,"// Under the large code model, we cannot assume that __morestack lives; // within 2^31 bytes of the call site, so we cannot use pc-relative; // addressing. We cannot perform the call via a temporary register,; // as the rax register may be used to store the static chain, and all; // other suitable registers may be either callee-save or used for; // parameter passing. We cannot use the stack at this point either; // because __morestack manipulates the stack directly.; //; // To avoid these issues, perform an indirect call via a read-only memory; // location containing the address.; //; // This solution is not perfect, as it assumes that the .rodata section; // is laid out within 2^31 bytes of each function body, but this seems; // to be sufficient for JIT.; // FIXME: Add retpoline support and remove the error here..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:502,Performance,perform,perform,502,"// Under the large code model, we cannot assume that __morestack lives; // within 2^31 bytes of the call site, so we cannot use pc-relative; // addressing. We cannot perform the call via a temporary register,; // as the rax register may be used to store the static chain, and all; // other suitable registers may be either callee-save or used for; // parameter passing. We cannot use the stack at this point either; // because __morestack manipulates the stack directly.; //; // To avoid these issues, perform an indirect call via a read-only memory; // location containing the address.; //; // This solution is not perfect, as it assumes that the .rodata section; // is laid out within 2^31 bytes of each function body, but this seems; // to be sufficient for JIT.; // FIXME: Add retpoline support and remove the error here..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:482,Safety,avoid,avoid,482,"// Under the large code model, we cannot assume that __morestack lives; // within 2^31 bytes of the call site, so we cannot use pc-relative; // addressing. We cannot perform the call via a temporary register,; // as the rax register may be used to store the static chain, and all; // other suitable registers may be either callee-save or used for; // parameter passing. We cannot use the stack at this point either; // because __morestack manipulates the stack directly.; //; // To avoid these issues, perform an indirect call via a read-only memory; // location containing the address.; //; // This solution is not perfect, as it assumes that the .rodata section; // is laid out within 2^31 bytes of each function body, but this seems; // to be sufficient for JIT.; // FIXME: Add retpoline support and remove the error here..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:96,Deployability,update,update,96,// To support shrink-wrapping we would need to insert the new blocks; // at the right place and update the branches to PrologueMBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:21,Integrability,wrap,wrapping,21,// To support shrink-wrapping we would need to insert the new blocks; // at the right place and update the branches to PrologueMBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:306,Availability,avail,available,306,"// Compute the largest caller's frame that is needed to fit the callees'; // frames. This 'MaxStack' is computed from:; //; // a) the fixed frame size, which is the space needed for all spilled temps,; // b) outgoing on-stack parameter areas, and; // c) the minimum stack space this function needs to make available for the; // functions it calls (a tunable ABI property).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:10,Deployability,update,update,10,"// Do not update 'MaxStack' for primitive and built-in functions; // (encoded with names either starting with ""erlang.""/""bif_"" or not; // having a ""."", such as a simple <Module>.<Function>.<Arity>, or an; // ""_"", such as the BIF ""suspend_0"") as they are executed on another; // stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:162,Usability,simpl,simple,162,"// Do not update 'MaxStack' for primitive and built-in functions; // (encoded with names either starting with ""erlang.""/""bif_"" or not; // having a ""."", such as a simple <Module>.<Function>.<Arity>, or an; // ""_"", such as the BIF ""suspend_0"") as they are executed on another; // stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:10,Safety,avoid,avoid,10,"// Try to avoid emitting dead SP adjustments if the block end is unreachable,; // typically because the function is marked noreturn (abort, throw,; // assert_fail, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:133,Safety,abort,abort,133,"// Try to avoid emitting dead SP adjustments if the block end is unreachable,; // typically because the function is marked noreturn (abort, throw,; // assert_fail, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:173,Integrability,depend,depends,173,"// If we don't have FP, but need to generate unwind information,; // we need to set the correct CFA offset after the stack adjustment.; // How much we adjust the CFA offset depends on whether we're emitting; // CFI only for EH purposes or for debugging. EH only requires the CFA; // offset to be correct at each call site, while for debugging we want; // it to be more precise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:188,Safety,safe,safe,188,"// If we cannot use LEA to adjust SP, we may need to use ADD, which; // clobbers the EFLAGS. Check that we do not need to preserve it,; // otherwise, conservatively assume this is not; // safe to insert the epilogue here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:539,Energy Efficiency,allocate,allocated,539,"// The comparison function we use for std::sort to order our local; // stack symbols. The current algorithm is to use an estimated; // ""density"". This takes into consideration the size and number of; // uses each object has in order to roughly minimize code size.; // So, for example, an object of size 16B that is referenced 5 times; // will get higher priority than 4 4B objects referenced 1 time each.; // It's not perfect and we may be able to squeeze a few more bytes out of; // it (for example : 0(esp) requires fewer bytes, symbols allocated at the; // fringe end can have special consideration, given their size is less; // important, etc.), but the algorithmic complexity grows too much to be; // worth the extra gains we get. This gets us pretty close.; // The final order leaves us with objects with highest priority going; // at the end of our list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:246,Integrability,depend,depending,246,"// The density is calculated by doing :; // (double)DensityA = A.ObjectNumUses / A.ObjectSize; // (double)DensityB = B.ObjectNumUses / B.ObjectSize; // Since this approach may cause inconsistencies in; // the floating point <, >, == comparisons, depending on the floating; // point model with which the compiler was built, we're going; // to scale both sides by multiplying with; // A.ObjectSize * B.ObjectSize. This ends up factoring away; // the division and, with it, the need for any floating point; // arithmetic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:189,Availability,down,down,189,"// Create an array of all MFI objects. We won't need all of these; // objects, but we're going to create a full array of them to make; // it easier to index into when we're counting ""uses"" down below.; // We want to be able to easily/cheaply access an object by simply; // indexing into it, instead of having to search for it every time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:242,Security,access,access,242,"// Create an array of all MFI objects. We won't need all of these; // objects, but we're going to create a full array of them to make; // it easier to index into when we're counting ""uses"" down below.; // We want to be able to easily/cheaply access an object by simply; // indexing into it, instead of having to search for it every time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:262,Usability,simpl,simply,262,"// Create an array of all MFI objects. We won't need all of these; // objects, but we're going to create a full array of them to make; // it easier to index into when we're counting ""uses"" down below.; // We want to be able to easily/cheaply access an object by simply; // indexing into it, instead of having to search for it every time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,Modifiability,Variab,Variable,3,// Variable size. Just use 4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:94,Integrability,depend,depend,94,"// Now modify the original list to represent the final order that; // we want. The order will depend on whether we're going to access them; // from the stack pointer or the frame pointer. For SP, the list should; // end up with the END containing objects that we want with smaller offsets.; // For FP, it should be flipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:127,Security,access,access,127,"// Now modify the original list to represent the final order that; // we want. The order will depend on whether we're going to access them; // from the stack pointer or the frame pointer. For SP, the list should; // end up with the END containing objects that we want with smaller offsets.; // For FP, it should be flipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:52,Safety,safe,safe,52,"// All invalid items are sorted at the end, so it's safe to stop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:20,Security,access,accessing,20,// Flip it if we're accessing off of the FP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:17,Energy Efficiency,allocate,allocates,17,// Every funclet allocates enough stack space for the largest outgoing call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:25,Energy Efficiency,allocate,allocate,25,"// Win64 C++ EH needs to allocate the UnwindHelp object at some fixed offset; // relative to RSP after the prologue. Find the offset of the last fixed; // object, so that we can allocate a slot immediately following it. If there; // were no fixed objects, use offset -SlotSize, which is immediately after the; // return address. Fixed objects have negative frame indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:178,Energy Efficiency,allocate,allocate,178,"// Win64 C++ EH needs to allocate the UnwindHelp object at some fixed offset; // relative to RSP after the prologue. Find the offset of the last fixed; // object, so that we can allocate a slot immediately following it. If there; // were no fixed objects, use offset -SlotSize, which is immediately after the; // return address. Fixed objects have negative frame indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:3,Performance,Cache,Cached,3,// Cached subtarget predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:49,Availability,avail,available,49,/// Is64Bit implies that x86_64 instructions are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:32,Testability,stub,stub,32,/// Replace a StackProbe inline-stub with the actual probe code inline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:190,Integrability,wrap,wrapping,190,"/// Check whether or not the given \p MBB can be used as a prologue; /// for the target.; /// The prologue will be inserted first in this basic block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:311,Integrability,wrap,wrapping,311,"/// Check whether or not the given \p MBB can be used as a prologue; /// for the target.; /// The prologue will be inserted first in this basic block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:206,Integrability,wrap,wrapping,206,/// Check whether or not the given \p MBB can be used as a epilogue; /// for the target.; /// The epilogue will be inserted before the first terminator of that block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:60,Integrability,wrap,wrapping,60,/// Returns true if the target will correctly handle shrink wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:4,Integrability,Wrap,Wraps,4,/// Wraps up getting a CFI index and building a MachineInstr for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:47,Security,access,accessible,47,/// Return true if the function has a redzone (accessible bytes past the; /// frame of the top of stack function) as part of it's ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectBranchTracking.cpp:159,Integrability,depend,depending,159,"/// Adds a new ENDBR instruction to the beginning of the MBB.; /// The function will not add it if already exists.; /// It will add ENDBR32 or ENDBR64 opcode, depending on the target.; /// \returns true if the ENDBR was added and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectBranchTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectBranchTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:1068,Deployability,pipeline,pipeline,1068,"//==- X86IndirectThunks.cpp - Construct indirect call/jump thunks for x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Pass that injects an MI thunk that is used to lower indirect calls in a way; /// that prevents speculation on some x86 processors and can be used to mitigate; /// security vulnerabilities due to targeted speculative execution and side; /// channels such as CVE-2017-5715.; ///; /// Currently supported thunks include:; /// - Retpoline -- A RET-implemented trampoline that lowers indirect calls; /// - LVI Thunk -- A CALL/JMP-implemented thunk that forces load serialization; /// before making an indirect call/jump; ///; /// Note that the reason that this is implemented as a MachineFunctionPass and; /// not a ModulePass is that ModulePasses at this point in the LLVM X86 pipeline; /// serialize all transformations, which can consume lots of memory.; ///; /// TODO(chandlerc): All of this code could use better comments and; /// documentation.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:405,Integrability,inject,injects,405,"//==- X86IndirectThunks.cpp - Construct indirect call/jump thunks for x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Pass that injects an MI thunk that is used to lower indirect calls in a way; /// that prevents speculation on some x86 processors and can be used to mitigate; /// security vulnerabilities due to targeted speculative execution and side; /// channels such as CVE-2017-5715.; ///; /// Currently supported thunks include:; /// - Retpoline -- A RET-implemented trampoline that lowers indirect calls; /// - LVI Thunk -- A CALL/JMP-implemented thunk that forces load serialization; /// before making an indirect call/jump; ///; /// Note that the reason that this is implemented as a MachineFunctionPass and; /// not a ModulePass is that ModulePasses at this point in the LLVM X86 pipeline; /// serialize all transformations, which can consume lots of memory.; ///; /// TODO(chandlerc): All of this code could use better comments and; /// documentation.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:850,Performance,load,load,850,"//==- X86IndirectThunks.cpp - Construct indirect call/jump thunks for x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Pass that injects an MI thunk that is used to lower indirect calls in a way; /// that prevents speculation on some x86 processors and can be used to mitigate; /// security vulnerabilities due to targeted speculative execution and side; /// channels such as CVE-2017-5715.; ///; /// Currently supported thunks include:; /// - Retpoline -- A RET-implemented trampoline that lowers indirect calls; /// - LVI Thunk -- A CALL/JMP-implemented thunk that forces load serialization; /// before making an indirect call/jump; ///; /// Note that the reason that this is implemented as a MachineFunctionPass and; /// not a ModulePass is that ModulePasses at this point in the LLVM X86 pipeline; /// serialize all transformations, which can consume lots of memory.; ///; /// TODO(chandlerc): All of this code could use better comments and; /// documentation.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:405,Security,inject,injects,405,"//==- X86IndirectThunks.cpp - Construct indirect call/jump thunks for x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Pass that injects an MI thunk that is used to lower indirect calls in a way; /// that prevents speculation on some x86 processors and can be used to mitigate; /// security vulnerabilities due to targeted speculative execution and side; /// channels such as CVE-2017-5715.; ///; /// Currently supported thunks include:; /// - Retpoline -- A RET-implemented trampoline that lowers indirect calls; /// - LVI Thunk -- A CALL/JMP-implemented thunk that forces load serialization; /// before making an indirect call/jump; ///; /// Note that the reason that this is implemented as a MachineFunctionPass and; /// not a ModulePass is that ModulePasses at this point in the LLVM X86 pipeline; /// serialize all transformations, which can consume lots of memory.; ///; /// TODO(chandlerc): All of this code could use better comments and; /// documentation.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:558,Security,secur,security,558,"//==- X86IndirectThunks.cpp - Construct indirect call/jump thunks for x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Pass that injects an MI thunk that is used to lower indirect calls in a way; /// that prevents speculation on some x86 processors and can be used to mitigate; /// security vulnerabilities due to targeted speculative execution and side; /// channels such as CVE-2017-5715.; ///; /// Currently supported thunks include:; /// - Retpoline -- A RET-implemented trampoline that lowers indirect calls; /// - LVI Thunk -- A CALL/JMP-implemented thunk that forces load serialization; /// before making an indirect call/jump; ///; /// Note that the reason that this is implemented as a MachineFunctionPass and; /// not a ModulePass is that ModulePasses at this point in the LLVM X86 pipeline; /// serialize all transformations, which can consume lots of memory.; ///; /// TODO(chandlerc): All of this code could use better comments and; /// documentation.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:218,Performance,load,loaded,218,"// This code mitigates LVI by replacing each indirect call/jump with a; // direct call/jump to a thunk that looks like:; // ```; // lfence; // jmpq *%r11; // ```; // This ensures that if the value in register %r11 was loaded from memory,; // then the value in %r11 is (architecturally) correct prior to the jump.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:81,Usability,pause,pause,81,"// __llvm_retpoline_r11:; // callq .Lr11_call_target; // .Lr11_capture_spec:; // pause; // lfence; // jmp .Lr11_capture_spec; // .align 16; // .Lr11_call_target:; // movq %r11, (%rsp); // retq",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:259,Usability,pause,pause,259,"// For 32-bit targets we need to emit a collection of thunks for various; // possible scratch registers as well as a fallback that uses EDI, which is; // normally callee saved.; // __llvm_retpoline_eax:; // calll .Leax_call_target; // .Leax_capture_spec:; // pause; // jmp .Leax_capture_spec; // .align 16; // .Leax_call_target:; // movl %eax, (%esp) # Clobber return addr; // retl; //; // __llvm_retpoline_ecx:; // ... # Same setup; // movl %ecx, (%esp); // retl; //; // __llvm_retpoline_edx:; // ... # Same setup; // movl %edx, (%esp); // retl; //; // __llvm_retpoline_edi:; // ... # Same setup; // movl %edi, (%esp); // retl",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:137,Usability,PAUSE,PAUSE,137,"// In the capture loop for speculation, we want to stop the processor from; // speculating as fast as possible. On Intel processors, the PAUSE instruction; // will block speculation without consuming any execution resources. On AMD; // processors, the PAUSE instruction is (essentially) a nop, so we also use an; // LFENCE instruction which they have advised will stop speculation as well; // with minimal resource utilization. We still end the capture with a jump to; // form an infinite loop to fully guarantee that no matter what implementation; // of the x86 ISA, speculating this code path never escapes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:252,Usability,PAUSE,PAUSE,252,"// In the capture loop for speculation, we want to stop the processor from; // speculating as fast as possible. On Intel processors, the PAUSE instruction; // will block speculation without consuming any execution resources. On AMD; // processors, the PAUSE instruction is (essentially) a nop, so we also use an; // LFENCE instruction which they have advised will stop speculation as well; // with minimal resource utilization. We still end the capture with a jump to; // form an infinite loop to fully guarantee that no matter what implementation; // of the x86 ISA, speculating this code path never escapes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp:44,Performance,cache,cache,44,"//===------- X86InsertPrefetch.cpp - Insert cache prefetch hints ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass applies cache prefetch instructions based on a profile. The pass; // assumes DiscriminateMemOps ran immediately before, to ensure debug info; // matches the one used at profile generation time. The profile is encoded in; // afdo format (text or binary). It contains prefetch hints recommendations.; // Each recommendation is made in terms of debug info locations, a type (i.e.; // nta, t{0|1|2}) and a delta. The debug info identifies an instruction with a; // memory operand (see X86DiscriminateMemOps). The prefetch will be made for; // a location at that memory operand + the delta specified in the; // recommendation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp:401,Performance,cache,cache,401,"//===------- X86InsertPrefetch.cpp - Insert cache prefetch hints ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass applies cache prefetch instructions based on a profile. The pass; // assumes DiscriminateMemOps ran immediately before, to ensure debug info; // matches the one used at profile generation time. The profile is encoded in; // afdo format (text or binary). It contains prefetch hints recommendations.; // Each recommendation is made in terms of debug info locations, a type (i.e.; // nta, t{0|1|2}) and a delta. The debug info identifies an instruction with a; // memory operand (see X86DiscriminateMemOps). The prefetch will be made for; // a location at that memory operand + the delta specified in the; // recommendation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp:55,Performance,cache,cache,55,"/// Return true if the provided MachineInstruction has cache prefetch hints. In; /// that case, the prefetch hints are stored, in order, in the Prefetches; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp:23,Integrability,message,message,23,// FIXME(mtrofin): ORE message when the recommendation cannot be taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp:842,Integrability,synchroniz,synchronizing,842,"//- X86Insertwait.cpp - Strict-Fp:Insert wait instruction X87 instructions --//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which insert x86 wait instructions after each; // X87 instructions when strict float is enabled.; //; // The logic to insert a wait instruction after an X87 instruction is as below:; // 1. If the X87 instruction don't raise float exception nor is a load/store; // instruction, or is a x87 control instruction, don't insert wait.; // 2. If the X87 instruction is an instruction which the following instruction; // is an X87 exception synchronizing X87 instruction, don't insert wait.; // 3. For other situations, insert wait instruction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp:658,Performance,load,load,658,"//- X86Insertwait.cpp - Strict-Fp:Insert wait instruction X87 instructions --//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which insert x86 wait instructions after each; // X87 instructions when strict float is enabled.; //; // The logic to insert a wait instruction after an X87 instruction is as below:; // 1. If the X87 instruction don't raise float exception nor is a load/store; // instruction, or is a x87 control instruction, don't insert wait.; // 2. If the X87 instruction is an instruction which the following instruction; // is an X87 exception synchronizing X87 instruction, don't insert wait.; // 3. For other situations, insert wait instruction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp:518,Testability,log,logic,518,"//- X86Insertwait.cpp - Strict-Fp:Insert wait instruction X87 instructions --//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which insert x86 wait instructions after each; // X87 instructions when strict float is enabled.; //; // The logic to insert a wait instruction after an X87 instruction is as below:; // 1. If the X87 instruction don't raise float exception nor is a load/store; // instruction, or is a x87 control instruction, don't insert wait.; // 2. If the X87 instruction is an instruction which the following instruction; // is an X87 exception synchronizing X87 instruction, don't insert wait.; // 3. For other situations, insert wait instruction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp:44,Performance,perform,perform,44,// a few special control instructions don't perform a wait operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp:75,Performance,load,load,75,"// If the instruction instruction neither has float exception nor is; // a load/store instruction, or the instruction is x87 control; // instruction, do not insert wait.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:39,Availability,mask,mask,39,/// Convert the x86 XMM integer vector mask to a vector of bools based on; /// each element's most significant bit (the sign bit).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:17,Availability,Mask,Mask,17,// Fold Constant Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Availability,Mask,Mask,3,// Mask was extended from a boolean vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:12,Modifiability,extend,extended,12,// Mask was extended from a boolean vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:62,Availability,mask,mask,62,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:95,Availability,mask,mask,95,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:140,Availability,mask,masked,140,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:170,Availability,mask,masked,170,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:207,Availability,mask,masked,207,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:100,Energy Efficiency,efficient,efficiently,100,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:8,Availability,Mask,Mask,8,// Zero Mask - masked load instruction creates a zero vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:15,Availability,mask,masked,15,// Zero Mask - masked load instruction creates a zero vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:22,Performance,load,load,22,// Zero Mask - masked load instruction creates a zero vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:7,Availability,mask,mask,7,// The mask is constant or extended from a bool vector. Convert this x86; // intrinsic to the LLVM intrinsic to allow target-independent optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:27,Modifiability,extend,extended,27,// The mask is constant or extended from a bool vector. Convert this x86; // intrinsic to the LLVM intrinsic to allow target-independent optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:137,Performance,optimiz,optimizations,137,// The mask is constant or extended from a bool vector. Convert this x86; // intrinsic to the LLVM intrinsic to allow target-independent optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:38,Availability,mask,masked,38,// The pass-through vector for an x86 masked load is a zero vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:45,Performance,load,load,45,// The pass-through vector for an x86 masked load is a zero vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:62,Availability,mask,mask,62,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:95,Availability,mask,mask,95,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:140,Availability,mask,masked,140,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:170,Availability,mask,masked,170,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:207,Availability,mask,masked,207,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:100,Energy Efficiency,efficient,efficiently,100,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:8,Availability,Mask,Mask,8,// Zero Mask - this masked store instruction does nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:20,Availability,mask,masked,20,// Zero Mask - this masked store instruction does nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:7,Availability,mask,mask,7,// The mask is constant or extended from a bool vector. Convert this x86; // intrinsic to the LLVM intrinsic to allow target-independent optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:27,Modifiability,extend,extended,27,// The mask is constant or extended from a bool vector. Convert this x86; // intrinsic to the LLVM intrinsic to allow target-independent optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:137,Performance,optimiz,optimizations,137,// The mask is constant or extended from a bool vector. Convert this x86; // intrinsic to the LLVM intrinsic to allow target-independent optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:62,Availability,mask,masked,62,// 'Replace uses' doesn't work for stores. Erase the original masked store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:134,Testability,log,logical,134,"// If the shift amount is guaranteed to be in-range we can replace it with a; // generic shift. If its guaranteed to be out of range, logical shifts combine; // to zero and arithmetic shifts are clamped to (BitWidth - 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Usability,Simpl,Simplify,3,// Simplify if count is constant vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:6,Testability,Log,LogicalShift,6,// If LogicalShift - just return zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:188,Testability,log,logical,188,"// Attempt to simplify AVX2 per-element shift intrinsics to a generic IR shift.; // Unlike the generic IR shifts, the intrinsics have defined behaviour for out; // of range shift amounts (logical - set to zero, arithmetic - splat sign bit).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:14,Usability,simpl,simplify,14,"// Attempt to simplify AVX2 per-element shift intrinsics to a generic IR shift.; // Unlike the generic IR shifts, the intrinsics have defined behaviour for out; // of range shift amounts (logical - set to zero, arithmetic - splat sign bit).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Usability,Simpl,Simplify,3,// Simplify if all shift amounts are constant/undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:38,Testability,Log,LogicalShift,38,// Handle out of range shifts.; // If LogicalShift - set to BitWidth (special case).; // If ArithmeticShift - set to (BitWidth - 1) (sign splat).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:62,Testability,log,logical,62,// We can't handle only some out of range values with generic logical shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:78,Testability,log,logic,78,"// Use for verification. Its a big table. Its difficult to go from Imm ->; // logic ops, but easy to verify that a set of logic ops is correct. We track; // the logic ops through the second value in the pair. At the end it should; // equal Imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:122,Testability,log,logic,122,"// Use for verification. Its a big table. Its difficult to go from Imm ->; // logic ops, but easy to verify that a set of logic ops is correct. We track; // the logic ops through the second value in the pair. At the end it should; // equal Imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:161,Testability,log,logic,161,"// Use for verification. Its a big table. Its difficult to go from Imm ->; // logic ops, but easy to verify that a set of logic ops is correct. We track; // the logic ops through the second value in the pair. At the end it should; // equal Imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:72,Availability,mask,mask,72,// The immediate permute control byte looks like this:; // [3:0] - zero mask for each 32-bit lane; // [5:4] - select one 32-bit destination lane; // [7:6] - select one 32-bit source lane,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:15,Availability,mask,mask,15,"// If all zero mask bits are set, this was just a weird way to; // generate a zero vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:15,Availability,mask,mask,15,"// If the zero mask is being used with a single input or the zero mask; // overrides the destination lane, this is a shuffle with the zero vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:66,Availability,mask,mask,66,"// If the zero mask is being used with a single input or the zero mask; // overrides the destination lane, this is a shuffle with the zero vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:12,Availability,mask,mask,12,// The zero mask may override the previous insert operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:45,Testability,log,logical,45,// TODO: Model this case as 2 shuffles or a 'logical and' plus shuffle?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:15,Usability,simpl,simplify,15,/// Attempt to simplify SSE4A EXTRQ/EXTRQI instructions using constant folding; /// or conversion to a shuffle vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:233,Integrability,wrap,wrap,233,"// Note that both field index and field length are 8-bit quantities.; // Since variables 'Index' and 'Length' are unsigned values; // obtained from zero-extending field index and field length; // respectively, their sum should never wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:79,Modifiability,variab,variables,79,"// Note that both field index and field length are 8-bit quantities.; // Since variables 'Index' and 'Length' are unsigned values; // obtained from zero-extending field index and field length; // respectively, their sum should never wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:153,Modifiability,extend,extending,153,"// Note that both field index and field length are 8-bit quantities.; // Since variables 'Index' and 'Length' are unsigned values; // obtained from zero-extending field index and field length; // respectively, their sum should never wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:112,Availability,mask,masks,112,"// If we are inserting whole bytes, we can convert this to a shuffle.; // Lowering can recognize EXTRQI shuffle masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:61,Availability,mask,mask,61,// Constant Fold - shift Index'th bit to lowest position and mask off; // Length bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:15,Usability,simpl,simplify,15,/// Attempt to simplify SSE4A INSERTQ/INSERTQI instructions using constant; /// folding or conversion to a shuffle vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:233,Integrability,wrap,wrap,233,"// Note that both field index and field length are 8-bit quantities.; // Since variables 'Index' and 'Length' are unsigned values; // obtained from zero-extending field index and field length; // respectively, their sum should never wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:79,Modifiability,variab,variables,79,"// Note that both field index and field length are 8-bit quantities.; // Since variables 'Index' and 'Length' are unsigned values; // obtained from zero-extending field index and field length; // respectively, their sum should never wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:153,Modifiability,extend,extending,153,"// Note that both field index and field length are 8-bit quantities.; // Since variables 'Index' and 'Length' are unsigned values; // obtained from zero-extending field index and field length; // respectively, their sum should never wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:114,Availability,mask,masks,114,"// If we are inserting whole bytes, we can convert this to a shuffle.; // Lowering can recognize INSERTQI shuffle masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:55,Availability,mask,mask,55,/// Attempt to convert pshufb* to shufflevector if the mask is constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:23,Availability,mask,mask,23,// Construct a shuffle mask from constant integers or UNDEFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:36,Availability,mask,mask,36,// Each byte in the shuffle control mask forms an index to permute the; // corresponding byte in the destination operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:80,Availability,mask,mask,80,"// If the most significant bit (bit[7]) of each byte of the shuffle; // control mask is set, then zero is written in the result byte.; // The zero vector is in the right-hand side of the resulting; // shufflevector.; // The value of each index for the high 128-bit lane is the least; // significant 4 bits of the respective shuffle control byte.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:59,Availability,mask,mask,59,/// Attempt to convert vpermilvar* to shufflevector if the mask is constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:23,Availability,mask,mask,23,// Construct a shuffle mask from constant integers or UNDEFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:45,Usability,clear,clear,45,"// The intrinsics only read one or two bits, clear the rest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:77,Availability,down,down,77,"// The PD variants uses bit 1 to select per-lane element index, so; // shift down to convert to generic shuffle mask index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:112,Availability,mask,mask,112,"// The PD variants uses bit 1 to select per-lane element index, so; // shift down to convert to generic shuffle mask index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:50,Availability,mask,mask,50,"// The _256 variants are a bit trickier since the mask bits always index; // into the corresponding 128 half. In order to convert to a generic; // shuffle, we have to make that explicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:62,Availability,mask,mask,62,/// Attempt to convert vpermd/vpermps to shufflevector if the mask is constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:23,Availability,mask,mask,23,// Construct a shuffle mask from constant integers or UNDEFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:44,Usability,simpl,simplifications,44,// If the RHS is a constant we can try some simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:82,Availability,mask,masking,82,// TODO should we turn this into 'and' if shift is 0? Or 'shl' if we; // are only masking bits that a shift already cleared?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:116,Usability,clear,cleared,116,// TODO should we turn this into 'and' if shift is 0? Or 'shl' if we; // are only masking bits that a shift already cleared?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:44,Usability,simpl,simplifications,44,// If the RHS is a constant we can try some simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:56,Availability,mask,mask,56,// any single contingous sequence of 1s anywhere in the mask simply; // describes a subset of the input bits shifted to the appropriate; // position. Replace with the straight forward IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:61,Usability,simpl,simply,61,// any single contingous sequence of 1s anywhere in the mask simply; // describes a subset of the input bits shifted to the appropriate; // position. Replace with the straight forward IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Usability,Clear,Clear,3,// Clear lowest set bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:56,Availability,mask,mask,56,// any single contingous sequence of 1s anywhere in the mask simply; // describes a subset of the input bits shifted to the appropriate; // position. Replace with the straight forward IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:61,Usability,simpl,simply,61,// any single contingous sequence of 1s anywhere in the mask simply; // describes a subset of the input bits shifted to the appropriate; // position. Replace with the straight forward IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Usability,Clear,Clear,3,// Clear lowest set bit;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:86,Usability,simpl,simplify,86,"// These intrinsics only demand the 0th element of their input vectors. If; // we can simplify the input based on that, do so now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:86,Usability,simpl,simplify,86,"// These intrinsics only demand the 0th element of their input vectors. If; // we can simplify the input based on that, do so now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:14,Availability,mask,masking,14,// Handle the masking aspect of the intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:41,Availability,mask,mask,41,// We don't need a select if we know the mask bit is a 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:12,Availability,mask,mask,12,// Cast the mask to an i1 vector and then extract the lowest element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:14,Usability,simpl,simplify,14,"// Attempt to simplify to a constant, shuffle vector or EXTRQI call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:14,Usability,simpl,simplify,14,// Attempt to simplify to a constant or shuffle vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:14,Usability,simpl,simplify,14,"// Attempt to simplify to a constant, shuffle vector or INSERTQI call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:14,Usability,simpl,simplify,14,// Attempt to simplify to a constant or shuffle vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:21,Availability,Mask,Mask,21,"// fold (blend A, A, Mask) -> A",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:8,Availability,Mask,Mask,8,// Zero Mask - select 1st argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:12,Availability,Mask,Mask,12,// Constant Mask - select 1st/2nd argument lane based on top bit of mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:68,Availability,mask,mask,68,// Constant Mask - select 1st/2nd argument lane based on top bit of mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:10,Availability,mask,mask,10,"// If the mask has less elements than the operands, each mask bit maps to; // multiple elements of the operands. Bitcast back and forth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:57,Availability,mask,mask,57,"// If the mask has less elements than the operands, each mask bit maps to; // multiple elements of the operands. Bitcast back and forth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:183,Usability,clear,clear,183,// The instructions for these intrinsics are speced to zero upper bits not; // pass them through like other scalar intrinsics. So we shouldn't just; // use Arg0 if DemandedElts[0] is clear like we do for other intrinsics.; // Instead we should return a zero vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h:743,Integrability,wrap,wrapping,743,"//===-- X86InstrBuilder.h - Functions to aid building x86 insts -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to handle X86'isms in a clean way.; //; // The BuildMem function may be used with the BuildMI function to add entire; // memory references in a single, typed, function call. X86 memory references; // can be very complex expressions (described in the README), so wrapping them; // up behind an easier to use interface makes sense. Descriptions of the; // functions are included below.; //; // For reference, the order of operands for memory references is:; // (Operand), Base, Scale, Index, Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h:788,Integrability,interface,interface,788,"//===-- X86InstrBuilder.h - Functions to aid building x86 insts -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to handle X86'isms in a clean way.; //; // The BuildMem function may be used with the BuildMI function to add entire; // memory references in a single, typed, function call. X86 memory references; // can be very complex expressions (described in the README), so wrapping them; // up behind an easier to use interface makes sense. Descriptions of the; // functions are included below.; //; // For reference, the order of operands for memory references is:; // (Operand), Base, Scale, Index, Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h:393,Security,expose,exposes,393,"//===-- X86InstrBuilder.h - Functions to aid building x86 insts -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to handle X86'isms in a clean way.; //; // The BuildMem function may be used with the BuildMI function to add entire; // memory references in a single, typed, function call. X86 memory references; // can be very complex expressions (described in the README), so wrapping them; // up behind an easier to use interface makes sense. Descriptions of the; // functions are included below.; //; // For reference, the order of operands for memory references is:; // (Operand), Base, Scale, Index, Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:139,Availability,mask,mask,139,/// This bit must be set in the 'Attributes' field of FMA group if such; /// group of FMA opcodes consists of AVX512 opcodes accepting a k-mask and; /// passing the elements from the 1st operand to the result of the operation; /// when the correpondings bits in the k-mask are unset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:268,Availability,mask,mask,268,/// This bit must be set in the 'Attributes' field of FMA group if such; /// group of FMA opcodes consists of AVX512 opcodes accepting a k-mask and; /// passing the elements from the 1st operand to the result of the operation; /// when the correpondings bits in the k-mask are unset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:60,Availability,mask,masked,60,/// Returns true iff the group of FMA opcodes holds k-merge-masked opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:59,Availability,mask,masked,59,/// Returns true iff the group of FMA opcodes holds k-zero-masked opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:61,Availability,mask,masked,61,/// Returns true iff the group of FMA opcodes holds any of k-masked opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:267,Usability,simpl,simple,267,// These tables are sorted by their RegOp value allowing them to be binary; // searched at runtime without the need for additional storage. The enum values; // are currently emitted in X86GenInstrInfo.inc in alphabetical order. Which; // makes sorting these tables a simple matter of alphabetizing the table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:29,Safety,safe,safe,29,// Table to map instructions safe to broadcast using a different width from the; // element width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:100,Modifiability,variab,variable,100,// This class stores the memory unfolding tables. It is instantiated as a; // function scope static variable to lazily init the unfolding table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:19,Performance,load,load,19,"// Index 0, folded load and store, no alignment requirement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:19,Performance,load,loads,19,"// Index 0, mix of loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:19,Performance,load,load,19,"// Index 1, folded load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:19,Performance,load,load,19,"// Index 2, folded load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:19,Performance,load,load,19,"// Index 3, folded load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:19,Performance,load,load,19,"// Index 4, folded load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:111,Modifiability,variab,variable,111,// This class stores the memory -> broadcast folding tables. It is instantiated; // as a function scope static variable to lazily init the folding table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h:406,Integrability,interface,interface,406,"//===-- X86InstrFoldTables.h - X86 Instruction Folding Tables ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the interface to query the X86 memory folding tables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h:56,Performance,load,load,56,// Look up the memory folding table entry for folding a load and a store into; // operand 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h:56,Performance,load,load,56,// Look up the memory folding table entry for folding a load or store with; // operand OpNum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:63,Performance,load,loaded,63,"// On x86 it is believed that imul is constant time w.r.t. the loaded data.; // However, they set flags and are perhaps the most surprisingly constant; // time operations so we call them out here separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,Usability,clear,clearing,22,"// Bit extracting and clearing instructions should execute in constant time,; // and set flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:50,Modifiability,extend,extend,50,// Various move instructions used to zero or sign extend things. Note that we; // intentionally don't support the _NOREX variants as we can't handle that; // register constraint anyways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:24,Security,access,access,24,"// LEA doesn't actually access memory, and its arithmetic is constant time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:31,Performance,load,load,31,"// By default, assume that the load will immediately leak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:63,Performance,load,loaded,63,"// On x86 it is believed that imul is constant time w.r.t. the loaded data.; // However, they set flags and are perhaps the most surprisingly constant; // time operations so we call them out here separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,Usability,clear,clearing,22,"// Bit extracting and clearing instructions should execute in constant time,; // and set flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Performance,Load,Loads,3,// Loads to register don't set flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:77,Usability,simpl,simplified,77,"// If we could not find a frame destroy opcode, then it has already; // been simplified, so we don't care.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:20,Testability,log,logic,20,// Defer to generic logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Performance,Load,Loads,3,// Loads from constant pools are trivially rematerializable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:35,Performance,load,load,35,// Allow re-materialization of PIC load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:65,Safety,avoid,avoid,65,// The instruction clobbers EFLAGS. Re-materialize as MOV32ri to avoid side; // effects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:51,Performance,load,load-effective-address,51,// Left shift instructions can be transformed into load-effective-address; // instructions if we can encode them appropriately.; // A LEA instruction utilizes a SIB byte to encode its scale factor.; // The SIB.scale field is two bits wide which means that we can encode any; // shift amount less than 4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:221,Availability,redundant,redundant,221,"// Caller (`X86InstrInfo::optimizeCompareInstr`) guarantees that; // `CmpValDefInstr` defines the value that's used by `CmpInstr`; in this case; // if `CmpValDefInstr` sets the EFLAGS, it is likely that `CmpInstr` is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:26,Performance,optimiz,optimizeCompareInstr,26,"// Caller (`X86InstrInfo::optimizeCompareInstr`) guarantees that; // `CmpValDefInstr` defines the value that's used by `CmpInstr`; in this case; // if `CmpValDefInstr` sets the EFLAGS, it is likely that `CmpInstr` is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:221,Safety,redund,redundant,221,"// Caller (`X86InstrInfo::optimizeCompareInstr`) guarantees that; // `CmpValDefInstr` defines the value that's used by `CmpInstr`; in this case; // if `CmpValDefInstr` sets the EFLAGS, it is likely that `CmpInstr` is; // redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,Testability,test,test,22,"// We can only remove test when AND32ri or AND64ri32 whose imm can fit 16bit; // size, others 32/64 bit ops would test higher bits which test16rr don't; // want to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:114,Testability,test,test,114,"// We can only remove test when AND32ri or AND64ri32 whose imm can fit 16bit; // size, others 32/64 bit ops would test higher bits which test16rr don't; // want to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:77,Usability,simpl,simplify,77,"// Requires `CmpValDefInstr` and `VregDefInstr` are from the same MBB; // to simplify the subsequent analysis.; //; // FIXME: If `VregDefInstr->getParent()` is the only predecessor of; // `CmpValDefInstr.getParent()`, this could be handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:525,Performance,optimiz,optimized,525,"// Get a sequence of instructions like; // %reg = and* ... // Set EFLAGS; // ... // EFLAGS not changed; // %extended_reg = subreg_to_reg 0, %reg, %subreg.sub_32bit; // test64rr %extended_reg, %extended_reg, implicit-def $eflags; // or; // %reg = and32* ...; // ... // EFLAGS not changed.; // %src_reg = copy %reg.sub_16bit:gr32; // test16rr %src_reg, %src_reg, implicit-def $eflags; //; // If subsequent readers use a subset of bits that don't change; // after `and*` instructions, it's likely that the test64rr could; // be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:36,Deployability,update,update,36,"// AND instruction will essentially update SF and clear OF, so; // NoSignFlag should be false in the sense that SF is modified by `AND`.; //; // However, the implementation artifically sets `NoSignFlag` to true; // to poison the SF bit; that is to say, if SF is looked at later, the; // optimization (to erase TEST64rr) will be disabled.; //; // The reason to poison SF bit is that SF bit value could be different; // in the `AND` and `TEST` operation; signed bit is not known for `AND`,; // and is known to be 0 as a result of `TEST64rr`.; //; // FIXME: As opposed to poisoning the SF bit directly, consider peeking into; // the AND instruction and using the static information to guide peephole; // optimization if possible. For example, it's possible to fold a; // conditional move into a copy if the relevant EFLAG bits could be deduced; // from an immediate operand of and operation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:287,Performance,optimiz,optimization,287,"// AND instruction will essentially update SF and clear OF, so; // NoSignFlag should be false in the sense that SF is modified by `AND`.; //; // However, the implementation artifically sets `NoSignFlag` to true; // to poison the SF bit; that is to say, if SF is looked at later, the; // optimization (to erase TEST64rr) will be disabled.; //; // The reason to poison SF bit is that SF bit value could be different; // in the `AND` and `TEST` operation; signed bit is not known for `AND`,; // and is known to be 0 as a result of `TEST64rr`.; //; // FIXME: As opposed to poisoning the SF bit directly, consider peeking into; // the AND instruction and using the static information to guide peephole; // optimization if possible. For example, it's possible to fold a; // conditional move into a copy if the relevant EFLAG bits could be deduced; // from an immediate operand of and operation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:701,Performance,optimiz,optimization,701,"// AND instruction will essentially update SF and clear OF, so; // NoSignFlag should be false in the sense that SF is modified by `AND`.; //; // However, the implementation artifically sets `NoSignFlag` to true; // to poison the SF bit; that is to say, if SF is looked at later, the; // optimization (to erase TEST64rr) will be disabled.; //; // The reason to poison SF bit is that SF bit value could be different; // in the `AND` and `TEST` operation; signed bit is not known for `AND`,; // and is known to be 0 as a result of `TEST64rr`.; //; // FIXME: As opposed to poisoning the SF bit directly, consider peeking into; // the AND instruction and using the static information to guide peephole; // optimization if possible. For example, it's possible to fold a; // conditional move into a copy if the relevant EFLAG bits could be deduced; // from an immediate operand of and operation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:436,Testability,TEST,TEST,436,"// AND instruction will essentially update SF and clear OF, so; // NoSignFlag should be false in the sense that SF is modified by `AND`.; //; // However, the implementation artifically sets `NoSignFlag` to true; // to poison the SF bit; that is to say, if SF is looked at later, the; // optimization (to erase TEST64rr) will be disabled.; //; // The reason to poison SF bit is that SF bit value could be different; // in the `AND` and `TEST` operation; signed bit is not known for `AND`,; // and is known to be 0 as a result of `TEST64rr`.; //; // FIXME: As opposed to poisoning the SF bit directly, consider peeking into; // the AND instruction and using the static information to guide peephole; // optimization if possible. For example, it's possible to fold a; // conditional move into a copy if the relevant EFLAG bits could be deduced; // from an immediate operand of and operation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:50,Usability,clear,clear,50,"// AND instruction will essentially update SF and clear OF, so; // NoSignFlag should be false in the sense that SF is modified by `AND`.; //; // However, the implementation artifically sets `NoSignFlag` to true; // to poison the SF bit; that is to say, if SF is looked at later, the; // optimization (to erase TEST64rr) will be disabled.; //; // The reason to poison SF bit is that SF bit value could be different; // in the `AND` and `TEST` operation; signed bit is not known for `AND`,; // and is known to be 0 as a result of `TEST64rr`.; //; // FIXME: As opposed to poisoning the SF bit directly, consider peeking into; // the AND instruction and using the static information to guide peephole; // optimization if possible. For example, it's possible to fold a; // conditional move into a copy if the relevant EFLAG bits could be deduced; // from an immediate operand of and operation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:682,Usability,guid,guide,682,"// AND instruction will essentially update SF and clear OF, so; // NoSignFlag should be false in the sense that SF is modified by `AND`.; //; // However, the implementation artifically sets `NoSignFlag` to true; // to poison the SF bit; that is to say, if SF is looked at later, the; // optimization (to erase TEST64rr) will be disabled.; //; // The reason to poison SF bit is that SF bit value could be different; // in the `AND` and `TEST` operation; signed bit is not known for `AND`,; // and is known to be 0 as a result of `TEST64rr`.; //; // FIXME: As opposed to poisoning the SF bit directly, consider peeking into; // the AND instruction and using the static information to guide peephole; // optimization if possible. For example, it's possible to fold a; // conditional move into a copy if the relevant EFLAG bits could be deduced; // from an immediate operand of and operation.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Usability,Clear,ClearsOverflowFlag,3,// ClearsOverflowFlag is true for AND operation (no surprise).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:56,Modifiability,variab,variables,56,"// TODO: For a 32-bit target, we need to adjust the LEA variables with; // something like this:; // Opcode = X86::LEA32r;; // InRegLEA = RegInfo.createVirtualRegister(&X86::GR32_NOSPRegClass);; // OutRegLEA =; // Is8BitOp ? RegInfo.createVirtualRegister(&X86::GR32ABCD_RegClass); // : RegInfo.createVirtualRegister(&X86::GR32RegClass);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:295,Performance,perform,performance,295,"// Build and insert into an implicit UNDEF value. This is OK because; // we will be shifting and then extracting the lower 8/16-bits.; // This has the potential to cause partial register stall. e.g.; // movw (%rbp,%rcx,2), %dx; // leal -65(%rdx), %esi; // But testing has shown this *does* help performance in 64-bit mode (at; // least on modern x86 machines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:260,Testability,test,testing,260,"// Build and insert into an implicit UNDEF value. This is OK because; // we will be shifting and then extracting the lower 8/16-bits.; // This has the potential to cause partial register stall. e.g.; // movw (%rbp,%rcx,2), %dx; // leal -65(%rdx), %esi; // But testing has shown this *does* help performance in 64-bit mode (at; // least on modern x86 machines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Deployability,Update,Update,3,// Update live variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:15,Modifiability,variab,variables,15,// Update live variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:31,Availability,down,down,31,// Move the definition of Dest down to ExtMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:490,Performance,perform,performed,490,"/// This method must be implemented by targets that; /// set the M_CONVERTIBLE_TO_3_ADDR flag. When this flag is set, the target; /// may be able to convert a two-address instruction into a true; /// three-address instruction on demand. This allows the X86 target (for; /// example) to convert ADD and SHL instructions into LEA instructions if they; /// would require register copies due to two-addressness.; ///; /// This method returns a null pointer if the transformation cannot be; /// performed, otherwise it returns the new instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:261,Availability,error,errors,261,"// Ideally, operations with undef should be folded before we get here, but we; // can't guarantee it. Bail out because optimizing undefs is a waste of time.; // Without this, we have to forward undef state to new register operands to; // avoid machine verifier errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:119,Performance,optimiz,optimizing,119,"// Ideally, operations with undef should be folded before we get here, but we; // can't guarantee it. Bail out because optimizing undefs is a waste of time.; // Without this, we have to forward undef state to new register operands to; // avoid machine verifier errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:238,Safety,avoid,avoid,238,"// Ideally, operations with undef should be folded before we get here, but we; // can't guarantee it. Bail out because optimizing undefs is a waste of time.; // Without this, we have to forward undef state to new register operands to; // avoid machine verifier errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Deployability,Update,Update,3,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:15,Modifiability,variab,variables,15,// Update live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:138,Availability,mask,mask,138,/// This determines which of three possible cases of a three source commute; /// the source indexes correspond to taking into account any mask operands.; /// All prevents commuting a passthru operand. Returns -1 if the commute isn't; /// possible.; /// Case 0 - Possible to commute the first and second operands.; /// Case 1 - Possible to commute the first and third operands.; /// Case 2 - Possible to commute the second and third operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:40,Usability,simpl,simplify,40,// Put the lowest index to SrcOpIdx1 to simplify the checks below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:313,Availability,avail,available,313,"// TODO: Commuting the 1st operand of FMA*_Int requires some additional; // analysis. The commute optimization is legal only if all users of FMA*_Int; // use only the lowest element of the FMA*_Int instruction. Such analysis are; // not implemented yet. So, just return 0 in that case.; // When such analysis are available this place will be the right place for; // calling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:98,Performance,optimiz,optimization,98,"// TODO: Commuting the 1st operand of FMA*_Int requires some additional; // analysis. The commute optimization is legal only if all users of FMA*_Int; // use only the lowest element of the FMA*_Int instruction. Such analysis are; // not implemented yet. So, just return 0 in that case.; // When such analysis are available this place will be the right place for; // calling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Usability,Clear,Clear,3,// Clear out the bits we are swapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:12,Performance,optimiz,optimizing,12,"// If we're optimizing for size, try to use MOVSD/MOVSS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:95,Modifiability,extend,extended,95,// Only the least significant bits of Imm are used.; // Using int8_t to ensure it will be sign extended to the int64_t that; // setImm takes in order to match isel behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:14,Availability,mask,masked,14,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:141,Availability,mask,masked,141,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:283,Availability,mask,mask,283,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:435,Availability,mask,mask,435,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:596,Availability,mask,mask,596,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:833,Availability,mask,mask,833,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:864,Availability,mask,masked,864,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:880,Availability,mask,masked,880,"// For k-zero-masked operations it is Ok to commute the first vector; // operand. Unless this is an intrinsic instruction.; // For regular k-masked operations a conservative choice is done as the; // elements of the first vector operand, for which the corresponding bit; // in the k-mask operand is set to 0, are copied to the result of the; // instruction.; // TODO/FIXME: The commute still may be legal if it is known that the; // k-mask operand is set to either all ones or all zeroes.; // It is also Ok to commute the 1st operand if all users of MI use only; // the elements enabled by the k-mask operand. For example,; // v4 = VFMADD213PSZrk v1, k, v2, v3; // v1[i] = k[i] ? v2[i]*v1[i]+v3[i]; // : v1[i];; // VMOVAPSZmrk <mem_addr>, k, v4; // this is the ONLY user of v4 ->; // // Ok, to commute v1 in FMADD213PSZrk.; // The k-mask operand has index = 2 for masked and zero-masked operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:114,Availability,mask,mask,114,// The operand with index = 1 is used as a source for those elements for; // which the corresponding bit in the k-mask is set to 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:30,Availability,mask,mask,30,// Just ignore and skip the k-mask operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:27,Safety,safe,safely,27,// Float comparison can be safely commuted for; // Ordered/Unordered/Equal/NotEqual tests,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:84,Testability,test,tests,84,// Float comparison can be safely commuted for; // Ordered/Unordered/Equal/NotEqual tests,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:75,Availability,mask,masked,75,// The indices of the commutable operands are 1 and 2 (or 2 and 3; // when masked).; // Assign them to the returned operand indices here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:12,Availability,mask,mask,12,// Skip the mask register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:11,Availability,mask,masked,11,// Handled masked instructions since we need to skip over the mask input; // and the preserved input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:62,Availability,mask,mask,62,// Handled masked instructions since we need to skip over the mask input; // and the preserved input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:44,Availability,mask,mask,44,// First assume that the first input is the mask operand and skip past it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:90,Availability,mask,mask,90,// Check if the first input is tied. If there isn't one then we only; // need to skip the mask operand which we did above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:19,Availability,mask,masking,19,"// If this is zero masking instruction with a tied operand, we need to; // move the first index back to the first input since this must; // be a 3 input instruction and we want the first two non-mask inputs.; // Otherwise this is a 2 input instruction with a preserved input and; // mask, so we need to move the indices to skip one more input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:195,Availability,mask,mask,195,"// If this is zero masking instruction with a tied operand, we need to; // move the first index back to the first input since this must; // be a 3 input instruction and we want the first two non-mask inputs.; // Otherwise this is a 2 input instruction with a preserved input and; // mask, so we need to move the indices to skip one more input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:283,Availability,mask,mask,283,"// If this is zero masking instruction with a tied operand, we need to; // move the first index back to the first input since this must; // be a 3 input instruction and we want the first two non-mask inputs.; // Otherwise this is a 2 input instruction with a preserved input and; // mask, so we need to move the indices to skip one more input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:11,Deployability,toggle,toggle,11,// Need to toggle bits 3:0. Bit 4 stays the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:32,Integrability,rout,routine,32,"// Directly invoke the MC-layer routine for real (i.e., non-pseudo); // instructions (fast case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:10,Deployability,patch,patches,10,"// Kernel patches thunk calls in runtime, these should never be conditional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:108,Safety,abort,abort,108,"// Can't handle indirect branch.; // In practice we should never have an undef eflags operand, if we do; // abort here as we are not prepared to preserve the flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Deployability,Update,Update,3,// Update the MachineOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:59,Testability,test,test,59,"// Currently we only recognize the simple pattern:; //; // test %reg, %reg; // je %label; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:35,Usability,simpl,simple,35,"// Currently we only recognize the simple pattern:; //; // test %reg, %reg; // je %label; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:78,Integrability,Bridg,Bridge,78,"// This latency applies to Pentium M, Merom, Wolfdale, Nehalem, and Sandy; // Bridge. Probably Ivy Bridge as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:99,Integrability,Bridg,Bridge,99,"// This latency applies to Pentium M, Merom, Wolfdale, Nehalem, and Sandy; // Bridge. Probably Ivy Bridge as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:8,Performance,latency,latency,8,"// This latency applies to Pentium M, Merom, Wolfdale, Nehalem, and Sandy; // Bridge. Probably Ivy Bridge as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:4,Testability,Test,Test,4,/// Test if the given register is a physical h register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:10,Availability,Mask,MaskReg,10,"// SrcReg(MaskReg) -> DestReg(GR64); // SrcReg(MaskReg) -> DestReg(GR32); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:47,Availability,Mask,MaskReg,47,"// SrcReg(MaskReg) -> DestReg(GR64); // SrcReg(MaskReg) -> DestReg(GR32); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:132,Testability,test,tested,132,"// SrcReg(MaskReg) -> DestReg(GR64); // SrcReg(MaskReg) -> DestReg(GR32); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:27,Availability,Mask,MaskReg,27,"// SrcReg(GR64) -> DestReg(MaskReg); // SrcReg(GR32) -> DestReg(MaskReg); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:64,Availability,Mask,MaskReg,64,"// SrcReg(GR64) -> DestReg(MaskReg); // SrcReg(GR32) -> DestReg(MaskReg); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:132,Testability,test,tested,132,"// SrcReg(GR64) -> DestReg(MaskReg); // SrcReg(GR32) -> DestReg(MaskReg); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:14,Modifiability,extend,extended,14,// If this an extended register and we don't have VLX we need to use a; // 512-bit move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:14,Modifiability,extend,extended,14,// If this an extended register and we don't have VLX we need to use a; // 512-bit move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:58,Testability,test,tested,58,"// All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:25,Availability,error,error,25,// FIXME: We use a fatal error here because historically LLVM has tried; // lower some of these physreg copies and we want to ensure we get; // reasonable bug reports if someone encounters a case no other testing; // found. This path should be removed after the LLVM 7 release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:269,Deployability,release,release,269,// FIXME: We use a fatal error here because historically LLVM has tried; // lower some of these physreg copies and we want to ensure we get; // reasonable bug reports if someone encounters a case no other testing; // found. This path should be removed after the LLVM 7 release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:205,Testability,test,testing,205,// FIXME: We use a fatal error here because historically LLVM has tried; // lower some of these physreg copies and we want to ensure we get; // reasonable bug reports if someone encounters a case no other testing; // found. This path should be removed after the LLVM 7 release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:153,Testability,assert,asserted,153,"// FIXME: Dirty hack for apparent invariant that doesn't hold when; // subreg_to_reg is coalesced with ordinary copies, such that the bits that; // were asserted as 0 are now undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:16,Availability,mask,mask,16,"// All of these mask pair classes have the same spill size, the same kind; // of kmov instructions can be used with all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:8,Modifiability,extend,extend,8,// Zero extend of a sub-reg of NullValueReg into itself does not change the; // null value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:24,Performance,perform,perform,24,// A SUB can be used to perform comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:226,Integrability,depend,depend,226,"// ""ELF Handling for Thread-Local Storage"" specifies that x86-64 GOTTPOFF, and; // i386 GOTNTPOFF/INDNTPOFF relocations can convert an ADD to a LEA during; // Initial Exec to Local Exec relaxation. In these cases, we must not depend; // on the EFLAGS modification of ADD actually happening in the final binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:125,Integrability,depend,depending,125,// The shift instructions only modify ZF if their shift count is non-zero.; // N.B.: The processor truncates the shift count depending on the encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:109,Safety,Avoid,Avoid,109,// Some left shift instructions can be turned into LEA instructions but only; // if their flags aren't used. Avoid transforming such instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:56,Testability,TEST,TEST,56,// These instructions clear the overflow flag just like TEST.; // FIXME: These are not the only instructions in this switch that clear the; // overflow flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,Usability,clear,clear,22,// These instructions clear the overflow flag just like TEST.; // FIXME: These are not the only instructions in this switch that clear the; // overflow flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:129,Usability,clear,clear,129,// These instructions clear the overflow flag just like TEST.; // FIXME: These are not the only instructions in this switch that clear the; // overflow flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,Deployability,update,update,17,"// BEXTR doesn't update the sign flag so we can't use it. It does clear; // the overflow flag, but that's not useful without the sign flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:66,Usability,clear,clear,66,"// BEXTR doesn't update the sign flag so we can't use it. It does clear; // the overflow flag, but that's not useful without the sign flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:19,Performance,optimiz,optimize,19,// Fall through to optimize Cmp if Cmp is CMPrr or CMPri.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:123,Testability,test,testl,123,"// Try to use EFLAGS from the instruction defining %SrcReg. Example:; // %eax = addl ...; // ... // EFLAGS not changed; // testl %eax, %eax // <-- can be removed",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:152,Testability,test,testl,152,"// Try to use EFLAGS produced by an instruction reading %SrcReg.; // Example:; // %eax = ...; // ...; // popcntl %eax; // ... // EFLAGS not changed; // testl %eax, %eax // <-- can be removed",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:76,Safety,safe,safe,76,"// MOV32r0 is implemented with xor which clobbers condition code. It is; // safe to move up, if the definition to EFLAGS is dead and earlier; // instructions do not read or write EFLAGS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:82,Safety,safe,safe,82,"// Scan forward from the instruction after CmpInstr for uses of EFLAGS.; // It is safe to remove CmpInstr if EFLAGS is redefined or killed.; // If we are done with the basic block, we need to check whether EFLAGS is; // live-out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:58,Deployability,update,updates,58,// We should check the usage if this instruction uses and updates EFLAGS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:46,Deployability,update,updated,46,// It is safe to remove CmpInstr if EFLAGS is updated again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:9,Safety,safe,safe,9,// It is safe to remove CmpInstr if EFLAGS is updated again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:24,Performance,perform,perform,24,"// CF is used, we can't perform this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:37,Performance,optimiz,optimization,37,"// CF is used, we can't perform this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:46,Deployability,update,update,46,"// If SF is used, but the instruction doesn't update the SF, then we; // can't do the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:86,Performance,optimiz,optimization,86,"// If SF is used, but the instruction doesn't update the SF, then we; // can't do the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:43,Usability,clear,clear,43,"// If OF is used, the instruction needs to clear it like CmpZero does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:46,Deployability,update,update,46,"// If SF is used, but the instruction doesn't update the SF, then we; // can't do the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:86,Performance,optimiz,optimization,86,"// If SF is used, but the instruction doesn't update the SF, then we; // can't do the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:54,Safety,safe,safe,54,"// Push the MachineInstr to OpsToUpdate.; // If it is safe to remove CmpInstr, the condition code of these; // instructions will be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:46,Deployability,update,updated,46,// It is safe to remove CmpInstr if EFLAGS is updated again or killed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:9,Safety,safe,safe,9,// It is safe to remove CmpInstr if EFLAGS is updated again or killed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,Deployability,update,update,17,"// If we have to update users but EFLAGS is live-out abort, since we cannot; // easily find all of the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:53,Safety,abort,abort,53,"// If we have to update users but EFLAGS is live-out abort, since we cannot; // easily find all of the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:25,Deployability,update,updated,25,// The instruction to be updated is either Sub or MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,Performance,load,load,22,"/// Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if load defines a virtual; /// register, the virtual register is used once in the same BB, and the; /// instructions in-between do not load or store, and have no side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:92,Performance,load,load,92,"/// Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if load defines a virtual; /// register, the virtual register is used once in the same BB, and the; /// instructions in-between do not load or store, and have no side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:113,Performance,load,load,113,"/// Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if load defines a virtual; /// register, the virtual register is used once in the same BB, and the; /// instructions in-between do not load or store, and have no side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:245,Performance,load,load,245,"/// Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if load defines a virtual; /// register, the virtual register is used once in the same BB, and the; /// instructions in-between do not load or store, and have no side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:33,Modifiability,extend,extended,33,"// 64 bit operations accept sign extended 32 bit immediates.; // 32 bit operations accept all 32 bit immediates, so we don't need to check; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:121,Performance,optimiz,optimizing,121,// Immediate has larger code size than register. So avoid folding the; // immediate if it has more than 1 use and we are optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:52,Safety,avoid,avoid,52,// Immediate has larger code size than register. So avoid folding the; // immediate if it has more than 1 use and we are optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Testability,TEST,TEST,3,"// TEST, CMP",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Performance,Load,LoadStackGuard,3,// LoadStackGuard has so far only been implemented for 64-bit MachO. Different; // code sequence is needed for other targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:204,Availability,avail,available,204,"// This is used to handle spills for 128/256-bit registers when we have AVX512,; // but not VLX. If it uses an extended register we need to use an instruction; // that loads the lower 128/256-bit, but is available with only AVX512F.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:111,Modifiability,extend,extended,111,"// This is used to handle spills for 128/256-bit registers when we have AVX512,; // but not VLX. If it uses an extended register we need to use an instruction; // that loads the lower 128/256-bit, but is available with only AVX512F.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:168,Performance,load,loads,168,"// This is used to handle spills for 128/256-bit registers when we have AVX512,; // but not VLX. If it uses an extended register we need to use an instruction; // that loads the lower 128/256-bit, but is available with only AVX512F.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:35,Performance,load,load,35,// We can use a normal VEX encoded load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:205,Availability,avail,available,205,"// This is used to handle spills for 128/256-bit registers when we have AVX512,; // but not VLX. If it uses an extended register we need to use an instruction; // that stores the lower 128/256-bit, but is available with only AVX512F.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:111,Modifiability,extend,extended,111,"// This is used to handle spills for 128/256-bit registers when we have AVX512,; // but not VLX. If it uses an extended register we need to use an instruction; // that stores the lower 128/256-bit, but is available with only AVX512F.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Modifiability,Extend,Extended,3,// Extended register without VLX. Use a larger XOR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:57,Availability,mask,mask,57,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:274,Availability,mask,mask,274,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:328,Availability,mask,mask,328,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:404,Availability,mask,mask,404,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:26,Integrability,depend,dependency-breaking,26,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:110,Integrability,depend,dependence,110,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:176,Performance,perform,performance,176,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:310,Usability,usab,usable,310,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:47,Deployability,update,update,47,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:217,Deployability,update,update,217,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:270,Deployability,update,updated,270,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:402,Integrability,depend,dependency,402,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:181,Performance,load,loads,181,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:340,Performance,load,load,340,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:437,Performance,perform,performance,437,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:167,Safety,avoid,avoid,167,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:48,Deployability,update,update,48,// Load folding won't effect the undef register update since the input is; // a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Performance,Load,Load,3,// Load folding won't effect the undef register update since the input is; // a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:107,Deployability,update,update,107,/// Inform the BreakFalseDeps pass how many idle; /// instructions we would like before a partial register update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:56,Deployability,update,update,56,"// If MI is marked as reading Reg, the partial register update is wanted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:76,Integrability,depend,dependency,76,"// If any instructions in the clearance range are reading Reg, insert a; // dependency breaking instruction, which is inexpensive and is likely to; // be hidden in other instruction's cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:30,Usability,clear,clearance,30,"// If any instructions in the clearance range are reading Reg, insert a; // dependency breaking instruction, which is inexpensive and is likely to; // be hidden in other instruction's cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:204,Integrability,depend,dependency,204,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.; // Operand 1 of these instructions is tied so they're separate from their; // VEX counterparts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:190,Safety,avoid,avoid,190,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.; // Operand 1 of these instructions is tied so they're separate from their; // VEX counterparts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:204,Integrability,depend,dependency,204,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:190,Safety,avoid,avoid,190,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:48,Deployability,update,update,48,// Load folding won't effect the undef register update since the input is; // a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Performance,Load,Load,3,// Load folding won't effect the undef register update since the input is; // a GPR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:338,Deployability,pipeline,pipeline,338,"/// Inform the BreakFalseDeps pass how many idle instructions we would like; /// before certain undef register reads.; ///; /// This catches the VCVTSI2SD family of instructions:; ///; /// vcvtsi2sdq %rax, undef %xmm0, %xmm14; ///; /// We should to be careful *not* to catch VXOR idioms which are presumably; /// handled specially in the pipeline:; ///; /// vxorps undef %xmm1, undef %xmm1, %xmm1; ///; /// Like getPartialRegUpdateClearance, this makes a strong assumption that the; /// high bits that are passed-through are not live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:40,Integrability,depend,dependence,40,"// If MI kills this register, the false dependence is already broken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,Usability,clear,clear,17,// Use vxorps to clear the full ymm register.; // It wants to read and write the xmm sub-register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,Usability,clear,clear,17,// Use vpxord to clear the full ymm/zmm register.; // It wants to read and write the xmm sub-register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:19,Deployability,update,update,19,// We only need to update constraints on virtual register operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:26,Performance,load,load,26,// Attempt to convert the load of inserted vector into a fold load; // of a single float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:62,Performance,load,load,62,// Attempt to convert the load of inserted vector into a fold load; // of a single float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:86,Performance,load,load,86,"// Move the upper 64-bits of the second operand to the lower 64-bits.; // To fold the load, adjust the pointer to the upper and use (V)MOVLPS.; // TODO: In most cases AVX doesn't have a 8-byte alignment requirement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:139,Performance,load,load,139,"// If we won't be able to fold this to the memory form of UNPCKL, use; // MOVHPD instead. Done as custom because we can't have this in the load; // table twice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:65,Deployability,pipeline,pipeline,65,// The are two cases we need to handle depending on where in the pipeline; // the folding attempt is being made.; // -Register has the undef flag set.; // -Register is produced by the IMPLICIT_DEF instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:39,Integrability,depend,depending,39,// The are two cases we need to handle depending on where in the pipeline; // the folding attempt is being made.; // -Register has the undef flag set.; // -Register is produced by the IMPLICIT_DEF instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:76,Performance,load,loads,76,"// For CPUs that favor the register form of a call or push,; // do not fold loads into calls or pushes, unless optimizing for size; // aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:111,Performance,optimiz,optimizing,111,"// For CPUs that favor the register form of a call or push,; // do not fold loads into calls or pushes, unless optimizing for size; // aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:36,Deployability,update,update,36,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:57,Performance,optimiz,optimizing,57,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:23,Performance,load,loads,23,// GOTTPOFF relocation loads can only be folded into add instructions.; // FIXME: Need to exclude other relocations that only support specific; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:14,Performance,load,loads,14,// Don't fold loads into indirect calls that need a KCFI check as we'll; // have to unfold these in X86TargetLowering::EmitKCFICheck anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:34,Performance,load,load,34,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.; // FIXME: Allow scalar intrinsic instructions like ADDSSrm_Int.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:91,Performance,load,load,91,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.; // FIXME: Allow scalar intrinsic instructions like ADDSSrm_Int.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,Safety,safe,safe,17,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.; // FIXME: Allow scalar intrinsic instructions like ADDSSrm_Int.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:113,Modifiability,extend,extended,113,"// If this is a 64-bit load, but the spill slot is 32, then we can do; // a 32-bit load which is implicitly zero-extended. This likely is; // due to live interval analysis remat'ing a load from stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:23,Performance,load,load,23,"// If this is a 64-bit load, but the spill slot is 32, then we can do; // a 32-bit load which is implicitly zero-extended. This likely is; // due to live interval analysis remat'ing a load from stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:83,Performance,load,load,83,"// If this is a 64-bit load, but the spill slot is 32, then we can do; // a 32-bit load which is implicitly zero-extended. This likely is; // due to live interval analysis remat'ing a load from stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:184,Performance,load,load,184,"// If this is a 64-bit load, but the spill slot is 32, then we can do; // a 32-bit load which is implicitly zero-extended. This likely is; // due to live interval analysis remat'ing a load from stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:211,Availability,fault,fault,211,"// For stores, make sure the size of the object is equal to the size of; // the store. If the object is larger, the extra bits would be garbage. If; // the object is smaller we might overwrite another object or fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:90,Modifiability,extend,extend,90,// If this is the special case where we use a MOV32rm to load a 32-bit; // value and zero-extend the top bits. Change the destination register; // to a 32-bit one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:57,Performance,load,load,57,// If this is the special case where we use a MOV32rm to load a 32-bit; // value and zero-extend the top bits. Change the destination register; // to a 32-bit one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:26,Usability,undo,undo,26,// Folding failed again - undo the commute before returning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:41,Availability,failure,failure,41,// Return here to prevent duplicate fuse failure report.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:36,Deployability,update,update,36,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:57,Performance,optimiz,optimizing,57,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:34,Performance,load,load,34,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:91,Performance,load,load,91,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,Safety,safe,safe,17,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:16,Performance,Load,LoadMI,16,"/// Check if \p LoadMI is a partial register load that we can't fold into \p MI; /// because the latter uses contents that wouldn't be defined in the folded; /// version. For instance, this transformation isn't legal:; /// movss (%rdi), %xmm0; /// addps %xmm0, %xmm0; /// ->; /// addps (%rdi), %xmm0; ///; /// But this one is:; /// movss (%rdi), %xmm0; /// addss %xmm0, %xmm0; /// ->; /// addss (%rdi), %xmm0; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:45,Performance,load,load,45,"/// Check if \p LoadMI is a partial register load that we can't fold into \p MI; /// because the latter uses contents that wouldn't be defined in the folded; /// version. For instance, this transformation isn't legal:; /// movss (%rdi), %xmm0; /// addps %xmm0, %xmm0; /// ->; /// addps (%rdi), %xmm0; ///; /// But this one is:; /// movss (%rdi), %xmm0; /// addss %xmm0, %xmm0; /// ->; /// addss (%rdi), %xmm0; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:27,Performance,load,load,27,"// These instructions only load 32 bits, we can't fold them if the; // destination register is wider than 32 bits (4 bytes), and its user; // instruction isn't scalar (SS).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:27,Performance,load,load,27,"// These instructions only load 64 bits, we can't fold them if the; // destination register is wider than 64 bits (8 bytes), and its user; // instruction isn't scalar (SD).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:27,Performance,load,load,27,"// These instructions only load 16 bits, we can't fold them if the; // destination register is wider than 16 bits (2 bytes), and its user; // instruction isn't scalar (SH).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:32,Performance,Load,LoadMI,32,"// TODO: Support the case where LoadMI loads a wide register, but MI; // only uses a subreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:39,Performance,load,loads,39,"// TODO: Support the case where LoadMI loads a wide register, but MI; // only uses a subreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:6,Performance,load,loading,6,"// If loading from a FrameIndex, fold directly from the FrameIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:36,Deployability,update,update,36,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:57,Performance,optimiz,optimizing,57,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:34,Performance,load,load,34,// Determine the alignment of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:84,Performance,load,load,84,// Make sure the subregisters match.; // Otherwise we risk changing the size of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:54,Safety,risk,risk,54,// Make sure the subregisters match.; // Otherwise we risk changing the size of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:41,Performance,load,load,41,"// Folding a V_SET0 or V_SETALLONES as a load, to ease register pressure.; // Create a constant-pool entry and operands to load from it.; // Large code model can't fold loads this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:123,Performance,load,load,123,"// Folding a V_SET0 or V_SETALLONES as a load, to ease register pressure.; // Create a constant-pool entry and operands to load from it.; // Large code model can't fold loads this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:169,Performance,load,loads,169,"// Folding a V_SET0 or V_SETALLONES as a load, to ease register pressure.; // Create a constant-pool entry and operands to load from it.; // Large code model can't fold loads this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,Performance,load,load,22,// Create operands to load from the constant pool entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:20,Performance,load,load,20,// Folding a normal load. Just copy the load's address operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:40,Performance,load,load,40,// Folding a normal load. Just copy the load's address operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:31,Performance,load,load,31,// Clone the MMO and unset the load flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:37,Security,access,accesses,37,// TODO: Check if 32-byte or greater accesses are slow too?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:24,Performance,load,loadRegFromAddr,24,"// Without memoperands, loadRegFromAddr and storeRegToStackSlot will; // conservatively assume the address is unaligned. That's bad for; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:140,Performance,perform,performance,140,"// Without memoperands, loadRegFromAddr and storeRegToStackSlot will; // conservatively assume the address is unaligned. That's bad for; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:12,Performance,load,load,12,// Emit the load or broadcast instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:12,Performance,load,load,12,// Emit the load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:37,Performance,load,load,37,// Do not introduce a slow unaligned load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:85,Security,access,access,85,"// FIXME: If a VR128 can have size 32, we should be checking if a 32-byte; // memory access is slow above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:85,Security,access,access,85,"// FIXME: If a VR128 can have size 32, we should be checking if a 32-byte; // memory access is slow above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:7,Performance,load,load,7,// AVX load instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:10,Performance,load,load,10,// AVX512 load instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:31,Performance,load,loads,31,// Lambda to check if both the loads have the same value for an operand index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:36,Energy Efficiency,schedul,scheduled,36,// ENDBR instructions should not be scheduled around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:86,Performance,load,loads,86,// FIXME: Return false for x87 stack register classes for now. We can't; // allow any loads of these registers before FpGet_ST0_80.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:43,Availability,mask,masks,43,// Helper to attempt to widen/narrow blend masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:63,Availability,mask,masks,63,// Treat VPBLENDWY as a 128-bit vector as it repeats the lo/hi masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:30,Performance,latency,latency,30,// AVX instructions with high latency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:33,Performance,latency,latency,33,// AVX512 instructions with high latency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:317,Integrability,depend,depend,317,"// Integer binary math/logic instructions have a third source operand:; // the EFLAGS register. That operand must be both defined here and never; // used; ie, it must be dead. If the EFLAGS operand is live, then we can; // not change anything because rearranging the operands could affect other; // instructions that depend on the exact status flags (zero, sign, etc.); // that are set by using these particular operands with this operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:23,Testability,log,logic,23,"// Integer binary math/logic instructions have a third source operand:; // the EFLAGS register. That operand must be both defined here and never; // used; ie, it must be dead. If the EFLAGS operand is live, then we can; // not change anything because rearranging the operands could affect other; // instructions that depend on the exact status flags (zero, sign, etc.); // that are set by using these particular operands with this operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:130,Testability,log,logic,130,"// TODO: There are many more machine instruction opcodes to match:; // 1. Other data types (integer, vectors); // 2. Other math / logic operations (xor, or); // 3. Other forms of the same operation (intrinsics and other variants)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:42,Modifiability,extend,extended,42,"// MOV32ri may be used for producing zero-extended 32-bit immediates in; // 64-bit parameters, so we need to consider super-registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:77,Modifiability,extend,extend,77,"// If the described register is the destination register we need to; // sign-extend the source register from 32 bits. The other case we handle; // is when the described register is the 32-bit sub-register of the; // destination register, in case we just need to return the source; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:20,Security,access,accesses,20,// No point folding accesses if there isn't at least two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:63,Safety,risk,risk,63,"// Does the function use a red zone? If it does, then we can't risk messing; // with the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:66,Usability,clear,clear,66,// Convert register to the 32-bit version. Both 'movl' and 'xorl' clear the; // upper bits of a 64-bit register automagically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:11,Safety,safe,safe,11,// PXOR is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:12,Safety,safe,safe,12,// VPXOR is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:13,Safety,safe,safe,13,// VPXORY is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:11,Safety,safe,safe,11,// KXOR is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:119,Testability,stub,stub,119,"// namespace X86; /// isGlobalStubReference - Return true if the specified TargetFlag operand is; /// a reference to a stub for a global, not the global itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:13,Testability,stub,stub,13,// dllimport stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:16,Testability,stub,stub,16,// COFF .refptr stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:293,Availability,avail,available,293,"/// isCoalescableExtInstr - Return true if the instruction is a ""coalescable""; /// extension instruction. That is, it's like a copy where it's legal for the; /// source to overlap the destination. e.g. X86::MOVSX64rr32. If this returns; /// true, then it's expected the pre-extension value is available as a subreg; /// of the result register. This also returns the sub-register index in; /// SubIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:347,Performance,load,loaded,347,/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value of any of its register operands; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:244,Integrability,depend,dependent,244,"/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value loaded from memory or the value of any; /// non-address register operands.; ///; /// For example, if the latency of the instruction is dependent on the; /// particular bits set in any of the registers *or* any of the bits loaded; /// from memory.; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:109,Performance,load,loaded,109,"/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value loaded from memory or the value of any; /// non-address register operands.; ///; /// For example, if the latency of the instruction is dependent on the; /// particular bits set in any of the registers *or* any of the bits loaded; /// from memory.; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:214,Performance,latency,latency,214,"/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value loaded from memory or the value of any; /// non-address register operands.; ///; /// For example, if the latency of the instruction is dependent on the; /// particular bits set in any of the registers *or* any of the bits loaded; /// from memory.; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:331,Performance,load,loaded,331,"/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value loaded from memory or the value of any; /// non-address register operands.; ///; /// For example, if the latency of the instruction is dependent on the; /// particular bits set in any of the registers *or* any of the bits loaded; /// from memory.; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:562,Performance,load,loaded,562,"/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value loaded from memory or the value of any; /// non-address register operands.; ///; /// For example, if the latency of the instruction is dependent on the; /// particular bits set in any of the registers *or* any of the bits loaded; /// from memory.; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:138,Availability,reliab,reliable,138,/// isLoadFromStackSlotPostFE - Check for post-frame ptr elimination; /// stack locations as well. This uses a heuristic so it isn't; /// reliable for correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:137,Availability,reliab,reliable,137,/// isStoreToStackSlotPostFE - Check for post-frame ptr elimination; /// stack locations as well. This uses a heuristic so it isn't; /// reliable for correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:514,Performance,perform,performed,514,"/// convertToThreeAddress - This method must be implemented by targets that; /// set the M_CONVERTIBLE_TO_3_ADDR flag. When this flag is set, the target; /// may be able to convert a two-address instruction into a true; /// three-address instruction on demand. This allows the X86 target (for; /// example) to convert ADD and SHL instructions into LEA instructions if they; /// would require register copies due to two-addressness.; ///; /// This method returns a null pointer if the transformation cannot be; /// performed, otherwise it returns the new instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:25,Integrability,rout,routine,25,"/// Returns true iff the routine could find two commutable operands in the; /// given machine instruction.; /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments. Their; /// input values can be re-defined in this method only if the input values; /// are not pre-defined, which is designated by the special value; /// 'CommuteAnyOperandIndex' assigned to it.; /// If both of indices are pre-defined and refer to some operands, then the; /// method simply returns true if the corresponding operands are commutable; /// and returns false otherwise.; ///; /// For example, calling this method this way:; /// unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;; /// findCommutedOpIndices(MI, Op1, Op2);; /// can be interpreted as a query asking to find an operand that would be; /// commutable with the operand#1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:460,Usability,simpl,simply,460,"/// Returns true iff the routine could find two commutable operands in the; /// given machine instruction.; /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments. Their; /// input values can be re-defined in this method only if the input values; /// are not pre-defined, which is designated by the special value; /// 'CommuteAnyOperandIndex' assigned to it.; /// If both of indices are pre-defined and refer to some operands, then the; /// method simply returns true if the corresponding operands are commutable; /// and returns false otherwise.; ///; /// For example, calling this method this way:; /// unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;; /// findCommutedOpIndices(MI, Op1, Op2);; /// can be interpreted as a query asking to find an operand that would be; /// commutable with the operand#1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:82,Performance,perform,performs,82,"/// Returns an adjusted FMA opcode that must be used in FMA instruction that; /// performs the same computations as the given \p MI but which has the; /// operands \p SrcOpIdx1 and \p SrcOpIdx2 commuted.; /// It may return 0 if it is unsafe to commute the operands.; /// Note that a machine instruction (instead of its opcode) is passed as the; /// first parameter to make it possible to analyze the instruction's uses and; /// commute the first operand of FMA even when it seems unsafe when you look; /// at the opcode. For example, it is Ok to commute the first operand of; /// VFMADD*SD_Int, if ONLY the lowest 64-bit element of the result is used.; ///; /// The returned FMA opcode may differ from the opcode in the given \p MI.; /// For example, commuting the operands #1 and #3 in the following FMA; /// FMA213 #1, #2, #3; /// results into instruction with adjusted opcode:; /// FMA231 #3, #2, #1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:234,Safety,unsafe,unsafe,234,"/// Returns an adjusted FMA opcode that must be used in FMA instruction that; /// performs the same computations as the given \p MI but which has the; /// operands \p SrcOpIdx1 and \p SrcOpIdx2 commuted.; /// It may return 0 if it is unsafe to commute the operands.; /// Note that a machine instruction (instead of its opcode) is passed as the; /// first parameter to make it possible to analyze the instruction's uses and; /// commute the first operand of FMA even when it seems unsafe when you look; /// at the opcode. For example, it is Ok to commute the first operand of; /// VFMADD*SD_Int, if ONLY the lowest 64-bit element of the result is used.; ///; /// The returned FMA opcode may differ from the opcode in the given \p MI.; /// For example, commuting the operands #1 and #3 in the following FMA; /// FMA213 #1, #2, #3; /// results into instruction with adjusted opcode:; /// FMA231 #3, #2, #1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:480,Safety,unsafe,unsafe,480,"/// Returns an adjusted FMA opcode that must be used in FMA instruction that; /// performs the same computations as the given \p MI but which has the; /// operands \p SrcOpIdx1 and \p SrcOpIdx2 commuted.; /// It may return 0 if it is unsafe to commute the operands.; /// Note that a machine instruction (instead of its opcode) is passed as the; /// first parameter to make it possible to analyze the instruction's uses and; /// commute the first operand of FMA even when it seems unsafe when you look; /// at the opcode. For example, it is Ok to commute the first operand of; /// VFMADD*SD_Int, if ONLY the lowest 64-bit element of the result is used.; ///; /// The returned FMA opcode may differ from the opcode in the given \p MI.; /// For example, commuting the operands #1 and #3 in the following FMA; /// FMA213 #1, #2, #3; /// results into instruction with adjusted opcode:; /// FMA231 #3, #2, #1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:40,Performance,load,load,40,/// Check whether the target can fold a load that feeds a subreg operand; /// (or a subreg operand that feeds a store).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:59,Performance,load,load,59,"/// foldMemoryOperand - If this target supports it, fold a load or store of; /// the specified stack slot into the specified machine instruction for the; /// specified operand(s). If this is possible, the target should perform the; /// folding and return true, otherwise it should return false. If it folds; /// the instruction, it is likely that the MachineInstruction the iterator; /// references has been changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:219,Performance,perform,perform,219,"/// foldMemoryOperand - If this target supports it, fold a load or store of; /// the specified stack slot into the specified machine instruction for the; /// specified operand(s). If this is possible, the target should perform the; /// folding and return true, otherwise it should return false. If it folds; /// the instruction, it is likely that the MachineInstruction the iterator; /// references has been changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:90,Performance,load,load,90,"/// foldMemoryOperand - Same as the previous version except it allows folding; /// of any load and store from / to any address, not just from a specific; /// stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:71,Performance,load,load,71,"/// unfoldMemoryOperand - Separate a single instruction which folded a load or; /// a store or a load and a store into two or more instruction. If this is; /// possible, returns true as well as the new instructions by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:97,Performance,load,load,97,"/// unfoldMemoryOperand - Separate a single instruction which folded a load or; /// a store or a load and a store into two or more instruction. If this is; /// possible, returns true as well as the new instructions by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:95,Performance,load,load,95,"/// getOpcodeAfterMemoryUnfold - Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:239,Performance,Load,LoadRegIndex,239,"/// getOpcodeAfterMemoryUnfold - Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:365,Performance,load,loaded,365,"/// getOpcodeAfterMemoryUnfold - Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:63,Energy Efficiency,schedul,scheduler,63,/// areLoadsFromSameBasePtr - This is used by the pre-regalloc scheduler; /// to determine if two loads are loading from the same base address. It; /// should only return true if the base pointers are the same and the; /// only differences between the two addresses are the offset. It also returns; /// the offsets by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:98,Performance,load,loads,98,/// areLoadsFromSameBasePtr - This is used by the pre-regalloc scheduler; /// to determine if two loads are loading from the same base address. It; /// should only return true if the base pointers are the same and the; /// only differences between the two addresses are the offset. It also returns; /// the offsets by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:108,Performance,load,loading,108,/// areLoadsFromSameBasePtr - This is used by the pre-regalloc scheduler; /// to determine if two loads are loading from the same base address. It; /// should only return true if the base pointers are the same and the; /// only differences between the two addresses are the offset. It also returns; /// the offsets by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:186,Energy Efficiency,schedul,scheduled,186,/// isSchedulingBoundary - Overrides the isSchedulingBoundary from; ///	Codegen/TargetInstrInfo.cpp to make it capable of identifying ENDBR; /// intructions and prevent it from being re-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:65,Energy Efficiency,schedul,scheduler,65,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:167,Energy Efficiency,schedul,scheduled,167,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:295,Energy Efficiency,schedul,scheduled,295,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:473,Energy Efficiency,schedul,schedule,473,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:568,Energy Efficiency,schedul,scheduled,568,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:146,Performance,load,loads,146,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:209,Performance,load,loads,209,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:219,Performance,load,loading,219,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:259,Performance,cache,cache,259,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:372,Performance,load,load,372,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:490,Performance,load,loads,490,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:534,Performance,load,loads,534,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:51,Safety,safe,safe,51,/// isSafeToMoveRegClassDefs - Return true if it's safe to move a machine; /// instruction that defines the specified register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:4,Performance,optimiz,optimizeCompareInstr,4,/// optimizeCompareInstr - Check if there exists an earlier instruction that; /// operates on the same source operands and sets flags in the same way as; /// Compare; remove Compare if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:4,Performance,optimiz,optimizeLoadInstr,4,"/// optimizeLoadInstr - Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:42,Performance,load,load,42,"/// optimizeLoadInstr - Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:112,Performance,load,load,112,"/// optimizeLoadInstr - Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:206,Performance,load,load,206,"/// optimizeLoadInstr - Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:319,Performance,load,load,319,"/// optimizeLoadInstr - Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:23,Performance,latency,latency,23,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands; /// For X86 instruction (vpmaddwd + vpmaddwd) -> vpdpwssd, the vpmaddwd; /// is not in the critical path, so the root latency only include vpmaddwd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:76,Performance,latency,latency,76,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands; /// For X86 instruction (vpmaddwd + vpmaddwd) -> vpdpwssd, the vpmaddwd; /// is not in the critical path, so the root latency only include vpmaddwd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:112,Performance,latency,latency,112,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands; /// For X86 instruction (vpmaddwd + vpmaddwd) -> vpdpwssd, the vpmaddwd; /// is not in the critical path, so the root latency only include vpmaddwd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:319,Performance,latency,latency,319,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands; /// For X86 instruction (vpmaddwd + vpmaddwd) -> vpdpwssd, the vpmaddwd; /// is not in the critical path, so the root latency only include vpmaddwd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:194,Availability,down,down,194,/// This is a helper for convertToThreeAddress for 8 and 16-bit instructions.; /// We use 32-bit LEA to form 3-address code by promoting to a 32-bit; /// super-register and then truncating back down to a 8/16-bit sub-register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:25,Integrability,rout,routine,25,"/// Returns true iff the routine could find two commutable operands in the; /// given machine instruction with 3 vector inputs.; /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments. Their; /// input values can be re-defined in this method only if the input values; /// are not pre-defined, which is designated by the special value; /// 'CommuteAnyOperandIndex' assigned to it.; /// If both of indices are pre-defined and refer to some operands, then the; /// method simply returns true if the corresponding operands are commutable; /// and returns false otherwise.; ///; /// For example, calling this method this way:; /// unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;; /// findThreeSrcCommutedOpIndices(MI, Op1, Op2);; /// can be interpreted as a query asking to find an operand that would be; /// commutable with the operand#1.; ///; /// If IsIntrinsic is set, operand 1 will be ignored for commuting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:481,Usability,simpl,simply,481,"/// Returns true iff the routine could find two commutable operands in the; /// given machine instruction with 3 vector inputs.; /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments. Their; /// input values can be re-defined in this method only if the input values; /// are not pre-defined, which is designated by the special value; /// 'CommuteAnyOperandIndex' assigned to it.; /// If both of indices are pre-defined and refer to some operands, then the; /// method simply returns true if the corresponding operands are commutable; /// and returns false otherwise.; ///; /// For example, calling this method this way:; /// unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;; /// findThreeSrcCommutedOpIndices(MI, Op1, Op2);; /// can be interpreted as a query asking to find an operand that would be; /// commutable with the operand#1.; ///; /// If IsIntrinsic is set, operand 1 will be ignored for commuting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:468,Testability,TEST,TEST,468,"/// Returns true when instruction \p FlagI produces the same flags as \p OI.; /// The caller should pass in the results of calling analyzeCompare on \p OI:; /// \p SrcReg, \p SrcReg2, \p ImmMask, \p ImmValue.; /// If the flags match \p OI as if it had the input operands swapped then the; /// function succeeds and sets \p IsSwapped to true.; ///; /// Examples of OI, FlagI pairs returning true:; /// CMP %1, 42 and CMP %1, 42; /// CMP %1, %2 and %3 = SUB %1, %2; /// TEST %1, %1 and %2 = SUB %1, 0; /// CMP %1, %2 and %3 = SUB %2, %1 ; IsSwapped=true",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:470,Performance,optimiz,optimization,470,"//===- X86InterleavedAccess.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the X86 implementation of the interleaved accesses; /// optimization generating X86-specific instructions/intrinsics for; /// interleaved access groups.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:456,Security,access,accesses,456,"//===- X86InterleavedAccess.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the X86 implementation of the interleaved accesses; /// optimization generating X86-specific instructions/intrinsics for; /// interleaved access groups.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:552,Security,access,access,552,"//===- X86InterleavedAccess.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the X86 implementation of the interleaved accesses; /// optimization generating X86-specific instructions/intrinsics for; /// interleaved access groups.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:220,Performance,load,loads,220,"/// This class holds necessary information to represent an interleaved; /// access group and supports utilities to lower the group into; /// X86-specific instructions/intrinsics.; /// E.g. A group of interleaving access loads (Factor = 2; accessing every; /// other element); /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; /// %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:292,Performance,load,load,292,"/// This class holds necessary information to represent an interleaved; /// access group and supports utilities to lower the group into; /// X86-specific instructions/intrinsics.; /// E.g. A group of interleaving access loads (Factor = 2; accessing every; /// other element); /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; /// %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:76,Security,access,access,76,"/// This class holds necessary information to represent an interleaved; /// access group and supports utilities to lower the group into; /// X86-specific instructions/intrinsics.; /// E.g. A group of interleaving access loads (Factor = 2; accessing every; /// other element); /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; /// %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:213,Security,access,access,213,"/// This class holds necessary information to represent an interleaved; /// access group and supports utilities to lower the group into; /// X86-specific instructions/intrinsics.; /// E.g. A group of interleaving access loads (Factor = 2; accessing every; /// other element); /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; /// %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:239,Security,access,accessing,239,"/// This class holds necessary information to represent an interleaved; /// access group and supports utilities to lower the group into; /// X86-specific instructions/intrinsics.; /// E.g. A group of interleaving access loads (Factor = 2; accessing every; /// other element); /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; /// %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:26,Performance,load,load,26,/// Reference to the wide-load instruction of an interleaved access; /// group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:61,Security,access,access,61,/// Reference to the wide-load instruction of an interleaved access; /// group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:53,Performance,load,load,53,"/// Reference to the shuffle(s), consumer(s) of the (load) 'Inst'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:11,Availability,down,down,11,/// Breaks down a vector \p 'Inst' of N elements into \p NumSubVectors; /// sub vectors of type \p T. Returns the sub-vectors in \p DecomposedVectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:4,Performance,Perform,Performs,4,"/// Performs matrix transposition on a 4x4 matrix \p InputVectors and; /// returns the transposed-vectors in \p TransposedVectors.; /// E.g.; /// InputVectors:; /// In-V0 = p1, p2, p3, p4; /// In-V1 = q1, q2, q3, q4; /// In-V2 = r1, r2, r3, r4; /// In-V3 = s1, s2, s3, s4; /// OutputVectors:; /// Out-V0 = p1, q1, r1, s1; /// Out-V1 = p2, q2, r2, s2; /// Out-V2 = p3, q3, r3, s3; /// Out-V3 = P4, q4, r4, s4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:96,Performance,load,load,96,"/// In order to form an interleaved access group X86InterleavedAccessGroup; /// requires a wide-load instruction \p 'I', a group of interleaved-vectors; /// \p Shuffs, reference to the first indices of each interleaved-vector; /// \p 'Ind' and the interleaving stride factor \p F. In order to generate; /// X86-specific instructions/intrinsics it also requires the underlying; /// target information \p STarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:36,Security,access,access,36,"/// In order to form an interleaved access group X86InterleavedAccessGroup; /// requires a wide-load instruction \p 'I', a group of interleaved-vectors; /// \p Shuffs, reference to the first indices of each interleaved-vector; /// \p 'Ind' and the interleaving stride factor \p F. In order to generate; /// X86-specific instructions/intrinsics it also requires the underlying; /// target information \p STarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:37,Security,access,access,37,"/// Returns true if this interleaved access group can be lowered into; /// x86-specific instructions/intrinsics, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:28,Security,access,access,28,/// Lowers this interleaved access group into X86-specific; /// instructions/intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:94,Performance,load,load,94,"// Currently, lowering is supported for the following vectors:; // Stride 4:; // 1. Store and load of 4-element vectors of 64 bits on AVX.; // 2. Store of 16/32-element vectors of 8 bits on AVX.; // Stride 3:; // 1. Load of 16/32-element vectors of 8 bits on AVX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:216,Performance,Load,Load,216,"// Currently, lowering is supported for the following vectors:; // Stride 4:; // 1. Store and load of 4-element vectors of 64 bits on AVX.; // 2. Store of 16/32-element vectors of 8 bits on AVX.; // Stride 3:; // 1. Load of 16/32-element vectors of 8 bits on AVX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:17,Performance,load,load,17,// Decompose the load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:56,Performance,load,load,56,"// In the case of stride 3 with a vector of 32 elements load the information; // in the following way:; // [0,1...,VF/2-1,VF/2+VF,VF/2+VF+1,...,2VF-1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:14,Performance,load,loads,14,// Generate N loads of T type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:163,Availability,mask,mask,163,"// genShuffleBland - Creates shuffle according to two vectors.This function is; // only works on instructions with lane inside 256 registers. According to; // the mask 'Mask' creates a new Mask 'Out' by the offset of the mask. The; // offset amount depends on the two integer, 'LowOffset' and 'HighOffset'.; // Where the 'LowOffset' refers to the first vector and the highOffset refers to; // the second vector.; // |a0....a5,b0....b4,c0....c4|a16..a21,b16..b20,c16..c20|; // |c5...c10,a5....a9,b5....b9|c21..c26,a22..a26,b21..b25|; // |b10..b15,c11..c15,a10..a15|b26..b31,c27..c31,a27..a31|; // For the sequence to work as a mirror to the load.; // We must consider the elements order as above.; // In this function we are combining two types of shuffles.; // The first one is vpshufed and the second is a type of ""blend"" shuffle.; // By computing the shuffle on a sequence of 16 elements(one lane) and add the; // correct offset. We are creating a vpsuffed + blend sequence between two; // shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:169,Availability,Mask,Mask,169,"// genShuffleBland - Creates shuffle according to two vectors.This function is; // only works on instructions with lane inside 256 registers. According to; // the mask 'Mask' creates a new Mask 'Out' by the offset of the mask. The; // offset amount depends on the two integer, 'LowOffset' and 'HighOffset'.; // Where the 'LowOffset' refers to the first vector and the highOffset refers to; // the second vector.; // |a0....a5,b0....b4,c0....c4|a16..a21,b16..b20,c16..c20|; // |c5...c10,a5....a9,b5....b9|c21..c26,a22..a26,b21..b25|; // |b10..b15,c11..c15,a10..a15|b26..b31,c27..c31,a27..a31|; // For the sequence to work as a mirror to the load.; // We must consider the elements order as above.; // In this function we are combining two types of shuffles.; // The first one is vpshufed and the second is a type of ""blend"" shuffle.; // By computing the shuffle on a sequence of 16 elements(one lane) and add the; // correct offset. We are creating a vpsuffed + blend sequence between two; // shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:189,Availability,Mask,Mask,189,"// genShuffleBland - Creates shuffle according to two vectors.This function is; // only works on instructions with lane inside 256 registers. According to; // the mask 'Mask' creates a new Mask 'Out' by the offset of the mask. The; // offset amount depends on the two integer, 'LowOffset' and 'HighOffset'.; // Where the 'LowOffset' refers to the first vector and the highOffset refers to; // the second vector.; // |a0....a5,b0....b4,c0....c4|a16..a21,b16..b20,c16..c20|; // |c5...c10,a5....a9,b5....b9|c21..c26,a22..a26,b21..b25|; // |b10..b15,c11..c15,a10..a15|b26..b31,c27..c31,a27..a31|; // For the sequence to work as a mirror to the load.; // We must consider the elements order as above.; // In this function we are combining two types of shuffles.; // The first one is vpshufed and the second is a type of ""blend"" shuffle.; // By computing the shuffle on a sequence of 16 elements(one lane) and add the; // correct offset. We are creating a vpsuffed + blend sequence between two; // shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:221,Availability,mask,mask,221,"// genShuffleBland - Creates shuffle according to two vectors.This function is; // only works on instructions with lane inside 256 registers. According to; // the mask 'Mask' creates a new Mask 'Out' by the offset of the mask. The; // offset amount depends on the two integer, 'LowOffset' and 'HighOffset'.; // Where the 'LowOffset' refers to the first vector and the highOffset refers to; // the second vector.; // |a0....a5,b0....b4,c0....c4|a16..a21,b16..b20,c16..c20|; // |c5...c10,a5....a9,b5....b9|c21..c26,a22..a26,b21..b25|; // |b10..b15,c11..c15,a10..a15|b26..b31,c27..c31,a27..a31|; // For the sequence to work as a mirror to the load.; // We must consider the elements order as above.; // In this function we are combining two types of shuffles.; // The first one is vpshufed and the second is a type of ""blend"" shuffle.; // By computing the shuffle on a sequence of 16 elements(one lane) and add the; // correct offset. We are creating a vpsuffed + blend sequence between two; // shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:249,Integrability,depend,depends,249,"// genShuffleBland - Creates shuffle according to two vectors.This function is; // only works on instructions with lane inside 256 registers. According to; // the mask 'Mask' creates a new Mask 'Out' by the offset of the mask. The; // offset amount depends on the two integer, 'LowOffset' and 'HighOffset'.; // Where the 'LowOffset' refers to the first vector and the highOffset refers to; // the second vector.; // |a0....a5,b0....b4,c0....c4|a16..a21,b16..b20,c16..c20|; // |c5...c10,a5....a9,b5....b9|c21..c26,a22..a26,b21..b25|; // |b10..b15,c11..c15,a10..a15|b26..b31,c27..c31,a27..a31|; // For the sequence to work as a mirror to the load.; // We must consider the elements order as above.; // In this function we are combining two types of shuffles.; // The first one is vpshufed and the second is a type of ""blend"" shuffle.; // By computing the shuffle on a sequence of 16 elements(one lane) and add the; // correct offset. We are creating a vpsuffed + blend sequence between two; // shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:640,Performance,load,load,640,"// genShuffleBland - Creates shuffle according to two vectors.This function is; // only works on instructions with lane inside 256 registers. According to; // the mask 'Mask' creates a new Mask 'Out' by the offset of the mask. The; // offset amount depends on the two integer, 'LowOffset' and 'HighOffset'.; // Where the 'LowOffset' refers to the first vector and the highOffset refers to; // the second vector.; // |a0....a5,b0....b4,c0....c4|a16..a21,b16..b20,c16..c20|; // |c5...c10,a5....a9,b5....b9|c21..c26,a22..a26,b21..b25|; // |b10..b15,c11..c15,a10..a15|b26..b31,c27..c31,a27..a31|; // For the sequence to work as a mirror to the load.; // We must consider the elements order as above.; // In this function we are combining two types of shuffles.; // The first one is vpshufed and the second is a type of ""blend"" shuffle.; // By computing the shuffle on a sequence of 16 elements(one lane) and add the; // correct offset. We are creating a vpsuffed + blend sequence between two; // shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:3,Availability,Mask,MaskHighTemp,3,// MaskHighTemp and MaskLowTemp built in the vpunpckhbw and vpunpcklbw X86; // shuffle pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:20,Availability,Mask,MaskLowTemp,20,// MaskHighTemp and MaskLowTemp built in the vpunpckhbw and vpunpcklbw X86; // shuffle pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:39,Availability,mask,mask,39,"// createShuffleStride returns shuffle mask of size N.; // The shuffle pattern is as following :; // {0, Stride%(VF/Lane), (2*Stride%(VF/Lane))...(VF*Stride/Lane)%(VF/Lane),; // (VF/ Lane) ,(VF / Lane)+Stride%(VF/Lane),...,; // (VF / Lane)+(VF*Stride/Lane)%(VF/Lane)}; // Where Lane is the # of lanes in a register:; // VectorSize = 128 => Lane = 1; // VectorSize = 256 => Lane = 2; // For example shuffle pattern for VF 16 register size 256 -> lanes = 2; // {<[0|3|6|1|4|7|2|5]-[8|11|14|9|12|15|10|13]>}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:84,Availability,mask,mask,84,"// setGroupSize sets 'SizeInfo' to the size(number of elements) of group; // inside mask a shuffleMask. A mask contains exactly 3 groups, where; // each group is a monotonically increasing sequence with stride 3.; // For example shuffleMask {0,3,6,1,4,7,2,5} => {3,3,2}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:106,Availability,mask,mask,106,"// setGroupSize sets 'SizeInfo' to the size(number of elements) of group; // inside mask a shuffleMask. A mask contains exactly 3 groups, where; // each group is a monotonically increasing sequence with stride 3.; // For example shuffleMask {0,3,6,1,4,7,2,5} => {3,3,2}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:41,Availability,mask,mask,41,"// DecodePALIGNRMask returns the shuffle mask of vpalign instruction.; // vpalign works according to lanes; // Where Lane is the # of lanes in a register:; // VectorWide = 128 => Lane = 1; // VectorWide = 256 => Lane = 2; // For Lane = 1 shuffle pattern is: {DiffToJump,...,DiffToJump+VF-1}.; // For Lane = 2 shuffle pattern is:; // {DiffToJump,...,VF/2-1,VF,...,DiffToJump+VF-1}.; // Imm variable sets the offset amount. The result of the; // function is stored inside ShuffleMask vector and it built as described in; // the begin of the description. AlignDirection is a boolean that indicates the; // direction of the alignment. (false - align to the ""right"" side while true -; // align to the ""left"" side)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:389,Modifiability,variab,variable,389,"// DecodePALIGNRMask returns the shuffle mask of vpalign instruction.; // vpalign works according to lanes; // Where Lane is the # of lanes in a register:; // VectorWide = 128 => Lane = 1; // VectorWide = 256 => Lane = 2; // For Lane = 1 shuffle pattern is: {DiffToJump,...,DiffToJump+VF-1}.; // For Lane = 2 shuffle pattern is:; // {DiffToJump,...,VF/2-1,VF,...,DiffToJump+VF-1}.; // Imm variable sets the offset amount. The result of the; // function is stored inside ShuffleMask vector and it built as described in; // the begin of the description. AlignDirection is a boolean that indicates the; // direction of the alignment. (false - align to the ""right"" side while true -; // align to the ""left"" side)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:535,Integrability,depend,depends,535,"// concatSubVector - The function rebuilds the data to a correct expected; // order. An assumption(The shape of the matrix) was taken for the; // deinterleaved to work with lane's instructions like 'vpalign' or 'vphuf'.; // This function ensures that the data is built in correct way for the lane; // instructions. Each lane inside the vector is a 128-bit length.; //; // The 'InVec' argument contains the data in increasing order. In InVec[0] You; // can find the first 128 bit data. The number of different lanes inside a; // vector depends on the 'VecElems'.In general, the formula is; // VecElems * type / 128. The size of the array 'InVec' depends and equal to; // 'VecElems'.; // For VecElems = 16; // Invec[0] - |0| Vec[0] - |0|; // Invec[1] - |1| => Vec[1] - |1|; // Invec[2] - |2| Vec[2] - |2|; // For VecElems = 32; // Invec[0] - |0|1| Vec[0] - |0|3|; // Invec[1] - |2|3| => Vec[1] - |1|4|; // Invec[2] - |4|5| Vec[2] - |2|5|; // For VecElems = 64; // Invec[0] - |0|1|2 |3 | Vec[0] - |0|3|6|9 |; // Invec[1] - |4|5|6 |7 | => Vec[1] - |1|4|7|10|; // Invec[2] - |8|9|10|11| Vec[2] - |2|5|8|11|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:645,Integrability,depend,depends,645,"// concatSubVector - The function rebuilds the data to a correct expected; // order. An assumption(The shape of the matrix) was taken for the; // deinterleaved to work with lane's instructions like 'vpalign' or 'vphuf'.; // This function ensures that the data is built in correct way for the lane; // instructions. Each lane inside the vector is a 128-bit length.; //; // The 'InVec' argument contains the data in increasing order. In InVec[0] You; // can find the first 128 bit data. The number of different lanes inside a; // vector depends on the 'VecElems'.In general, the formula is; // VecElems * type / 128. The size of the array 'InVec' depends and equal to; // 'VecElems'.; // For VecElems = 16; // Invec[0] - |0| Vec[0] - |0|; // Invec[1] - |1| => Vec[1] - |1|; // Invec[2] - |2| Vec[2] - |2|; // For VecElems = 32; // Invec[0] - |0|1| Vec[0] - |0|3|; // Invec[1] - |2|3| => Vec[1] - |1|4|; // Invec[2] - |4|5| Vec[2] - |2|5|; // For VecElems = 64; // Invec[0] - |0|1|2 |3 | Vec[0] - |0|3|6|9 |; // Invec[1] - |4|5|6 |7 | => Vec[1] - |1|4|7|10|; // Invec[2] - |8|9|10|11| Vec[2] - |2|5|8|11|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:157,Availability,Mask,MaskResult,157,"// group2Shuffle reorder the shuffle stride back into continuous order.; // For example For VF16 with Mask1 = {0,3,6,9,12,15,2,5,8,11,14,1,4,7,10,13} =>; // MaskResult = {0,11,6,1,12,7,2,13,8,3,14,9,4,15,10,5}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:54,Deployability,continuous,continuous,54,"// group2Shuffle reorder the shuffle stride back into continuous order.; // For example For VF16 with Mask1 = {0,3,6,9,12,15,2,5,8,11,14,1,4,7,10,13} =>; // MaskResult = {0,11,6,1,12,7,2,13,8,3,14,9,4,15,10,5}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:46,Availability,mask,mask,46,// According to the index compute the convert mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:27,Security,access,access,27,// Lowers this interleaved access group into X86-specific; // instructions/intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:3,Performance,Perform,Perform,3,// Perform matrix-transposition in order to compute interleaved; // results by generating some sort of (optimized) target-specific; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:104,Performance,optimiz,optimized,104,// Perform matrix-transposition in order to compute interleaved; // results by generating some sort of (optimized) target-specific; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:105,Integrability,depend,depending,105,"// Lower interleaved load(s) into target specific instructions/; // intrinsics. Lowering sequence varies depending on the vector-types, factor,; // number of shuffles and ISA.; // Currently, lowering is supported for 4x64 bits with Factor = 4 on AVX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:21,Performance,load,load,21,"// Lower interleaved load(s) into target specific instructions/; // intrinsics. Lowering sequence varies depending on the vector-types, factor,; // number of shuffles and ISA.; // Currently, lowering is supported for 4x64 bits with Factor = 4 on AVX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:25,Security,access,access,25,// Create an interleaved access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:25,Security,access,access,25,// Create an interleaved access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,Performance,optimiz,optimize,36,"/// If true, selector should try to optimize for minimum code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:23,Security,access,access,23,/// Disable direct TLS access through segment registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:51,Safety,avoid,avoid,51,"// Utility function to determine whether we should avoid selecting; // immediate forms of instructions for better code size or not.; // At a high level, we'd like to avoid such instructions when; // we have similar constants used within the same basic block; // that can be kept in a register.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:166,Safety,avoid,avoid,166,"// Utility function to determine whether we should avoid selecting; // immediate forms of instructions for better code size or not.; // At a high level, we'd like to avoid such instructions when; // we have similar constants used within the same basic block; // that can be kept in a register.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:37,Performance,optimiz,optimizing,37,// Do not want to hoist if we're not optimizing for size.; // TODO: We'd like to remove this restriction.; // See the comment in X86InstrInfo.td for more info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:21,Modifiability,extend,extended,21,"// If this is a sign-extended 8-bit integer immediate used in an ALU; // instruction, there is probably an opcode encoding to save space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:13,Safety,detect,detect,13,// Helper to detect unneeded and instructions on shift amounts. Called; // from PatFrags in tablegen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:26,Performance,perform,performs,26,/// Address-mode matching performs shift-of-and to and-of-shift; /// reassociation in order to expose more scaled addressing; /// opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:95,Security,expose,expose,95,/// Address-mode matching performs shift-of-and to and-of-shift; /// reassociation in order to expose more scaled addressing; /// opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:52,Performance,load,load,52,// Indicates we should prefer to use a non-temporal load for this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:66,Performance,load,load,66,// Indicates we should prefer to use a non-temporal load for this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:24,Availability,mask,masked,24,// Returns true if this masked compare can be implemented legally with this; // type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:131,Availability,mask,mask,131,// We can get 256-bit 8 element types here without VLX being enabled. When; // this happens we will use 512-bit operations and the mask will not be; // zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:157,Modifiability,extend,extended,157,// We can get 256-bit 8 element types here without VLX being enabled. When; // this happens we will use 512-bit operations and the mask will not be; // zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:51,Availability,mask,mask,51,// Returns true if we can assume the writer of the mask has zero extended it; // for us.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:65,Modifiability,extend,extended,65,// Returns true if we can assume the writer of the mask has zero extended it; // for us.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:104,Availability,mask,mask,104,"// If this is an AND, check if we have a compare on either side. As long as; // one side guarantees the mask is zero extended, the AND will preserve those; // zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:117,Modifiability,extend,extended,117,"// If this is an AND, check if we have a compare on either side. As long as; // one side guarantees the mask is zero extended, the AND will preserve those; // zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:27,Performance,load,loads,27,// Don't fold non-temporal loads if we have an instruction for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:13,Performance,load,load,13,"// If N is a load, do additional profitability checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:92,Energy Efficiency,reduce,reduces,92,"// If the other operand is a 8-bit immediate we should fold the immediate; // instead. This reduces code size.; // e.g.; // movl 4(%esp), %eax; // addl $4, %eax; // vs.; // movl $4, %eax; // addl 4(%esp), %eax; // The former is 2 bytes shorter. In case where the increment is 1, then; // the saving can be 4 bytes (by using incl %eax).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:117,Performance,load,load,117,"// If this is a 64-bit AND with an immediate that fits in 32-bits,; // prefer using the smaller and over folding the load. This is needed to; // make sure immediates created by shrinkAndImmediate are always folded.; // Ideally we would narrow the load during DAG combine and get the; // best of both worlds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:247,Performance,load,load,247,"// If this is a 64-bit AND with an immediate that fits in 32-bits,; // prefer using the smaller and over folding the load. This is needed to; // make sure immediates created by shrinkAndImmediate are always folded.; // Ideally we would narrow the load during DAG combine and get the; // best of both worlds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:128,Performance,load,load,128,"// If this really a zext_inreg that can be represented with a movzx; // instruction, prefer that.; // TODO: We could shrink the load and fold if it is non-volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:99,Modifiability,extend,extended,99,// ADD/SUB with can negate the immediate and use the opposite operation; // to fit 128 into a sign extended 8 bit immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:280,Performance,load,load,280,"// If the other operand is a TLS address, we should fold it instead.; // This produces; // movl %gs:0, %eax; // leal i@NTPOFF(%eax), %eax; // instead of; // movl $i@NTPOFF, %eax; // addl %gs:0, %eax; // if the block also has an access to a second TLS address this will save; // a load.; // FIXME: This is probably also true for non-TLS addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:228,Security,access,access,228,"// If the other operand is a TLS address, we should fold it instead.; // This produces; // movl %gs:0, %eax; // leal i@NTPOFF(%eax), %eax; // instead of; // movl $i@NTPOFF, %eax; // addl %gs:0, %eax; // if the block also has an access to a second TLS address this will save; // a load.; // FIXME: This is probably also true for non-TLS addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:14,Performance,load,load,14,"// Don't fold load if this matches the BTS/BTR/BTC patterns.; // BTS: (or X, (shl 1, n)); // BTR: (and X, (rotl -2, n)); // BTC: (xor X, (shl 1, n))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,Performance,load,load,16,"// Don't fold a load into a shift by immediate. The BMI2 instructions; // support folding a load, but not an immediate. The legacy instructions; // support folding an immediate, but can't fold a load. Folding an; // immediate is preferable to folding a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:92,Performance,load,load,92,"// Don't fold a load into a shift by immediate. The BMI2 instructions; // support folding a load, but not an immediate. The legacy instructions; // support folding an immediate, but can't fold a load. Folding an; // immediate is preferable to folding a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:195,Performance,load,load,195,"// Don't fold a load into a shift by immediate. The BMI2 instructions; // support folding a load, but not an immediate. The legacy instructions; // support folding an immediate, but can't fold a load. Folding an; // immediate is preferable to folding a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:253,Performance,load,load,253,"// Don't fold a load into a shift by immediate. The BMI2 instructions; // support folding a load, but not an immediate. The legacy instructions; // support folding an immediate, but can't fold a load. Folding an; // immediate is preferable to folding a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:21,Performance,load,load,21,// Prevent folding a load if this can implemented with an insert_subreg or; // a move that implicitly zeroes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:48,Availability,mask,masked,48,// Indicates it is profitable to form an AVX512 masked operation. Returning; // false will favor a masked register-register masked move or vblendm and the; // operation will be selected separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:99,Availability,mask,masked,99,// Indicates it is profitable to form an AVX512 masked operation. Returning; // false will favor a masked register-register masked move or vblendm and the; // operation will be selected separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:124,Availability,mask,masked,124,// Indicates it is profitable to form an AVX512 masked operation. Returning; // false will favor a masked register-register masked move or vblendm and the; // operation will be selected separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:61,Performance,load,load,61,/// Replace the original chain operand of the call with; /// load's chain operand and move load below the call's chain operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:91,Performance,load,load,91,/// Replace the original chain operand of the call with; /// load's chain operand and move load below the call's chain operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:37,Performance,load,load,37,"/// Return true if call address is a load and it can be; /// moved below CALLSEQ_START and the chains leading up to the call.; /// Return the CALLSEQ_START by reference as a second output.; /// In the case of a tail call, there isn't a callseq node between the call; /// chain and the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:285,Performance,load,load,285,"/// Return true if call address is a load and it can be; /// moved below CALLSEQ_START and the chains leading up to the call.; /// Return the CALLSEQ_START by reference as a second output.; /// In the case of a tail call, there isn't a callseq node between the call; /// chain and the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:120,Performance,load,load,120,"// The transformation is somewhat dangerous if the call's chain was glued to; // the call. After MoveBelowOrigChain the load is moved between the call and; // the chain, this can create a cycle if the load is not folded. So it is; // *really* important that we are sure the load will be folded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:201,Performance,load,load,201,"// The transformation is somewhat dangerous if the call's chain was glued to; // the call. After MoveBelowOrigChain the load is moved between the call and; // the chain, this can create a cycle if the load is not folded. So it is; // *really* important that we are sure the load will be folded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:274,Performance,load,load,274,"// The transformation is somewhat dangerous if the call's chain was glued to; // the call. After MoveBelowOrigChain the load is moved between the call and; // the chain, this can create a cycle if the load is not folded. So it is; // *really* important that we are sure the load will be folded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:134,Performance,load,load,134,"// Since we are not checking for AA here, conservatively abort if the chain; // writes to memory. It's not safe to move the callee (a load) across a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:57,Safety,abort,abort,57,"// Since we are not checking for AA here, conservatively abort if the chain; // writes to memory. It's not safe to move the callee (a load) across a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:107,Safety,safe,safe,107,"// Since we are not checking for AA here, conservatively abort if the chain; // writes to memory. It's not safe to move the callee (a load) across a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:75,Modifiability,enhance,enhancement,75,"// Preincrement iterator to avoid invalidation issues.; // This is for CET enhancement.; //; // ENDBR32 and ENDBR64 have specific opcodes:; // ENDBR32: F3 0F 1E FB; // ENDBR64: F3 0F 1E FA; // And we want that attackers won’t find unintended ENDBR32/64; // opcode matches in the binary; // Here’s an example:; // If the compiler had to generate asm for the following code:; // a = 0xF30F1EFA; // it could, for example, generate:; // mov 0xF30F1EFA, dword ptr[a]; // In such a case, the binary would include a gadget that starts; // with a fake ENDBR64 opcode. Therefore, we split such generation; // into multiple operations, let it not shows in the binary",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:28,Safety,avoid,avoid,28,"// Preincrement iterator to avoid invalidation issues.; // This is for CET enhancement.; //; // ENDBR32 and ENDBR64 have specific opcodes:; // ENDBR32: F3 0F 1E FB; // ENDBR64: F3 0F 1E FA; // And we want that attackers won’t find unintended ENDBR32/64; // opcode matches in the binary; // Here’s an example:; // If the compiler had to generate asm for the following code:; // a = 0xF30F1EFA; // it could, for example, generate:; // mov 0xF30F1EFA, dword ptr[a]; // In such a case, the binary would include a gadget that starts; // with a fake ENDBR64 opcode. Therefore, we split such generation; // into multiple operations, let it not shows in the binary",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:210,Security,attack,attackers,210,"// Preincrement iterator to avoid invalidation issues.; // This is for CET enhancement.; //; // ENDBR32 and ENDBR64 have specific opcodes:; // ENDBR32: F3 0F 1E FB; // ENDBR64: F3 0F 1E FA; // And we want that attackers won’t find unintended ENDBR32/64; // opcode matches in the binary; // Here’s an example:; // If the compiler had to generate asm for the following code:; // a = 0xF30F1EFA; // it could, for example, generate:; // mov 0xF30F1EFA, dword ptr[a]; // In such a case, the binary would include a gadget that starts; // with a fake ENDBR64 opcode. Therefore, we split such generation; // into multiple operations, let it not shows in the binary",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:103,Testability,test,test,103,"// If this is a target specific AND node with no flag usages, turn it back; // into ISD::AND to enable test instruction matching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:316,Integrability,depend,dependency,316,"// Convert vector increment or decrement to sub/add with an all-ones; // constant:; // add X, <1, 1...> --> sub X, <-1, -1...>; // sub X, <1, 1...> --> add X, <-1, -1...>; // The all-ones vector constant can be materialized using a pcmpeq; // instruction that is commonly recognized as an idiom (has no register; // dependency), so that's better/smaller than loading a splat 1 constant.; //; // But don't do this if it would inhibit a potentially profitable load; // folding opportunity for the other operand. That only occurs with the; // intersection of:; // (1) The other operand (op0) is load foldable.; // (2) The op is an add (otherwise, we are *creating* an add and can still; // load fold the other op).; // (3) The target has AVX (otherwise, we have a destructive add and can't; // load fold the other op without killing the constant op).; // (4) The constant 1 vector has multiple uses (so it is profitable to load; // into a register anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:359,Performance,load,loading,359,"// Convert vector increment or decrement to sub/add with an all-ones; // constant:; // add X, <1, 1...> --> sub X, <-1, -1...>; // sub X, <1, 1...> --> add X, <-1, -1...>; // The all-ones vector constant can be materialized using a pcmpeq; // instruction that is commonly recognized as an idiom (has no register; // dependency), so that's better/smaller than loading a splat 1 constant.; //; // But don't do this if it would inhibit a potentially profitable load; // folding opportunity for the other operand. That only occurs with the; // intersection of:; // (1) The other operand (op0) is load foldable.; // (2) The op is an add (otherwise, we are *creating* an add and can still; // load fold the other op).; // (3) The target has AVX (otherwise, we have a destructive add and can't; // load fold the other op without killing the constant op).; // (4) The constant 1 vector has multiple uses (so it is profitable to load; // into a register anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:458,Performance,load,load,458,"// Convert vector increment or decrement to sub/add with an all-ones; // constant:; // add X, <1, 1...> --> sub X, <-1, -1...>; // sub X, <1, 1...> --> add X, <-1, -1...>; // The all-ones vector constant can be materialized using a pcmpeq; // instruction that is commonly recognized as an idiom (has no register; // dependency), so that's better/smaller than loading a splat 1 constant.; //; // But don't do this if it would inhibit a potentially profitable load; // folding opportunity for the other operand. That only occurs with the; // intersection of:; // (1) The other operand (op0) is load foldable.; // (2) The op is an add (otherwise, we are *creating* an add and can still; // load fold the other op).; // (3) The target has AVX (otherwise, we have a destructive add and can't; // load fold the other op without killing the constant op).; // (4) The constant 1 vector has multiple uses (so it is profitable to load; // into a register anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:592,Performance,load,load,592,"// Convert vector increment or decrement to sub/add with an all-ones; // constant:; // add X, <1, 1...> --> sub X, <-1, -1...>; // sub X, <1, 1...> --> add X, <-1, -1...>; // The all-ones vector constant can be materialized using a pcmpeq; // instruction that is commonly recognized as an idiom (has no register; // dependency), so that's better/smaller than loading a splat 1 constant.; //; // But don't do this if it would inhibit a potentially profitable load; // folding opportunity for the other operand. That only occurs with the; // intersection of:; // (1) The other operand (op0) is load foldable.; // (2) The op is an add (otherwise, we are *creating* an add and can still; // load fold the other op).; // (3) The target has AVX (otherwise, we have a destructive add and can't; // load fold the other op without killing the constant op).; // (4) The constant 1 vector has multiple uses (so it is profitable to load; // into a register anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:687,Performance,load,load,687,"// Convert vector increment or decrement to sub/add with an all-ones; // constant:; // add X, <1, 1...> --> sub X, <-1, -1...>; // sub X, <1, 1...> --> add X, <-1, -1...>; // The all-ones vector constant can be materialized using a pcmpeq; // instruction that is commonly recognized as an idiom (has no register; // dependency), so that's better/smaller than loading a splat 1 constant.; //; // But don't do this if it would inhibit a potentially profitable load; // folding opportunity for the other operand. That only occurs with the; // intersection of:; // (1) The other operand (op0) is load foldable.; // (2) The op is an add (otherwise, we are *creating* an add and can still; // load fold the other op).; // (3) The target has AVX (otherwise, we have a destructive add and can't; // load fold the other op without killing the constant op).; // (4) The constant 1 vector has multiple uses (so it is profitable to load; // into a register anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:791,Performance,load,load,791,"// Convert vector increment or decrement to sub/add with an all-ones; // constant:; // add X, <1, 1...> --> sub X, <-1, -1...>; // sub X, <1, 1...> --> add X, <-1, -1...>; // The all-ones vector constant can be materialized using a pcmpeq; // instruction that is commonly recognized as an idiom (has no register; // dependency), so that's better/smaller than loading a splat 1 constant.; //; // But don't do this if it would inhibit a potentially profitable load; // folding opportunity for the other operand. That only occurs with the; // intersection of:; // (1) The other operand (op0) is load foldable.; // (2) The op is an add (otherwise, we are *creating* an add and can still; // load fold the other op).; // (3) The target has AVX (otherwise, we have a destructive add and can't; // load fold the other op without killing the constant op).; // (4) The constant 1 vector has multiple uses (so it is profitable to load; // into a register anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:920,Performance,load,load,920,"// Convert vector increment or decrement to sub/add with an all-ones; // constant:; // add X, <1, 1...> --> sub X, <-1, -1...>; // sub X, <1, 1...> --> add X, <-1, -1...>; // The all-ones vector constant can be materialized using a pcmpeq; // instruction that is commonly recognized as an idiom (has no register; // dependency), so that's better/smaller than loading a splat 1 constant.; //; // But don't do this if it would inhibit a potentially profitable load; // folding opportunity for the other operand. That only occurs with the; // intersection of:; // (1) The other operand (op0) is load foldable.; // (2) The op is an add (otherwise, we are *creating* an add and can still; // load fold the other op).; // (3) The target has AVX (otherwise, we have a destructive add and can't; // load fold the other op without killing the constant op).; // (4) The constant 1 vector has multiple uses (so it is profitable to load; // into a register anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:24,Performance,load,load,24,"// If this is a XMM/YMM load of the same lower bits as another YMM/ZMM; // load, then just extract the lower subvector and avoid the second load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:75,Performance,load,load,75,"// If this is a XMM/YMM load of the same lower bits as another YMM/ZMM; // load, then just extract the lower subvector and avoid the second load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:140,Performance,load,load,140,"// If this is a XMM/YMM load of the same lower bits as another YMM/ZMM; // load, then just extract the lower subvector and avoid the second load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:123,Safety,avoid,avoid,123,"// If this is a XMM/YMM load of the same lower bits as another YMM/ZMM; // load, then just extract the lower subvector and avoid the second load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:28,Availability,mask,mask,28,// Replace VSELECT with non-mask conditions with with BLENDV/VPTERNLOG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:22,Modifiability,extend,extend,22,// Replace vector any extend with the zero extend equivalents so we don't; // need 2 sets of patterns. Ignore vXi1 extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:43,Modifiability,extend,extend,43,// Replace vector any extend with the zero extend equivalents so we don't; // need 2 sets of patterns. Ignore vXi1 extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:42,Energy Efficiency,reduce,reduce,42,// Widen scalar fp logic ops to vector to reduce isel patterns.; // FIXME: Can we do this during lowering/combine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Testability,log,logic,19,// Widen scalar fp logic ops to vector to reduce isel patterns.; // FIXME: Can we do this during lowering/combine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:45,Performance,load,load,45,// Only do this when the target can fold the load into the call or; // jmp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:33,Performance,load,load,33,/// Also try moving call address load from outside callseq_start to just; /// before the call to allow it to be folded.; ///; /// [Load chain]; /// ^; /// |; /// [Load]; /// ^ ^; /// | |; /// / \--; /// / |; ///[CALLSEQ_START] |; /// ^ |; /// | |; /// [LOAD/C2Reg] |; /// | |; /// \ /; /// \ /; /// [CALL],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:131,Performance,Load,Load,131,/// Also try moving call address load from outside callseq_start to just; /// before the call to allow it to be folded.; ///; /// [Load chain]; /// ^; /// |; /// [Load]; /// ^ ^; /// | |; /// / \--; /// / |; ///[CALLSEQ_START] |; /// ^ |; /// | |; /// [LOAD/C2Reg] |; /// | |; /// \ /; /// \ /; /// [CALL],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:163,Performance,Load,Load,163,/// Also try moving call address load from outside callseq_start to just; /// before the call to allow it to be folded.; ///; /// [Load chain]; /// ^; /// |; /// [Load]; /// ^ ^; /// | |; /// / \--; /// / |; ///[CALLSEQ_START] |; /// ^ |; /// | |; /// [LOAD/C2Reg] |; /// | |; /// \ /; /// \ /; /// [CALL],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:253,Performance,LOAD,LOAD,253,/// Also try moving call address load from outside callseq_start to just; /// before the call to allow it to be folded.; ///; /// [Load chain]; /// ^; /// |; /// [Load]; /// ^ ^; /// | |; /// / \--; /// / |; ///[CALLSEQ_START] |; /// ^ |; /// | |; /// [LOAD/C2Reg] |; /// | |; /// \ /; /// \ /; /// [CALL],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:81,Performance,load,load,81,"// Lower fpround and fpextend nodes that target the FP stack to be store and; // load to the stack. This is a gross hack. We would like to simply mark; // these as being illegal, but when we do that, legalize produces these when; // it expands calls, then expands these in the same legalize pass. We would; // like dag combine to be able to hack on these between the call expansion; // and the node legalization. As such this pass basically does ""really; // late"" legalization of these inline with the X86 isel pass.; // FIXME: This should only happen when not compiled with -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:139,Usability,simpl,simply,139,"// Lower fpround and fpextend nodes that target the FP stack to be store and; // load to the stack. This is a gross hack. We would like to simply mark; // these as being illegal, but when we do that, legalize produces these when; // it expands calls, then expands these in the same legalize pass. We would; // like dag combine to be able to hack on these between the call expansion; // and the node legalization. As such this pass basically does ""really; // late"" legalization of these inline with the X86 isel pass.; // FIXME: This should only happen when not compiled with -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:136,Performance,load,loads,136,"// Here we could have an FP stack truncation or an FPStack <-> SSE convert.; // FPStack has extload and truncstore. SSE can fold direct loads into other; // operations. Based on this, decide what we want to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Performance,optimiz,optimize,10,// FIXME: optimize the case where the src/dest is a load or store?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:52,Performance,load,load,52,// FIXME: optimize the case where the src/dest is a load or store?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:227,Safety,avoid,avoid,227,"// We're about to replace all uses of the FP_ROUND/FP_EXTEND with the; // extload we created. This will cause general havok on the dag because; // anything below the conversion could be folded into other existing nodes.; // To avoid invalidating 'I', back it up to the convert node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:136,Performance,load,loads,136,"// Here we could have an FP stack truncation or an FPStack <-> SSE convert.; // FPStack has extload and truncstore. SSE can fold direct loads into other; // operations. Based on this, decide what we want to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Performance,optimiz,optimize,10,"// FIXME: optimize the case where the src/dest is a load or store?; //Since the operation is StrictFP, use the preexisting chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:52,Performance,load,load,52,"// FIXME: optimize the case where the src/dest is a load or store?; //Since the operation is StrictFP, use the preexisting chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:227,Safety,avoid,avoid,227,"// We're about to replace all uses of the FP_ROUND/FP_EXTEND with the; // extload we created. This will cause general havok on the dag because; // anything below the conversion could be folded into other existing nodes.; // To avoid invalidating 'I', back it up to the convert node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:14,Availability,redundant,redundant,14,// Look for a redundant movzx/movsx that can occur after an 8-bit divrem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:14,Safety,redund,redundant,14,// Look for a redundant movzx/movsx that can occur after an 8-bit divrem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:48,Modifiability,extend,extend,48,// We need to be extracting the lower bit of an extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:20,Modifiability,extend,extend,20,// If we had a sign extend from 8 to 64 bits. We still need to go from 32; // to 64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:23,Modifiability,extend,extend,23,// Ok we can drop this extend and just use the original extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:56,Modifiability,extend,extend,56,// Ok we can drop this extend and just use the original extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:85,Modifiability,Rewrite,Rewrite,85,// Look for a TESTrr+ANDrr pattern where both operands of the test are; // the same. Rewrite to remove the AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:14,Testability,TEST,TESTrr,14,// Look for a TESTrr+ANDrr pattern where both operands of the test are; // the same. Rewrite to remove the AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:62,Testability,test,test,62,// Look for a TESTrr+ANDrr pattern where both operands of the test are; // the same. Rewrite to remove the AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:145,Availability,mask,masked,145,// Look for a KAND+KORTEST and turn it into KTEST if only the zero flag is; // used. We're doing this late so we can prefer to fold the AND into masked; // comparisons. Doing that can be better for the live range of the mask; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:220,Availability,mask,mask,220,// Look for a KAND+KORTEST and turn it into KTEST if only the zero flag is; // used. We're doing this late so we can prefer to fold the AND into masked; // comparisons. Doing that can be better for the live range of the mask; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:416,Safety,safe,safe,416,"// On 64-bit platforms, we can run into an issue where a frame index; // includes a displacement that, when added to the explicit displacement,; // will overflow the displacement field. Assuming that the frame index; // displacement fits into a 31-bit integer (which is only slightly more; // aggressive than the current fundamental assumption that it fits into; // a 32-bit integer), a 31-bit disp should always be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:98,Safety,unsafe,unsafe,98,"// In addition to the checks required for a register base, check that; // we do not try to use an unsafe Disp with a frame index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:65,Modifiability,extend,extended,65,"// In ILP32 (x32) mode, pointers are 32 bits and need to be zero-extended to; // 64 bits. Instructions with 32-bit register addresses perform this zero; // extension for us and we can safely ignore the high bits of Offset.; // Instructions with only a 32-bit immediate address do not, though: they; // sign extend instead. This means only address the low 2GB of address space; // is directly addressable, we need indirect addressing for the high 2GB of; // address space.; // TODO: Some of the earlier checks may be relaxed for ILP32 mode as the; // implicit zero extension of instructions would cover up any problem.; // However, we have asserts elsewhere that get triggered if we do, so keep; // the checks for now.; // TODO: We would actually be able to accept these, as well as the same; // addresses in LP64 mode, by adding the EIZ pseudo-register as an operand; // to get an address size override to be emitted. However, this; // pseudo-register is not part of any register class and therefore causes; // MIR verification to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:307,Modifiability,extend,extend,307,"// In ILP32 (x32) mode, pointers are 32 bits and need to be zero-extended to; // 64 bits. Instructions with 32-bit register addresses perform this zero; // extension for us and we can safely ignore the high bits of Offset.; // Instructions with only a 32-bit immediate address do not, though: they; // sign extend instead. This means only address the low 2GB of address space; // is directly addressable, we need indirect addressing for the high 2GB of; // address space.; // TODO: Some of the earlier checks may be relaxed for ILP32 mode as the; // implicit zero extension of instructions would cover up any problem.; // However, we have asserts elsewhere that get triggered if we do, so keep; // the checks for now.; // TODO: We would actually be able to accept these, as well as the same; // addresses in LP64 mode, by adding the EIZ pseudo-register as an operand; // to get an address size override to be emitted. However, this; // pseudo-register is not part of any register class and therefore causes; // MIR verification to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:134,Performance,perform,perform,134,"// In ILP32 (x32) mode, pointers are 32 bits and need to be zero-extended to; // 64 bits. Instructions with 32-bit register addresses perform this zero; // extension for us and we can safely ignore the high bits of Offset.; // Instructions with only a 32-bit immediate address do not, though: they; // sign extend instead. This means only address the low 2GB of address space; // is directly addressable, we need indirect addressing for the high 2GB of; // address space.; // TODO: Some of the earlier checks may be relaxed for ILP32 mode as the; // implicit zero extension of instructions would cover up any problem.; // However, we have asserts elsewhere that get triggered if we do, so keep; // the checks for now.; // TODO: We would actually be able to accept these, as well as the same; // addresses in LP64 mode, by adding the EIZ pseudo-register as an operand; // to get an address size override to be emitted. However, this; // pseudo-register is not part of any register class and therefore causes; // MIR verification to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:184,Safety,safe,safely,184,"// In ILP32 (x32) mode, pointers are 32 bits and need to be zero-extended to; // 64 bits. Instructions with 32-bit register addresses perform this zero; // extension for us and we can safely ignore the high bits of Offset.; // Instructions with only a 32-bit immediate address do not, though: they; // sign extend instead. This means only address the low 2GB of address space; // is directly addressable, we need indirect addressing for the high 2GB of; // address space.; // TODO: Some of the earlier checks may be relaxed for ILP32 mode as the; // implicit zero extension of instructions would cover up any problem.; // However, we have asserts elsewhere that get triggered if we do, so keep; // the checks for now.; // TODO: We would actually be able to accept these, as well as the same; // addresses in LP64 mode, by adding the EIZ pseudo-register as an operand; // to get an address size override to be emitted. However, this; // pseudo-register is not part of any register class and therefore causes; // MIR verification to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:639,Testability,assert,asserts,639,"// In ILP32 (x32) mode, pointers are 32 bits and need to be zero-extended to; // 64 bits. Instructions with 32-bit register addresses perform this zero; // extension for us and we can safely ignore the high bits of Offset.; // Instructions with only a 32-bit immediate address do not, though: they; // sign extend instead. This means only address the low 2GB of address space; // is directly addressable, we need indirect addressing for the high 2GB of; // address space.; // TODO: Some of the earlier checks may be relaxed for ILP32 mode as the; // implicit zero extension of instructions would cover up any problem.; // However, we have asserts elsewhere that get triggered if we do, so keep; // the checks for now.; // TODO: We would actually be able to accept these, as well as the same; // addresses in LP64 mode, by adding the EIZ pseudo-register as an operand; // to get an address size override to be emitted. However, this; // pseudo-register is not part of any register class and therefore causes; // MIR verification to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:326,Modifiability,extend,extended,326,"// load gs:0 -> GS segment register.; // load fs:0 -> FS segment register.; //; // This optimization is generally valid because the GNU TLS model defines that; // gs:0 (or fs:0 on X86-64) contains its own address. However, for X86-64 mode; // with 32-bit registers, as we get in ILP32 mode, those registers are first; // zero-extended to 64 bits and then added it to the base address, which gives; // unwanted results when the register holds a negative value.; // For more information see http://people.redhat.com/drepper/tls.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Performance,load,load,3,"// load gs:0 -> GS segment register.; // load fs:0 -> FS segment register.; //; // This optimization is generally valid because the GNU TLS model defines that; // gs:0 (or fs:0 on X86-64) contains its own address. However, for X86-64 mode; // with 32-bit registers, as we get in ILP32 mode, those registers are first; // zero-extended to 64 bits and then added it to the base address, which gives; // unwanted results when the register holds a negative value.; // For more information see http://people.redhat.com/drepper/tls.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:41,Performance,load,load,41,"// load gs:0 -> GS segment register.; // load fs:0 -> FS segment register.; //; // This optimization is generally valid because the GNU TLS model defines that; // gs:0 (or fs:0 on X86-64) contains its own address. However, for X86-64 mode; // with 32-bit registers, as we get in ILP32 mode, those registers are first; // zero-extended to 64 bits and then added it to the base address, which gives; // unwanted results when the register holds a negative value.; // For more information see http://people.redhat.com/drepper/tls.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:88,Performance,optimiz,optimization,88,"// load gs:0 -> GS segment register.; // load fs:0 -> FS segment register.; //; // This optimization is generally valid because the GNU TLS model defines that; // gs:0 (or fs:0 on X86-64) contains its own address. However, for X86-64 mode; // with 32-bit registers, as we get in ILP32 mode, those registers are first; // zero-extended to 64 bits and then added it to the base address, which gives; // unwanted results when the register holds a negative value.; // For more information see http://people.redhat.com/drepper/tls.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:128,Availability,down,down,128,"/// Try to match X86ISD::Wrapper and X86ISD::WrapperRIP nodes into an addressing; /// mode. These wrap things that will resolve down into a symbol reference.; /// If no match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:25,Integrability,Wrap,Wrapper,25,"/// Try to match X86ISD::Wrapper and X86ISD::WrapperRIP nodes into an addressing; /// mode. These wrap things that will resolve down into a symbol reference.; /// If no match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:45,Integrability,Wrap,WrapperRIP,45,"/// Try to match X86ISD::Wrapper and X86ISD::WrapperRIP nodes into an addressing; /// mode. These wrap things that will resolve down into a symbol reference.; /// If no match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:98,Integrability,wrap,wrap,98,"/// Try to match X86ISD::Wrapper and X86ISD::WrapperRIP nodes into an addressing; /// mode. These wrap things that will resolve down into a symbol reference.; /// If no match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:171,Integrability,wrap,wrappers,171,"// We can't use an addressing mode in the 64-bit large code model.; // Global TLS addressing is an exception. In the medium code model,; // we use can use a mode when RIP wrappers are present.; // That signifies access to globals that are known to be ""near"",; // such as the GOT itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:212,Security,access,access,212,"// We can't use an addressing mode in the 64-bit large code model.; // Global TLS addressing is an exception. In the medium code model,; // we use can use a mode when RIP wrappers are present.; // That signifies access to globals that are known to be ""near"",; // such as the GOT itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:52,Safety,safe,safe,52,// Commit the changes now that we know this fold is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:52,Performance,load,load,52,"// Post-processing: Make a second attempt to fold a load, if we now know; // that there will not be any other register. This is only performed for; // 64-bit ILP32 mode since 32-bit mode and 64-bit LP64 mode will have folded; // any foldable load the first time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:133,Performance,perform,performed,133,"// Post-processing: Make a second attempt to fold a load, if we now know; // that there will not be any other register. This is only performed for; // 64-bit ILP32 mode since 32-bit mode and 64-bit LP64 mode will have folded; // any foldable load the first time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:242,Performance,load,load,242,"// Post-processing: Make a second attempt to fold a load, if we now know; // that there will not be any other register. This is only performed for; // 64-bit ILP32 mode since 32-bit mode and 64-bit LP64 mode will have folded; // any foldable load the first time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:97,Safety,avoid,avoids,97,"// Post-processing: Convert lea(,%reg,2) to lea(%reg,%reg), which has; // a smaller encoding and avoids a scaled-index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:279,Integrability,depend,depend,279,"// Insert a node into the DAG at least before the Pos node's position. This; // will reposition the node as needed, and will assign it a node ID that is <=; // the Pos node's ID. Note that this does *not* preserve the uniqueness of node; // IDs! The selection DAG must no longer depend on their uniqueness when this; // is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:224,Performance,perform,performed,224,"// Transform ""(X >> (8-C1)) & (0xff << C1)"" to ""((X >> 8) & 0xff) << C1"" if; // safe. This allows us to convert the shift and and into an h-register; // extract and a scaled index. Returns false if the simplification is; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:80,Safety,safe,safe,80,"// Transform ""(X >> (8-C1)) & (0xff << C1)"" to ""((X >> 8) & 0xff) << C1"" if; // safe. This allows us to convert the shift and and into an h-register; // extract and a scaled index. Returns false if the simplification is; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:202,Usability,simpl,simplification,202,"// Transform ""(X >> (8-C1)) & (0xff << C1)"" to ""((X >> 8) & 0xff) << C1"" if; // safe. This allows us to convert the shift and and into an h-register; // extract and a scaled index. Returns false if the simplification is; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:60,Safety,safe,safe,60,"// Transforms ""(X << C1) & C2"" to ""(X & (C2>>C1)) << C1"" if safe and if this; // allows us to fold the shift into this addressing mode. Returns false if the; // transform succeeded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,Availability,mask,mask,16,// Use a signed mask so that shifting right will insert sign bits. These; // bits will be removed when we shift the result left so it doesn't matter; // what we use. This might allow a smaller immediate encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:139,Modifiability,extend,extended,139,"// If we have an any_extend feeding the AND, look through it to see if there; // is a shift behind it. But only if the AND doesn't use the extended bits.; // FIXME: Generalize this to other ANY_EXTEND than i32 to i64?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:46,Availability,mask,masked,46,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:70,Availability,mask,mask,70,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:256,Availability,MASK,MASK,256,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:757,Availability,mask,mask,757,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:779,Availability,mask,mask,779,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:886,Availability,mask,mask,886,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:98,Modifiability,extend,extending,98,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:29,Safety,detect,detect,29,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:122,Usability,undo,undoing,122,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:26,Availability,mask,mask,26,// We need to ensure that mask is a continuous run of bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,Deployability,continuous,continuous,36,// We need to ensure that mask is a continuous run of bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:98,Availability,mask,mask,98,// The amount of shift we're trying to fit into the addressing mode is taken; // from the shifted mask index (number of trailing zeros of the mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:142,Availability,mask,mask,142,// The amount of shift we're trying to fit into the addressing mode is taken; // from the shifted mask index (number of trailing zeros of the mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:46,Availability,mask,mask,46,"// There is nothing we can do here unless the mask is removing some bits.; // Also, the addressing mode can only represent shifts of 1, 2, or 3 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:32,Availability,down,down,32,// Scale the leading zero count down based on the actual size of the value.; // Also scale it down based on the size of the shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:94,Availability,down,down,94,// Scale the leading zero count down based on the actual size of the value.; // Also scale it down based on the size of the shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:41,Availability,mask,masked,41,"// The final check is to ensure that any masked out high bits of X are; // already known to be zero. Otherwise, the mask has a semantic impact; // other than masking out a couple of low bits. Unfortunately, because of; // the mask, zero extensions will be removed from operands in some cases.; // This code works extra hard to look through extensions because we can; // replace them with zero extensions cheaply if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:116,Availability,mask,mask,116,"// The final check is to ensure that any masked out high bits of X are; // already known to be zero. Otherwise, the mask has a semantic impact; // other than masking out a couple of low bits. Unfortunately, because of; // the mask, zero extensions will be removed from operands in some cases.; // This code works extra hard to look through extensions because we can; // replace them with zero extensions cheaply if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:158,Availability,mask,masking,158,"// The final check is to ensure that any masked out high bits of X are; // already known to be zero. Otherwise, the mask has a semantic impact; // other than masking out a couple of low bits. Unfortunately, because of; // the mask, zero extensions will be removed from operands in some cases.; // This code works extra hard to look through extensions because we can; // replace them with zero extensions cheaply if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:226,Availability,mask,mask,226,"// The final check is to ensure that any masked out high bits of X are; // already known to be zero. Otherwise, the mask has a semantic impact; // other than masking out a couple of low bits. Unfortunately, because of; // the mask, zero extensions will be removed from operands in some cases.; // This code works extra hard to look through extensions because we can; // replace them with zero extensions cheaply if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:37,Modifiability,extend,extend,37,"// Assume that we'll replace the any-extend with a zero-extend, and; // narrow the search to the extended value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:56,Modifiability,extend,extend,56,"// Assume that we'll replace the any-extend with a zero-extend, and; // narrow the search to the extended value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:97,Modifiability,extend,extended,97,"// Assume that we'll replace the any-extend with a zero-extend, and; // narrow the search to the extended value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:30,Availability,MASK,MASK,30,"// Transform ""(X >> SHIFT) & (MASK << C1)"" to; // ""((X >> (SHIFT + C1)) & (MASK)) << C1"". Everything before the SHL will be; // matched to a BEXTR later. Returns false if the simplification is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:75,Availability,MASK,MASK,75,"// Transform ""(X >> SHIFT) & (MASK << C1)"" to; // ""((X >> (SHIFT + C1)) & (MASK)) << C1"". Everything before the SHL will be; // matched to a BEXTR later. Returns false if the simplification is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:193,Performance,perform,performed,193,"// Transform ""(X >> SHIFT) & (MASK << C1)"" to; // ""((X >> (SHIFT + C1)) & (MASK)) << C1"". Everything before the SHL will be; // matched to a BEXTR later. Returns false if the simplification is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:175,Usability,simpl,simplification,175,"// Transform ""(X >> SHIFT) & (MASK << C1)"" to; // ""((X >> (SHIFT + C1)) & (MASK)) << C1"". Everything before the SHL will be; // matched to a BEXTR later. Returns false if the simplification is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:26,Availability,mask,mask,26,// We need to ensure that mask is a continuous run of bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,Deployability,continuous,continuous,36,// We need to ensure that mask is a continuous run of bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:98,Availability,mask,mask,98,// The amount of shift we're trying to fit into the addressing mode is taken; // from the shifted mask index (number of trailing zeros of the mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:142,Availability,mask,mask,142,// The amount of shift we're trying to fit into the addressing mode is taken; // from the shifted mask index (number of trailing zeros of the mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:46,Availability,mask,mask,46,"// There is nothing we can do here unless the mask is removing some bits.; // Also, the addressing mode can only represent shifts of 1, 2, or 3 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,Availability,mask,masks,36,"// TODO: Handle extensions, shifted masks etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:92,Performance,optimiz,optimizations,92,// We only handle up to 64-bit values here as those are what matter for; // addressing mode optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:7,Availability,mask,mask,7,"// The mask used for the transform is expected to be post-shift, but we; // found the shift first so just apply the shift to the mask before passing; // it down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:129,Availability,mask,mask,129,"// The mask used for the transform is expected to be post-shift, but we; // found the shift first so just apply the shift to the mask before passing; // it down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:156,Availability,down,down,156,"// The mask used for the transform is expected to be post-shift, but we; // found the shift first so just apply the shift to the mask before passing; // it down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,"// Try to fold the mask and shift into the scale, and return false if we; // succeed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:291,Safety,avoid,avoids,291,"// Given A-B, if A can be completely folded into the address and; // the index field with the index field unused, use -B as the index.; // This is a win if a has multiple parts that can be folded into; // the address. Also, this saves a mov if the base register has; // other uses, since it avoids a two-address sub instruction, however; // it costs an additional mov if the index register has other uses.; // Add an artificial use to this node so that we can keep track of; // it if it gets CSE'd with a different node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Testability,Test,Test,3,// Test if the LHS of the sub can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Testability,Test,Test,3,// Test if the index field is free for use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:108,Safety,avoid,avoid,108,"// Ok, the transformation is legal and appears profitable. Go for it.; // Negation will be emitted later to avoid creating dangling nodes if this; // was an unprofitable LEA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Performance,Perform,Perform,3,// Perform some heroic transforms on an and of a constant-count shift; // with a constant to enable use of the scaled offset field.; // Scale must not be used already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:92,Performance,optimiz,optimizations,92,// We only handle up to 64-bit values here as those are what matter for; // addressing mode optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,// Try to fold the mask and shift into an extract and scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,// Try to fold the mask and shift directly into the scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,// Try to fold the mask and shift into BEXTR and scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,// Try to swap the mask and shift to place shifts which can be done as; // a scale on the outside of the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:105,Availability,mask,mask,105,// Try to swap the mask and shift to place shifts which can be done as; // a scale on the outside of the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,Availability,mask,mask,16,"// Peek through mask: zext(and(shl(x,c1),c2))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:88,Safety,safe,safe,88,// The narrow shift must only shift out zero bits (it must be 'nuw').; // That makes it safe to widen to the destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,// Try to fold the mask and shift into an extract and scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,// Try to fold the mask and shift directly into the scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,// Try to fold the mask and shift into BEXTR and scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:106,Performance,perform,performed,106,"// Attempt to match index patterns, as long as we're not relying on implicit; // sign-extension, which is performed BEFORE scale.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:270,Performance,load,load,270,"/// Returns true if it is able to pattern match an addressing mode.; /// It returns the operands which make up the maximal addressing mode it can; /// match by reference.; ///; /// Parent is the parent node of the addr operand that is being matched. It; /// is always a load, store, atomic node, or null. It is only null when; /// checking memory operands for inline asm nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:13,Performance,load,loads,13,"// unaligned loads, fixme",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:85,Usability,simpl,simple,85,"// Don't match just leal(,%reg,2). It's cheaper to do addl %reg, %reg, or with; // a simple shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:213,Deployability,pipeline,pipeline,213,"// Heuristic: try harder to form an LEA from ADD if the operands set flags.; // Unlike ADD, LEA does not affect flags, so we will be less likely to require; // duplicating flag-producing instructions later in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,Safety,safe,safely,36,"/* TODO: These opcodes can be added safely, but we may want to justify; their inclusion for different reasons (better for reg-alloc).; case X86ISD::OR:; case X86ISD::XOR:; case X86ISD::AND:; */; // Value 1 is the flag output of the node - verify it's not dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:54,Performance,load,load,54,// TODO: We might want to factor in whether there's a load folding; // opportunity for the math op that disappears with LEA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:112,Modifiability,extend,extended,112,"// In the kernel code model, globals are in the negative 2GB of the address; // space, so globals can be a sign extended 32-bit immediate.; // In other code models, small globals are in the low 2GB of the address; // space, so sign extending them is equivalent to zero extending them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:232,Modifiability,extend,extending,232,"// In the kernel code model, globals are in the negative 2GB of the address; // space, so globals can be a sign extended 32-bit immediate.; // In other code models, small globals are in the low 2GB of the address; // space, so sign extending them is equivalent to zero extending them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:269,Modifiability,extend,extending,269,"// In the kernel code model, globals are in the negative 2GB of the address; // space, so globals can be a sign extended 32-bit immediate.; // In other code models, small globals are in the low 2GB of the address; // space, so sign extending them is equivalent to zero extending them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:4,Testability,Test,Test,4,/// Test whether the given X86ISD::CMP node has any users that use a flag; /// other than ZF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:4,Testability,Test,Test,4,/// Test whether the given X86ISD::CMP node has any uses which require the SF; /// flag to be accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:4,Testability,Test,Test,4,/// Test whether the given node which sets flags has any uses which require the; /// CF flag to be accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:87,Performance,load,load,87,/// Check whether or not the chain ending in StoreNode is suitable for doing; /// the {load; op; store} to modify transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:20,Modifiability,extend,extending,20,// Is the store non-extending and non-indexed?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:29,Modifiability,extend,extending,29,// Is the stored value a non-extending and non-indexed load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:55,Performance,load,load,55,// Is the stored value a non-extending and non-indexed load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Performance,Load,LoadNode,10,// Return LoadNode by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:33,Performance,load,loaded,33,// Is store the only read of the loaded value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:47,Performance,load,load,47,// Is the address of the store the same as the load?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:191,Availability,down,down,191,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:112,Integrability,depend,dependencies,112,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:155,Integrability,depend,dependencies,155,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:173,Integrability,Depend,Dependencies,173,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:445,Integrability,depend,dependences,445,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:580,Integrability,depend,dependencies,580,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:20,Performance,Load,Load-Op-Store,20,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:546,Safety,safe,safe,546,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:8,Performance,Load,Load,8,"// Drop Load, but keep its chain. No cycle check necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,Performance,Load,Load,16,// Check (a) if Load is a predecessor to Xn + Yn,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:22,Performance,load,load,22,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the EFLAGS on the original operation are used.; //; // To move this to tablegen, we'll need to improve tablegen to allow flags to; // be transferred from a node in the pattern to the result node, probably with; // a new keyword. For example, we have this; // def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), ""dec{q}\t$dst"",; // [(store (add (loadi64 addr:$dst), -1), addr:$dst),; // (implicit EFLAGS)]>;; // but maybe need something like this; // def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), ""dec{q}\t$dst"",; // [(store (add (loadi64 addr:$dst), -1), addr:$dst),; // (transferrable EFLAGS)]>;; //; // Until then, we manually fold these and instruction select the operation; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:64,Usability,simpl,simple,64,"// Change a chain of {load; op; store} of the same value into a simple op; // through memory of that value, if the uses of the modified value and its; // address are suitable.; //; // The tablegen pattern memory operand pattern is currently not able to match; // the case where the EFLAGS on the original operation are used.; //; // To move this to tablegen, we'll need to improve tablegen to allow flags to; // be transferred from a node in the pattern to the result node, probably with; // a new keyword. For example, we have this; // def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), ""dec{q}\t$dst"",; // [(store (add (loadi64 addr:$dst), -1), addr:$dst),; // (implicit EFLAGS)]>;; // but maybe need something like this; // def DEC64m : RI<0xFF, MRM1m, (outs), (ins i64mem:$dst), ""dec{q}\t$dst"",; // [(store (add (loadi64 addr:$dst), -1), addr:$dst),; // (transferrable EFLAGS)]>;; //; // Until then, we manually fold these and instruction select the operation; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update Load Chain uses as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Performance,Load,Load,10,// Update Load Chain uses as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:25,Availability,Mask,Mask,25,// See if this is an X & Mask that we can match to BEXTR/BZHI.; // Where Mask is one of the following patterns:; // a) x & (1 << nbits) - 1; // b) x & ~(-1 << nbits); // c) x & (-1 >> (32 - y)); // d) x << (32 - y) >> (32 - y); // e) (1 << nbits) - 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:73,Availability,Mask,Mask,73,// See if this is an X & Mask that we can match to BEXTR/BZHI.; // Where Mask is one of the following patterns:; // a) x & (1 << nbits) - 1; // b) x & ~(-1 << nbits); // c) x & (-1 >> (32 - y)); // d) x << (32 - y) >> (32 - y); // e) (1 << nbits) - 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:7,Availability,mask,mask,7,// The mask itself may be truncated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:101,Availability,mask,mask,101,"// Pattern c. is non-canonical, and is expanded into pattern d. iff there; // is no extra use of the mask. Clearly, there was one since we are here.; // But at the same time, if we need to negate the shift amount,; // then we don't want the mask to stick around, else it's unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:241,Availability,mask,mask,241,"// Pattern c. is non-canonical, and is expanded into pattern d. iff there; // is no extra use of the mask. Clearly, there was one since we are here.; // But at the same time, if we need to negate the shift amount,; // then we don't want the mask to stick around, else it's unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:107,Usability,Clear,Clearly,107,"// Pattern c. is non-canonical, and is expanded into pattern d. iff there; // is no extra use of the mask. Clearly, there was one since we are here.; // But at the same time, if we need to negate the shift amount,; // then we don't want the mask to stick around, else it's unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:55,Usability,clear,cleared,55,"// We might have matched the amount of high bits to be cleared,; // but we want the amount of low bits to be kept, so negate it then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:76,Testability,log,logically,76,"// Else, if we do *NOT* have BMI2, let's find out if the if the 'X' is; // *logically* shifted (potentially with one-use trunc inbetween),; // and the truncation was the only use of the shift,; // and if so look past one-use truncation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:18,Testability,log,logically,18,"// If the 'X' is *logically* shifted, we can fold that shift into 'control'.; // FIXME: only if the shift is one-use?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:15,Modifiability,extend,extend,15,"// Now, *zero*-extend the shift amount. The bits 8...15 *must* be zero!; // We could zext to i16 in some form, but we intentionally don't do that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:270,Availability,mask,masks,270,"// If we have TBM we can use an immediate for the control. If we have BMI; // we should only do this if the BEXTR instruction is implemented well.; // Otherwise moving the control into a register makes this more costly.; // TODO: Maybe load folding, greater than 32-bit masks, or a guarantee of LICM; // hoisting the move immediate would make it worthwhile with a less optimal; // BEXTR?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:236,Performance,load,load,236,"// If we have TBM we can use an immediate for the control. If we have BMI; // we should only do this if the BEXTR instruction is implemented well.; // Otherwise moving the control into a register makes this more costly.; // TODO: Maybe load folding, greater than 32-bit masks, or a guarantee of LICM; // hoisting the move immediate would make it worthwhile with a less optimal; // BEXTR?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:21,Availability,mask,mask,21,// And RHS must be a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:107,Performance,load,load,107,"// Don't interfere with something that can be handled by extracting AH.; // TODO: If we are able to fold a load, BEXTR might still be better than AH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:12,Availability,avail,available,12,"// BZHI, if available, is always fast, unlike BEXTR. But even if we decide; // that we can't use BEXTR, it is only worthwhile using BZHI if the mask; // does not fit into 32 bits. Load folding is not a sufficient reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:144,Availability,mask,mask,144,"// BZHI, if available, is always fast, unlike BEXTR. But even if we decide; // that we can't use BEXTR, it is only worthwhile using BZHI if the mask; // does not fit into 32 bits. Load folding is not a sufficient reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:180,Performance,Load,Load,180,"// BZHI, if available, is always fast, unlike BEXTR. But even if we decide; // that we can't use BEXTR, it is only worthwhile using BZHI if the mask; // does not fit into 32 bits. Load folding is not a sufficient reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:58,Availability,mask,mask,58,"// If we can't make use of BEXTR then we can't fuse shift+mask stages.; // Let's perform the mask first, and apply shift later. Note that we need to; // widen the mask to account for the fact that we'll apply shift afterwards!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:93,Availability,mask,mask,93,"// If we can't make use of BEXTR then we can't fuse shift+mask stages.; // Let's perform the mask first, and apply shift later. Note that we need to; // widen the mask to account for the fact that we'll apply shift afterwards!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:163,Availability,mask,mask,163,"// If we can't make use of BEXTR then we can't fuse shift+mask stages.; // Let's perform the mask first, and apply shift later. Note that we need to; // widen the mask to account for the fact that we'll apply shift afterwards!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:81,Performance,perform,perform,81,"// If we can't make use of BEXTR then we can't fuse shift+mask stages.; // Let's perform the mask first, and apply shift later. Note that we need to; // widen the mask to account for the fact that we'll apply shift afterwards!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:17,Performance,load,load,17,// Try to fold a load. No need to check alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:17,Performance,load,load,17,// Try to fold a load. No need to check alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:24,Availability,mask,mask,24,// Narrower shifts only mask to 5 bits in hardware.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:84,Safety,avoid,avoid,84,"// If we are shifting by X+/-/^N where N == 0 mod Size, then just shift by X; // to avoid the ADD/SUB/XOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:88,Testability,log,logic,88,// Insert a negate op.; // TODO: This isn't guaranteed to replace the sub if there is a logic cone; // that uses it that's not a shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,Availability,mask,mask,16,// Insert a new mask to keep the shift amount legal. This should be removed; // by isel patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:18,Performance,optimiz,optimized,18,"// Now that we've optimized the shift amount, defer to normal isel to get; // load folding and legacy vs BMI2 selection without repeating it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:78,Performance,load,load,78,"// Now that we've optimized the shift amount, defer to normal isel to get; // load folding and legacy vs BMI2 selection without repeating it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:139,Modifiability,extend,extended,139,"// If we have an any_extend feeding the AND, look through it to see if there; // is a shift behind it. But only if the AND doesn't use the extended bits.; // FIXME: Generalize this to other ANY_EXTEND than i32 to i64?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:76,Modifiability,extend,extended,76,// AND32ri is the same as AND64ri32 with zext imm.; // Try this before sign extended immediates below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:154,Safety,avoid,avoid,154,"// Ok, we can reorder to get a smaller immediate.; // But, its possible the original immediate allowed an AND to become MOVZX.; // Doing this late due to avoid the MakedValueIsZero call as late as; // possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:57,Availability,mask,mask,57,// Figure out which bits need to be zero to achieve that mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:9,Performance,load,load,9,"// Not a load, check for broadcast which may be behind a bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:20,Testability,log,logic,20,// Try to match two logic ops to a VPTERNLOG.; // FIXME: Handle more complex patterns that use an operand more than once?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:53,Performance,perform,performing,53,"// We can build the appropriate control immediate by performing the logic; // operation we're matching using these constants for A, B, and C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:68,Testability,log,logic,68,"// We can build the appropriate control immediate by performing the logic; // operation we're matching using these constants for A, B, and C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:313,Availability,mask,mask,313,"/// If the high bits of an 'and' operand are known zero, try setting the; /// high bits of an 'and' constant operand to produce a smaller encoding by; /// creating a small, sign-extended negative immediate rather than a large; /// positive one. This reverses a transform in SimplifyDemandedBits that; /// shrinks mask constants by clearing bits. There is also a possibility that; /// the 'and' mask can be made -1, so the 'and' itself is unnecessary. In that; /// case, just replace the 'and'. Return 'true' if the node is replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:394,Availability,mask,mask,394,"/// If the high bits of an 'and' operand are known zero, try setting the; /// high bits of an 'and' constant operand to produce a smaller encoding by; /// creating a small, sign-extended negative immediate rather than a large; /// positive one. This reverses a transform in SimplifyDemandedBits that; /// shrinks mask constants by clearing bits. There is also a possibility that; /// the 'and' mask can be made -1, so the 'and' itself is unnecessary. In that; /// case, just replace the 'and'. Return 'true' if the node is replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:178,Modifiability,extend,extended,178,"/// If the high bits of an 'and' operand are known zero, try setting the; /// high bits of an 'and' constant operand to produce a smaller encoding by; /// creating a small, sign-extended negative immediate rather than a large; /// positive one. This reverses a transform in SimplifyDemandedBits that; /// shrinks mask constants by clearing bits. There is also a possibility that; /// the 'and' mask can be made -1, so the 'and' itself is unnecessary. In that; /// case, just replace the 'and'. Return 'true' if the node is replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:274,Usability,Simpl,SimplifyDemandedBits,274,"/// If the high bits of an 'and' operand are known zero, try setting the; /// high bits of an 'and' constant operand to produce a smaller encoding by; /// creating a small, sign-extended negative immediate rather than a large; /// positive one. This reverses a transform in SimplifyDemandedBits that; /// shrinks mask constants by clearing bits. There is also a possibility that; /// the 'and' mask can be made -1, so the 'and' itself is unnecessary. In that; /// case, just replace the 'and'. Return 'true' if the node is replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:331,Usability,clear,clearing,331,"/// If the high bits of an 'and' operand are known zero, try setting the; /// high bits of an 'and' constant operand to produce a smaller encoding by; /// creating a small, sign-extended negative immediate rather than a large; /// positive one. This reverses a transform in SimplifyDemandedBits that; /// shrinks mask constants by clearing bits. There is also a possibility that; /// the 'and' mask can be made -1, so the 'and' itself is unnecessary. In that; /// case, just replace the 'and'. Return 'true' if the node is replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Availability,mask,mask,19,"// Bail out if the mask constant is already negative. It's can't shrink more.; // If the upper 32 bits of a 64 bit mask are all zeros, we have special isel; // patterns to use a 32-bit and instead of a 64-bit and by relying on the; // implicit zeroing of 32 bit ops. So we should check if the lower 32 bits; // are negative too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:115,Availability,mask,mask,115,"// Bail out if the mask constant is already negative. It's can't shrink more.; // If the upper 32 bits of a 64 bit mask are all zeros, we have special isel; // patterns to use a 32-bit and instead of a 64-bit and by relying on the; // implicit zeroing of 32 bit ops. So we should check if the lower 32 bits; // are negative too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:51,Availability,mask,mask,51,// Don't extend into the upper 32 bits of a 64 bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:9,Modifiability,extend,extend,9,// Don't extend into the upper 32 bits of a 64 bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Availability,mask,masks,10,// Extend masks if we truncated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Modifiability,Extend,Extend,3,// Extend masks if we truncated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:111,Availability,mask,mask,111,"// The variable operand must be all zeros in the top bits to allow using the; // new, negative constant as the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:7,Modifiability,variab,variable,7,"// The variable operand must be all zeros in the top bits to allow using the; // new, negative constant as the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,Availability,mask,mask,16,"// Check if the mask is -1. In that case, this is an unnecessary instruction; // that escaped earlier analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:14,Availability,mask,mask,14,// A negative mask allows a smaller encoding. Create a new 'and' node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:91,Availability,mask,masked,91,"// Try to create VPTESTM instruction. If InMask is not null, it will be used; // to form a masked operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:42,Performance,load,load,42,"// If we need to widen, we can't fold the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:23,Performance,load,load,23,"// If we didn't fold a load, try to match broadcast. No widening limitation; // for this. But only 32 and 64 bit types are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:20,Performance,load,loads,20,// We can only fold loads if the sources are unique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:13,Availability,mask,mask,13,// Widen the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:40,Availability,mask,mask,40,"// If we widened, we need to shrink the mask VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:42,Availability,down,down,42,"// ANDN is not commutable, use it to pick down A and C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:48,Modifiability,extend,extended,48,"// Converts a 32-bit register to a 64-bit, zero-extended version of; // it. This is needed because x86-64 can do many things, but jmp %r32; // ain't one of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:17,Availability,mask,masked,17,// Try to form a masked VPTESTM. Operands can be in either order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Safety,avoid,avoid,10,// Try to avoid folding immediates with multiple uses for optsize.; // This code tries to select to register form directly to avoid going; // through the isel table which might fold the immediate. We can't change; // the patterns on the add/sub/and/or/xor with immediate paterns in the; // tablegen files to check immediate use count without making the patterns; // unavailable to the fast-isel table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:126,Safety,avoid,avoid,126,// Try to avoid folding immediates with multiple uses for optsize.; // This code tries to select to register form directly to avoid going; // through the isel table which might fold the immediate. We can't change; // the patterns on the add/sub/and/or/xor with immediate paterns in the; // tablegen files to check immediate use count without making the patterns; // unavailable to the fast-isel table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:22,Safety,avoid,avoid,22,// Check if we should avoid folding this immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:110,Performance,load,load,110,"// Ok this is a AND/OR/XOR/ADD/SUB with constant.; // If this is a not a subtract, we can still try to fold a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:75,Usability,clear,clear,75,"// Special case for div8, just use a move with zero extension to AX to; // clear the upper 8 bits (AH).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:8,Modifiability,extend,extend,8,// Sign extend the low part into the high part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:44,Modifiability,extend,extending,44,"// Zero out the high part, effectively zero extending the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:296,Availability,robust,robust,296,"// Prevent use of AH in a REX instruction by explicitly copying it to; // an ABCD_L register.; //; // The current assumption of the register allocator is that isel; // won't generate explicit references to the GR8_ABCD_H registers. If; // the allocator and/or the backend get enhanced to be more robust in; // that regard, this can be, and should be, removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:276,Modifiability,enhance,enhanced,276,"// Prevent use of AH in a REX instruction by explicitly copying it to; // an ABCD_L register.; //; // The current assumption of the register allocator is that isel; // won't generate explicit references to the GR8_ABCD_H registers. If; // the allocator and/or the backend get enhanced to be more robust in; // that regard, this can be, and should be, removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations for TEST compares.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:21,Testability,TEST,TEST,21,// Optimizations for TEST compares.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:39,Availability,Mask,Mask,39,"// If we are comparing (and (shr X, C, Mask) with 0, emit a BEXTR followed; // by a test instruction. The test should be removed later by; // analyzeCompare if we are using only the zero flag.; // TODO: Should we check the users and use the BEXTR flags directly?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:84,Testability,test,test,84,"// If we are comparing (and (shr X, C, Mask) with 0, emit a BEXTR followed; // by a test instruction. The test should be removed later by; // analyzeCompare if we are using only the zero flag.; // TODO: Should we check the users and use the BEXTR flags directly?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:106,Testability,test,test,106,"// If we are comparing (and (shr X, C, Mask) with 0, emit a BEXTR followed; // by a test instruction. The test should be removed later by; // analyzeCompare if we are using only the zero flag.; // TODO: Should we check the users and use the BEXTR flags directly?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:44,Availability,mask,mask,44,// We may have looked through a truncate so mask off any bits that; // shouldn't be part of the compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:81,Availability,mask,masks,81,"// Check if we can replace AND+IMM{32,64} with a shift. This is possible; // for masks like 0xFF000000 or 0x00FFFFFF and if we care only about the; // zero flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Availability,mask,mask,10,"// If the mask covers the most significant bit, then we can replace; // TEST+AND with a SHR and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:127,Availability,redundant,redundant,127,"// If the mask covers the most significant bit, then we can replace; // TEST+AND with a SHR and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:127,Safety,redund,redundant,127,"// If the mask covers the most significant bit, then we can replace; // TEST+AND with a SHR and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:72,Testability,TEST,TEST,72,"// If the mask covers the most significant bit, then we can replace; // TEST+AND with a SHR and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:137,Testability,TEST,TEST,137,"// If the mask covers the most significant bit, then we can replace; // TEST+AND with a SHR and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Availability,mask,mask,10,"// If the mask covers the least significant bit, then we can replace; // TEST+AND with a SHL and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:128,Availability,redundant,redundant,128,"// If the mask covers the least significant bit, then we can replace; // TEST+AND with a SHL and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:128,Safety,redund,redundant,128,"// If the mask covers the least significant bit, then we can replace; // TEST+AND with a SHL and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:73,Testability,TEST,TEST,73,"// If the mask covers the least significant bit, then we can replace; // TEST+AND with a SHL and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:138,Testability,TEST,TEST,138,"// If the mask covers the least significant bit, then we can replace; // TEST+AND with a SHL and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:18,Availability,mask,mask,18,"// If the shifted mask extends into the high half and is 8/16/32 bits; // wide, then replace it with a SHR and a TEST8rr/TEST16rr/TEST32rr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:23,Modifiability,extend,extends,23,"// If the shifted mask extends into the high half and is 8/16/32 bits; // wide, then replace it with a SHR and a TEST8rr/TEST16rr/TEST32rr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:182,Availability,mask,mask,182,"// For each of these checks we need to be careful if the sign flag is; // being used. It is only safe to use the sign flag in two conditions,; // either the sign bit in the shrunken mask is zero or the final test; // size is equal to the original compare size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:97,Safety,safe,safe,97,"// For each of these checks we need to be careful if the sign flag is; // being used. It is only safe to use the sign flag in two conditions,; // either the sign bit in the shrunken mask is zero or the final test; // size is equal to the original compare size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:208,Testability,test,test,208,"// For each of these checks we need to be careful if the sign flag is; // being used. It is only safe to use the sign flag in two conditions,; // either the sign bit in the shrunken mask is zero or the final test; // size is equal to the original compare size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:25,Testability,test,testl,25,"// For example, convert ""testl %eax, $8"" to ""testb %al, $8""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:45,Testability,test,testb,45,"// For example, convert ""testl %eax, $8"" to ""testb %al, $8""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:114,Performance,optimiz,optimizing,114,"// For example, ""testl %eax, $32776"" to ""testw %ax, $32776"".; // NOTE: We only want to form TESTW instructions if optimizing for; // min size. Otherwise we only save one byte and possibly get a length; // changing prefix penalty in the decoders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:17,Testability,test,testl,17,"// For example, ""testl %eax, $32776"" to ""testw %ax, $32776"".; // NOTE: We only want to form TESTW instructions if optimizing for; // min size. Otherwise we only save one byte and possibly get a length; // changing prefix penalty in the decoders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:41,Testability,test,testw,41,"// For example, ""testl %eax, $32776"" to ""testw %ax, $32776"".; // NOTE: We only want to form TESTW instructions if optimizing for; // min size. Otherwise we only save one byte and possibly get a length; // changing prefix penalty in the decoders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:92,Testability,TEST,TESTW,92,"// For example, ""testl %eax, $32776"" to ""testw %ax, $32776"".; // NOTE: We only want to form TESTW instructions if optimizing for; // min size. Otherwise we only save one byte and possibly get a length; // changing prefix penalty in the decoders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:17,Testability,test,testq,17,"// For example, ""testq %rax, $268468232"" to ""testl %eax, $268468232"".; // NOTE: We only want to run that transform if N0 is 32 or 64 bits.; // Otherwize, we find ourselves in a position where we have to do; // promotion. If previous passes did not promote the and, we assume; // they had a good reason not to and do not promote here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:45,Testability,test,testl,45,"// For example, ""testq %rax, $268468232"" to ""testl %eax, $268468232"".; // NOTE: We only want to run that transform if N0 is 32 or 64 bits.; // Otherwize, we find ourselves in a position where we have to do; // promotion. If previous passes did not promote the and, we assume; // they had a good reason not to and do not promote here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,Testability,test,testl,10,// Emit a testl or testw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Testability,test,testw,19,// Emit a testl or testw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:3,Deployability,Update,Update,3,// Update the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:20,Testability,TEST,TEST,20,// Replace CMP with TEST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Performance,load,load,19,// We can't fold a load if we are going to make two instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:19,Performance,load,load,19,// We can't fold a load if we are going to make two instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:30,Availability,mask,mask,30,// Gather instructions have a mask output not in the ISD node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:31,Availability,mask,mask,31,// Scatter instructions have a mask output not in the ISD node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:91,Energy Efficiency,schedul,scheduling,91,"/// This pass converts a legalized DAG into a X86-specific DAG,; /// ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:405,Integrability,interface,interfaces,405,"//===-- X86ISelLowering.cpp - X86 DAG Lowering Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that X86 uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,Availability,mask,masks,56,// X86-SSE is even stranger. It uses -1 or 0 for vector masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,Energy Efficiency,schedul,scheduler,60,"// For 64-bit, since we have so many registers, use the ILP scheduler.; // For 32-bit, use the register pressure specific scheduling.; // For Atom, always use ILP scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:122,Energy Efficiency,schedul,scheduling,122,"// For 64-bit, since we have so many registers, use the ILP scheduler.; // For 32-bit, use the register pressure specific scheduling.; // For Atom, always use ILP scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:163,Energy Efficiency,schedul,scheduling,163,"// For 64-bit, since we have so many registers, use the ILP scheduler.; // For 32-bit, use the register pressure specific scheduling.; // For Atom, always use ILP scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Energy Efficiency,efficient,efficient,47,"// TODO: when we have SSE, these could be more efficient, by using movd/movq.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:112,Availability,avail,available,112,"// Scalar integer divide and remainder are lowered to use operations that; // produce two results, to match the available instructions. This exposes; // the two-result form to trivial CSE, which is able to combine x/y and x%y; // into a single instruction.; //; // Scalar integer multiply-high is also lowered to use two-result; // operations, to match the available instructions. However, plain multiply; // (low) operations are left as Legal, as there are single-result; // instructions for this in x86. Using the two-result multiply instructions; // when both high and low results are needed must be arranged by dagcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:357,Availability,avail,available,357,"// Scalar integer divide and remainder are lowered to use operations that; // produce two results, to match the available instructions. This exposes; // the two-result form to trivial CSE, which is able to combine x/y and x%y; // into a single instruction.; //; // Scalar integer multiply-high is also lowered to use two-result; // operations, to match the available instructions. However, plain multiply; // (low) operations are left as Legal, as there are single-result; // instructions for this in x86. Using the two-result multiply instructions; // when both high and low results are needed must be arranged by dagcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:141,Security,expose,exposes,141,"// Scalar integer divide and remainder are lowered to use operations that; // produce two results, to match the available instructions. This exposes; // the two-result form to trivial CSE, which is able to combine x/y and x%y; // into a single instruction.; //; // Scalar integer multiply-high is also lowered to use two-result; // operations, to match the available instructions. However, plain multiply; // (low) operations are left as Legal, as there are single-result; // instructions for this in x86. Using the two-result multiply instructions; // when both high and low results are needed must be arranged by dagcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Integrability,depend,dependency,36,"// Promoted i16. tzcntw has a false dependency on Intel CPUs. For BSF, we emit; // a REP prefix to encode it as TZCNT for modern CPUs so it makes sense to; // promote that too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,Integrability,depend,dependency,65,// popcntw is longer to encode than popcntl and also has a false dependency; // on the dest that popcntl hasn't had since Cannon Lake.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:134,Performance,load,load,134,// Disable f32->f64 extload as we can only generate this in one instruction; // under optsize. So its easier to pattern match (fpext (load)) for that; // case instead of needing to emit 2 instructions for extload in the; // non-optsize case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,Performance,load,loads,31,"// Expand FP32 immediates into loads from the stack, save special cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,Performance,load,loads,31,"// Expand FP64 immediates into loads from the stack, save special cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,Safety,avoid,avoid,28,// Custom legalize these to avoid over promotion or custom promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Performance,load,load,38,// We want to legalize this to an f64 load rather than an i64 load on; // 64-bit targets and two 32-bit loads on a 32-bit target. Similar for; // store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,Performance,load,load,62,// We want to legalize this to an f64 load rather than an i64 load on; // 64-bit targets and two 32-bit loads on a 32-bit target. Similar for; // store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:104,Performance,load,loads,104,// We want to legalize this to an f64 load rather than an i64 load on; // 64-bit targets and two 32-bit loads on a 32-bit target. Similar for; // store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,Modifiability,extend,extend,60,// SSE41 brings specific instructions for doing vector sign extend even in; // cases where we don't have SRA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,Modifiability,extend,extending,35,"// SSE41 also has vector sign/zero extending loads, PMOV[SZ]X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,Performance,load,loads,45,"// SSE41 also has vector sign/zero extending loads, PMOV[SZ]X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,Energy Efficiency,efficient,efficiently,11,// XOP can efficiently perform BITREVERSE with VPPERM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,Performance,perform,perform,23,// XOP can efficiently perform BITREVERSE with VPPERM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,Modifiability,extend,extending,40,"// AVX2 also has wider vector sign/zero extending loads, VPMOV[SZ]X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:50,Performance,load,loads,50,"// AVX2 also has wider vector sign/zero extending loads, VPMOV[SZ]X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,Availability,mask,mask,43,// This block controls legalization of the mask vector sizes that are; // available with AVX512. 512-bit vectors are in a separate block controlled; // by useAVX512Regs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:74,Availability,avail,available,74,// This block controls legalization of the mask vector sizes that are; // available with AVX512. 512-bit vectors are in a separate block controlled; // by useAVX512Regs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,Performance,load,load,37,// There is no byte sized k-register load or store without AVX512DQ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extends,3,// Extends of v16i1/v8i1/v4i1/v2i1 to 128-bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:146,Availability,mask,masks,146,"// With 512-bit vectors and no VLX, we prefer to widen MLOAD/MSTORE; // to 512-bit rather than use the AVX2 instructions so that we can use; // k-masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Availability,mask,masks,22,// Extends from v64i1 masks to 512-bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extends,3,// Extends from v64i1 masks to 512-bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Modifiability,extend,extend,22,// NonVLX sub-targets extend 128/256 vectors to use the 512 version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,Availability,avail,available,60,// This block control legalization of v32i1/v64i1 which are available with; // AVX512BW..,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Availability,mask,masks,22,// Extends from v32i1 masks to 256-bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extends,3,// Extends from v32i1 masks to 256-bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,Modifiability,extend,extended,27,// INSERT_VECTOR_ELT v8f16 extended to VECTOR_SHUFFLE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,Availability,avail,available,26,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:49,Availability,avail,available,49,// Combine sin / cos into _sincos_stret if it is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:159,Performance,load,load,159,"// TODO: These control memcmp expansion in CGP and could be raised higher, but; // that needs to benchmarked and balanced with the potential use of vector; // load/store types (PR33329, PR33914).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:97,Testability,benchmark,benchmarked,97,"// TODO: These control memcmp expansion in CGP and could be raised higher, but; // that needs to benchmarked and balanced with the potential use of vector; // load/store types (PR33329, PR33914).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,Safety,predict,predictable,56,"// An out-of-order CPU can speculatively execute past a predictable branch,; // but a conditional move could be stalled by an expensive earlier operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,Performance,load,load,35,"// TODO: If this is a non-temporal load and the target has an instruction; // for it, it should not be folded. See ""useNonTemporalLoad()"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Performance,load,load,38,"// We can not replace a wide volatile load with a broadcast-from-memory,; // because that would narrow the load, which isn't legal for volatiles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:107,Performance,load,load,107,"// We can not replace a wide volatile load with a broadcast-from-memory,; // because that would narrow the load, which isn't legal for volatiles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:101,Performance,load,load,101,"// First determine if it is required or is profitable to flip the operands.; // If LHS is a foldable load, but RHS is not, flip the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:164,Performance,load,load,164,"/// Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:140,Performance,load,load,140,"// ""ELF Handling for Thread-Local Storage"" specifies that R_X86_64_GOTTPOFF; // relocation target a movq or addq instruction: don't let the load shrink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:32,Performance,load,load,32,"// If this is an (1) AVX vector load with (2) multiple uses and (3) all of; // those uses are extracted directly into a store, then the extract + store; // can be store-folded. Therefore, it's probably not worth splitting the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:226,Performance,load,load,226,"// If this is an (1) AVX vector load with (2) multiple uses and (3) all of; // those uses are extracted directly into a store, then the extract + store; // can be store-folded. Therefore, it's probably not worth splitting the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,Performance,load,load,61,// Skip uses of the chain value. Result 0 of the node is the load value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:50,Performance,load,load,50,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:249,Integrability,depend,depends,249,"// If we are using XMM registers in the ABI and the condition of the select is; // a floating-point compare and we have blendv or conditional move, then it is; // cheaper to select instead of doing a cross-register move and creating a; // load that depends on the compare result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:239,Performance,load,load,239,"// If we are using XMM registers in the ABI and the condition of the select is; // a floating-point compare and we have blendv or conditional move, then it is; // cheaper to select instead of doing a cross-register move and creating a; // load that depends on the compare result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:114,Performance,latency,latency,114,"// If vector multiply is legal, assume that's faster than shl + add/sub.; // Multiply is a complex op with higher latency and lower throughput in; // most implementations, sub-vXi32 vector multiplies are always fast,; // vXi32 mustn't have a SlowMULLD implementation, and anything larger (vXi64); // is always going to be slow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:132,Performance,throughput,throughput,132,"// If vector multiply is legal, assume that's faster than shl + add/sub.; // Multiply is a complex op with higher latency and lower throughput in; // most implementations, sub-vXi32 vector multiplies are always fast,; // vXi32 mustn't have a SlowMULLD implementation, and anything larger (vXi64); // is always going to be slow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Availability,Mask,Mask,3,// Mask vectors support all subregister combinations and operations that; // extract half of vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,Availability,avail,available,40,"// Don't shrink FP constpool if SSE2 is available since cvtss2sd is more; // expensive than a straight movsd. On the other hand, it's important to; // shrink long double fp constant since fldt is very slow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Performance,perform,perform,34,// Does baseline recommend not to perform the fold by default?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,Energy Efficiency,power,powerful,29,"// If we have AVX2 with it's powerful shift operations, then it's also good.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:102,Usability,clear,clear,102,"// For vectors, if we have rotate instruction support, then its definetly; // best. Otherwise its not clear what the best so just don't make changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:104,Availability,mask,mask,104,"// For scalar, if we have bmi prefer rotate for rorx. Otherwise prefer; // rotate unless we have a zext mask+shr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Availability,mask,mask,34,"// If the current setup has imm64 mask, then inverse will have; // at least imm32 mask (or be zext i32 -> i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:82,Availability,mask,mask,82,"// If the current setup has imm64 mask, then inverse will have; // at least imm32 mask (or be zext i32 -> i64).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:53,Availability,mask,mask,53,"// We can only benefit if req at least 7-bit for the mask. We; // don't want to replace shl of 1,2,3 as they can be implemented; // with lea/add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:77,Energy Efficiency,efficient,efficient,77,"// Keep exactly 32-bit imm64, this is zext i32 -> i64 which is; // extremely efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,Availability,mask,mask,58,// We prefer rotate for vectors of if we won't get a zext mask with SRL; // (PreferRotate will be set in the latter case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Availability,mask,mask,38,// Non-vector type and we have a zext mask with SRL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,Availability,mask,masks,37,// TODO: Should we always create i64 masks? Or only folded immediates?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,Availability,mask,mask,67,"// For vectors, we don't have a preference, but we probably want a mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,Energy Efficiency,efficient,efficiently,46,// Any legal vector type can be splatted more efficiently than; // loading/spilling from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,Performance,load,loading,67,// Any legal vector type can be splatted more efficiently than; // loading/spilling from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,/// Return true if every element in Mask is the undef sentinel value or equal to; /// the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,"/// Return true if every element in Mask, beginning from position Pos and ending; /// in Pos+Size is the undef sentinel value or equal to the specified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,"/// Return true if every element in Mask, beginning from position Pos and ending; /// in Pos+Size is the undef sentinel value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,Availability,mask,mask,23,/// Return true if the mask creates a vector whose lower half is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,Availability,mask,mask,23,/// Return true if the mask creates a vector whose upper half is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Availability,Mask,Mask,47,"/// Return true if the value of any element in Mask falls within the specified; /// range (L, H].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Availability,Mask,Mask,47,/// Return true if the value of any element in Mask is the zero sentinel value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Availability,Mask,Mask,47,/// Return true if the value of any element in Mask is the zero or undef; /// sentinel values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,"/// Return true if every element in Mask is undef or if its value; /// falls within the specified range (L, H].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,"/// Return true if every element in Mask is undef, zero or if its value; /// falls within the specified range (L, H].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,"/// Return true if every element in Mask, beginning; /// from position Pos and ending in Pos + Size, falls within the specified; /// sequence (Low, Low + Step, ..., Low + (Size - 1) * Step) or is undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,"/// Return true if every element in Mask, beginning; /// from position Pos and ending in Pos+Size, falls within the specified; /// sequential range (Low, Low+Size], or is undef or is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,Mask,Mask,36,"/// Return true if every element in Mask, beginning; /// from position Pos and ending in Pos+Size is undef or is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,Availability,mask,mask,46,/// Helper function to test whether a shuffle mask could be; /// simplified by widening the elements being shuffled.; ///; /// Appends the mask for wider elements in WidenedMask if valid. Otherwise; /// leaves it in an unspecified state.; ///; /// NOTE: This must handle normal vector shuffle masks and *target* vector; /// shuffle masks. The latter have the special property of a '-2' representing; /// a zero-ed lane of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:139,Availability,mask,mask,139,/// Helper function to test whether a shuffle mask could be; /// simplified by widening the elements being shuffled.; ///; /// Appends the mask for wider elements in WidenedMask if valid. Otherwise; /// leaves it in an unspecified state.; ///; /// NOTE: This must handle normal vector shuffle masks and *target* vector; /// shuffle masks. The latter have the special property of a '-2' representing; /// a zero-ed lane of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:293,Availability,mask,masks,293,/// Helper function to test whether a shuffle mask could be; /// simplified by widening the elements being shuffled.; ///; /// Appends the mask for wider elements in WidenedMask if valid. Otherwise; /// leaves it in an unspecified state.; ///; /// NOTE: This must handle normal vector shuffle masks and *target* vector; /// shuffle masks. The latter have the special property of a '-2' representing; /// a zero-ed lane of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:332,Availability,mask,masks,332,/// Helper function to test whether a shuffle mask could be; /// simplified by widening the elements being shuffled.; ///; /// Appends the mask for wider elements in WidenedMask if valid. Otherwise; /// leaves it in an unspecified state.; ///; /// NOTE: This must handle normal vector shuffle masks and *target* vector; /// shuffle masks. The latter have the special property of a '-2' representing; /// a zero-ed lane of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,Testability,test,test,23,/// Helper function to test whether a shuffle mask could be; /// simplified by widening the elements being shuffled.; ///; /// Appends the mask for wider elements in WidenedMask if valid. Otherwise; /// leaves it in an unspecified state.; ///; /// NOTE: This must handle normal vector shuffle masks and *target* vector; /// shuffle masks. The latter have the special property of a '-2' representing; /// a zero-ed lane of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,Usability,simpl,simplified,65,/// Helper function to test whether a shuffle mask could be; /// simplified by widening the elements being shuffled.; ///; /// Appends the mask for wider elements in WidenedMask if valid. Otherwise; /// leaves it in an unspecified state.; ///; /// NOTE: This must handle normal vector shuffle masks and *target* vector; /// shuffle masks. The latter have the special property of a '-2' representing; /// a zero-ed lane of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Availability,mask,mask,22,"// Check for an undef mask and a mask value properly aligned to fit with; // a pair of values. If we find such a case, use the non-undef mask's value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,Availability,mask,mask,33,"// Check for an undef mask and a mask value properly aligned to fit with; // a pair of values. If we find such a case, use the non-undef mask's value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:137,Availability,mask,mask,137,"// Check for an undef mask and a mask value properly aligned to fit with; // a pair of values. If we find such a case, use the non-undef mask's value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,Availability,mask,mask,28,// Finally check if the two mask values are adjacent and aligned with; // a pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Safety,safe,safely,22,// Otherwise we can't safely widen the elements used in this shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Availability,mask,mask,25,// Create an alternative mask with info about zeroable elements.; // Here we do not set undef elements as zeroable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,Availability,mask,mask,35,// Attempt to narrow/widen shuffle mask until it matches the target number of; // elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:57,Availability,Mask,MaskElt,57,// Build a vector of constants.; // Use an UNDEF node if MaskElt == -1.; // Split 64-bit constants in the 32-bit mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:148,Availability,avail,available,148,"// Try to build SSE/AVX zero vectors as <N x i32> bitcasted to their dest; // type. This ensures they get CSE'd. But if the integer type is not; // available, use a floating-point +0.0 instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:109,Energy Efficiency,power,power,109,// This is the index of the first element of the vectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:133,Usability,clear,clear,133,// This is the index of the first element of the vectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:203,Usability,simpl,simple,203,/// Generate a DAG to grab 128-bits from a vector > 128 bits. This; /// sets things up to match to an AVX VEXTRACTF128 / VEXTRACTI128; /// or AVX-512 VEXTRACTF32x4 / VEXTRACTI32x4; /// instructions or a simple subregister reference. Idx is an index in the; /// 128 bits we want. It need not be aligned to a 128-bit boundary. That makes; /// lowering EXTRACT_VECTOR_ELT operations easier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:109,Energy Efficiency,power,power,109,// This is the index of the first element of the vectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:133,Usability,clear,clear,133,// This is the index of the first element of the vectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:194,Usability,simpl,simple,194,/// Generate a DAG to put 128-bits into a vector > 128 bits. This; /// sets things up to match to an AVX VINSERTF128/VINSERTI128 or; /// AVX-512 VINSERTF32x4/VINSERTI32x4 instructions or a; /// simple superregister reference. Idx is an index in the 128 bits; /// we want. It need not be aligned to a 128-bit boundary. That makes; /// lowering INSERT_VECTOR_ELT operations easier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,Availability,mask,mask,12,/// Widen a mask vector type to a minimum of v8i1/v16i1 to allow use of KSHIFT; /// and bitcast with integer types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,Availability,mask,mask,12,/// Widen a mask vector to a minimum of v8i1/v16i1 to allow use of KSHIFT and; /// bitcast with integer types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,Security,access,access,29,// Helper to check if we can access all the constituent subvectors without any; // extract ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,Safety,avoid,avoid,55,// Make sure we only try to split 256/512-bit types to avoid creating; // narrow vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Testability,Assert,Assert,3,// Assert that all the types match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:144,Availability,avail,available,144,"// Helper for splitting operands of an operation to legal target size and; // apply a function on each part.; // Useful for operations that are available on SSE2 in 128-bit, on AVX2 in; // 256-bit and on AVX512BW in 512-bit. The argument VT is the type used for; // deciding if/how to split Ops. Ops elements do *not* have to be of type VT.; // The argument Builder is a function that will be applied on each split part:; // SDValue Builder(SelectionDAG&G, SDLoc, ArrayRef<SDValue>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,Modifiability,extend,extends,24,// Helper function that extends a non-512-bit vector op to 512-bits on non-VLX; // targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the 512-bit op then extract the bottom subvector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend to natively supported kshift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,Modifiability,extend,extended,46,"// Merge them together, SubVec should be zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Usability,Simpl,Simple,3,// Simple case when we put subvector in the upper part,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:32,Modifiability,extend,extending,32,"// Special case, use legal zero extending insert_subvector. This allows; // isel to optimize when bits are known zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,Performance,optimiz,optimize,84,"// Special case, use legal zero extending insert_subvector. This allows; // isel to optimize when bits are known zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,Performance,optimiz,optimization,9,// Do an optimization for the most frequently used types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce to original width if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear the upper bits of the subvector and move it to its insert position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce to original width if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,Availability,MASK,MASK,21,"// Create OR(AND(LHS,MASK),AND(RHS,~MASK)) bit select pattern",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,MASK,MASK,36,"// Create OR(AND(LHS,MASK),AND(RHS,~MASK)) bit select pattern",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Modifiability,extend,extending,25,// Fallback to sign/zero extending the requested half and pack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:232,Availability,mask,mask,232,"/// Return a vector_shuffle of the specified vector of zero or undef vector.; /// This produces a shuffle where the low element of V2 is swizzled into the; /// zero/undef vector, landing at element Idx.; /// This produces a shuffle mask like 4,1,2,3 (idx=0) or 0,1,2,4 (idx=3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,Availability,mask,mask,41,// Collect constant bits and insert into mask/undef bit masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,Availability,mask,masks,56,// Collect constant bits and insert into mask/undef bit masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,Safety,safe,safe,92,// If bitcasts to larger elements we might lose track of undefs - don't; // allow any to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,Availability,mask,mask,42,// Insert the extracted elements into the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,Availability,mask,mask,21,"/// Create a shuffle mask that matches the PACKSS/PACKUS truncation.; /// A multi-stage pack shuffle mask is created by specifying NumStages > 1.; /// Note: This ignores saturation, so inputs must be checked first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:101,Availability,mask,mask,101,"/// Create a shuffle mask that matches the PACKSS/PACKUS truncation.; /// A multi-stage pack shuffle mask is created by specifying NumStages > 1.; /// Note: This ignores saturation, so inputs must be checked first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,Availability,mask,mask,27,"/// Calculates the shuffle mask corresponding to the target-specific opcode.; /// If the mask could be calculated, returns it in \p Mask, returns the shuffle; /// operands in \p Ops, and returns true.; /// Sets \p IsUnary to true if only one source is used. Note that this will set; /// IsUnary for shuffles which use a single input multiple times, and in those; /// cases it will adjust the mask to only have indices within that single input.; /// It is an error to call this with non-empty Mask/Ops vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:89,Availability,mask,mask,89,"/// Calculates the shuffle mask corresponding to the target-specific opcode.; /// If the mask could be calculated, returns it in \p Mask, returns the shuffle; /// operands in \p Ops, and returns true.; /// Sets \p IsUnary to true if only one source is used. Note that this will set; /// IsUnary for shuffles which use a single input multiple times, and in those; /// cases it will adjust the mask to only have indices within that single input.; /// It is an error to call this with non-empty Mask/Ops vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:132,Availability,Mask,Mask,132,"/// Calculates the shuffle mask corresponding to the target-specific opcode.; /// If the mask could be calculated, returns it in \p Mask, returns the shuffle; /// operands in \p Ops, and returns true.; /// Sets \p IsUnary to true if only one source is used. Note that this will set; /// IsUnary for shuffles which use a single input multiple times, and in those; /// cases it will adjust the mask to only have indices within that single input.; /// It is an error to call this with non-empty Mask/Ops vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:392,Availability,mask,mask,392,"/// Calculates the shuffle mask corresponding to the target-specific opcode.; /// If the mask could be calculated, returns it in \p Mask, returns the shuffle; /// operands in \p Ops, and returns true.; /// Sets \p IsUnary to true if only one source is used. Note that this will set; /// IsUnary for shuffles which use a single input multiple times, and in those; /// cases it will adjust the mask to only have indices within that single input.; /// It is an error to call this with non-empty Mask/Ops vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:458,Availability,error,error,458,"/// Calculates the shuffle mask corresponding to the target-specific opcode.; /// If the mask could be calculated, returns it in \p Mask, returns the shuffle; /// operands in \p Ops, and returns true.; /// Sets \p IsUnary to true if only one source is used. Note that this will set; /// IsUnary for shuffles which use a single input multiple times, and in those; /// cases it will adjust the mask to only have indices within that single input.; /// It is an error to call this with non-empty Mask/Ops vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:492,Availability,Mask,Mask,492,"/// Calculates the shuffle mask corresponding to the target-specific opcode.; /// If the mask could be calculated, returns it in \p Mask, returns the shuffle; /// operands in \p Ops, and returns true.; /// Sets \p IsUnary to true if only one source is used. Note that this will set; /// IsUnary for shuffles which use a single input multiple times, and in those; /// cases it will adjust the mask to only have indices within that single input.; /// It is an error to call this with non-empty Mask/Ops vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:141,Usability,Simpl,SimplifyDemandedBits,141,"// We only decode broadcasts of same-sized vectors, peeking through to; // extracted subvectors is likely to cause hasOneUse issues with; // SimplifyDemandedBits etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,Availability,mask,mask,39,"// Unlike most shuffle nodes, VPERMV's mask operand is operand 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,Availability,mask,mask,40,"// Unlike most shuffle nodes, VPERMV3's mask operand is the middle one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,Availability,mask,mask,9,// Empty mask indicates the decode failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,mask,mask,36,// Check if we're getting a shuffle mask with zero'd elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,Availability,mask,mask,48,"// If we have a fake unary shuffle, the shuffle mask is spread across two; // inputs that are actually the same node. Re-map the mask to always point; // into the first input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:129,Availability,mask,mask,129,"// If we have a fake unary shuffle, the shuffle mask is spread across two; // inputs that are actually the same node. Re-map the mask to always point; // into the first input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Integrability,Wrap,Wrapper,3,// Wrapper for getTargetShuffleMask with InUnary;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:192,Availability,mask,mask,192,"/// Compute whether each element of a shuffle is zeroable.; ///; /// A ""zeroable"" vector shuffle element is one which can be lowered to zero.; /// Either it is an undef element in the shuffle mask, the element of the input; /// referenced is undef, or the element of the input referenced is known to be; /// zero. Many x86 shuffles can zero lanes cheaply and we often want to handle; /// as many lanes with this technique as possible to simplify the remaining; /// shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:437,Usability,simpl,simplify,437,"/// Compute whether each element of a shuffle is zeroable.; ///; /// A ""zeroable"" vector shuffle element is one which can be lowered to zero.; /// Either it is an undef element in the shuffle mask, the element of the input; /// referenced is undef, or the element of the input referenced is known to be; /// zero. Many x86 shuffles can zero lanes cheaply and we often want to handle; /// as many lanes with this technique as possible to simplify the remaining; /// shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,Availability,mask,mask,45,// Determine shuffle input and normalize the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,Availability,mask,mask,28,/// Decode a target shuffle mask and inputs and see if any values are; /// known to be undef or zero from their inputs.; /// Returns true if the target shuffle mask was decoded.; /// FIXME: Merge this with computeZeroableShuffleElements?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:160,Availability,mask,mask,160,/// Decode a target shuffle mask and inputs and see if any values are; /// known to be undef or zero from their inputs.; /// Returns true if the target shuffle mask was decoded.; /// FIXME: Merge this with computeZeroableShuffleElements?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,Availability,mask,mask,45,// Determine shuffle input and normalize the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:210,Performance,load,loads,210,"// SCALAR_TO_VECTOR - only the first element is defined, and the rest UNDEF.; // TODO: We currently only set UNDEF for integer types - floats use the same; // registers as vectors and many of the scalar folded loads rely on the; // SCALAR_TO_VECTOR pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,Availability,mask,mask,26,// Replace target shuffle mask elements with known undef/zero sentinels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,Availability,mask,mask,26,// Extract target shuffle mask sentinel elements to known undef/zero bitmasks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,Availability,mask,mask,31,// Attempt to create a shuffle mask from a VSELECT/BLENDV condition mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:68,Availability,mask,mask,68,// Attempt to create a shuffle mask from a VSELECT/BLENDV condition mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,Availability,mask,mask,64,// Attempt to decode ops that could be represented as a shuffle mask.; // The decoded shuffle mask may contain a different number of elements to the; // destination value type.; // TODO: Merge into getTargetShuffleInputs(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:94,Availability,mask,mask,94,// Attempt to decode ops that could be represented as a shuffle mask.; // The decoded shuffle mask may contain a different number of elements to the; // destination value type.; // TODO: Merge into getTargetShuffleInputs(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,Availability,mask,mask,35,// Attempt to decode as a per-byte mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,Availability,mask,mask,40,// Create 'identity' byte level shuffle mask and then add inserted bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:187,Availability,mask,mask,187,"// We can't easily fold ASHR into a shuffle, but if it was feeding a; // PACKSS then it was likely being used for sign-extension for a; // truncation, so just peek through and adjust the mask accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,Usability,simpl,simple,30,// Truncated source must be a simple vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,Availability,mask,mask,9,// Clear mask to all zeros and insert the shifted byte indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear mask to all zeros and insert the shifted byte indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extended,3,// Extended source must be a simple vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,Usability,simpl,simple,29,// Extended source must be a simple vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extended,3,// Extended source must be a simple vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,Usability,simpl,simple,29,// Extended source must be a simple vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:74,Availability,mask,mask,74,/// Removes unused/repeated shuffle source inputs and adjusts the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,Availability,mask,mask,67,/// Calls getTargetShuffleAndZeroables to resolve a target shuffle mask's inputs; /// and then sets the SM_SentinelUndef and SM_SentinelZero values.; /// Returns true if the target shuffle mask was decoded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:189,Availability,mask,mask,189,/// Calls getTargetShuffleAndZeroables to resolve a target shuffle mask's inputs; /// and then sets the SM_SentinelUndef and SM_SentinelZero values.; /// Returns true if the target shuffle mask was decoded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,Usability,simpl,simple,20,"// Ensure this is a simple (non-atomic, non-voltile), temporal read memop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:143,Integrability,depend,dependency,143,// If the build vector contains zeros or our first insertion is not the; // first index then insert into zero vector to break any register; // dependency else use SCALAR_TO_VECTOR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,Testability,log,logical,20,/// Return a vector logical shift node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:156,Availability,mask,mask,156,"// Check if the scalar load can be widened into a vector load. And if; // the address is ""base + cst"" see if the cst can be ""absorbed"" into; // the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,Performance,load,load,23,"// Check if the scalar load can be widened into a vector load. And if; // the address is ""base + cst"" see if the cst can be ""absorbed"" into; // the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:57,Performance,load,load,57,"// Check if the scalar load can be widened into a vector load. And if; // the address is ""base + cst"" see if the cst can be ""absorbed"" into; // the shuffle mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,Performance,Load,LoadSDNode,21,// Recurse to find a LoadSDNode source and the accumulated ByteOffest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,Performance,load,load,128,"/// Given the initializing elements 'Elts' of a vector of type 'VT', see if the; /// elements can be replaced by a single large load which has the same value as; /// a build_vector or insert_subvector whose loaded operands are 'Elts'.; ///; /// Example: <load i32 *a, load i32 *a+4, zero, undef> -> zextload a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:207,Performance,load,loaded,207,"/// Given the initializing elements 'Elts' of a vector of type 'VT', see if the; /// elements can be replaced by a single large load which has the same value as; /// a build_vector or insert_subvector whose loaded operands are 'Elts'.; ///; /// Example: <load i32 *a, load i32 *a+4, zero, undef> -> zextload a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:255,Performance,load,load,255,"/// Given the initializing elements 'Elts' of a vector of type 'VT', see if the; /// elements can be replaced by a single large load which has the same value as; /// a build_vector or insert_subvector whose loaded operands are 'Elts'.; ///; /// Example: <load i32 *a, load i32 *a+4, zero, undef> -> zextload a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:268,Performance,load,load,268,"/// Given the initializing elements 'Elts' of a vector of type 'VT', see if the; /// elements can be replaced by a single large load which has the same value as; /// a build_vector or insert_subvector whose loaded operands are 'Elts'.; ///; /// Example: <load i32 *a, load i32 *a+4, zero, undef> -> zextload a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,Performance,load,load,61,"// For each element in the initializer, see if we've found a load, zero or an; // undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,Performance,load,loaded,8,// Each loaded element must be the correct fractional portion of the; // requested vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:90,Performance,load,load,90,// Each loaded element must be the correct fractional portion of the; // requested vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,Performance,load,load,37,// TODO: Support offsetting the base load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,Performance,load,load,33,// Check to see if the element's load is consecutive to the base load; // or offset from a previous (already checked) load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,Performance,load,load,65,// Check to see if the element's load is consecutive to the base load; // or offset from a previous (already checked) load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:118,Performance,load,load,118,// Check to see if the element's load is consecutive to the base load; // or offset from a previous (already checked) load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,Performance,load,loads,15,// Consecutive loads can contain UNDEFS but not ZERO elements.; // Consecutive loads with UNDEFs and ZEROs elements require a; // an additional shuffle stage to clear the ZERO elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:79,Performance,load,loads,79,// Consecutive loads can contain UNDEFS but not ZERO elements.; // Consecutive loads with UNDEFs and ZEROs elements require a; // an additional shuffle stage to clear the ZERO elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:161,Usability,clear,clear,161,// Consecutive loads can contain UNDEFS but not ZERO elements.; // Consecutive loads with UNDEFs and ZEROs elements require a; // an additional shuffle stage to clear the ZERO elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,Performance,load,load,21,// Check if the base load is entirely dereferenceable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Performance,LOAD,LOAD,3,"// LOAD - all consecutive load/undefs (must start/end with a load or be; // entirely dereferenceable). If we have found an entire vector of loads and; // undefs, then return a large load of the entire vector width starting at the; // base pointer. If the vector contains zeros, then attempt to shuffle those; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,Performance,load,load,26,"// LOAD - all consecutive load/undefs (must start/end with a load or be; // entirely dereferenceable). If we have found an entire vector of loads and; // undefs, then return a large load of the entire vector width starting at the; // base pointer. If the vector contains zeros, then attempt to shuffle those; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,Performance,load,load,61,"// LOAD - all consecutive load/undefs (must start/end with a load or be; // entirely dereferenceable). If we have found an entire vector of loads and; // undefs, then return a large load of the entire vector width starting at the; // base pointer. If the vector contains zeros, then attempt to shuffle those; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:140,Performance,load,loads,140,"// LOAD - all consecutive load/undefs (must start/end with a load or be; // entirely dereferenceable). If we have found an entire vector of loads and; // undefs, then return a large load of the entire vector width starting at the; // base pointer. If the vector contains zeros, then attempt to shuffle those; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:182,Performance,load,load,182,"// LOAD - all consecutive load/undefs (must start/end with a load or be; // entirely dereferenceable). If we have found an entire vector of loads and; // undefs, then return a large load of the entire vector width starting at the; // base pointer. If the vector contains zeros, then attempt to shuffle those; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,Performance,load,loads,45,// Don't create 256-bit non-temporal aligned loads without AVX2 as these; // will lower to regular temporal loads and use the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:108,Performance,load,loads,108,// Don't create 256-bit non-temporal aligned loads without AVX2 as these; // will lower to regular temporal loads and use the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,Performance,cache,cache,126,// Don't create 256-bit non-temporal aligned loads without AVX2 as these; // will lower to regular temporal loads and use the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,Performance,load,loaded,67,// IsConsecutiveLoadWithZeros - we need to create a shuffle of the loaded; // vector and a zero vector to clear out the zero elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:106,Usability,clear,clear,106,// IsConsecutiveLoadWithZeros - we need to create a shuffle of the loaded; // vector and a zero vector to clear out the zero elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Performance,load,load,34,// If the upper half of a ymm/zmm load is undef then just load the lower half.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,Performance,load,load,58,// If the upper half of a ymm/zmm load is undef then just load the lower half.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Performance,load,load,38,// VZEXT_LOAD - consecutive 32/64-bit load/undefs followed by zeros/undefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,Performance,load,load,63,"// BROADCAST - match the smallest possible repetition pattern, load that; // scalar/subvector element and then broadcast to the entire vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Performance,load,loads,16,// We must have loads at both ends of the repetition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:129,Performance,load,load,129,"// Combine a vector ops (shuffles etc.) that is equal to build_vector load1,; // load2, load3, load4, <0, 1, 2, 3> into a vector load if the load addresses; // are consecutive, non-overlapping, and in the right order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:141,Performance,load,load,141,"// Combine a vector ops (shuffles etc.) that is equal to build_vector load1,; // load2, load3, load4, <0, 1, 2, 3> into a vector load if the load addresses; // are consecutive, non-overlapping, and in the right order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:139,Performance,load,load,139,"/// Attempt to use the vbroadcast instruction to generate a splat value; /// from a splat BUILD_VECTOR which uses:; /// a. A single scalar load, or a constant.; /// b. Repeated pattern of constants (e.g. <0,1,0,1> or <0,1,2,3,0,1,2,3>).; ///; /// The VBROADCAST node is returned when a pattern is found,; /// or SDValue() otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid replacing with broadcast when it's a use of a shuffle; // instruction to preserve the present custom lowering of shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Performance,Load,Load,3,// Load the constant scalar/subvector and broadcast it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Performance,Load,Load,3,// Load the vector of constants and broadcast it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:276,Performance,load,load,276,"// If we are moving a scalar into a vector (Ld must be set and all elements; // but 1 are undef) and that operation is not obviously supported by; // vmovd/vmovq/vmovss/vmovsd, then keep trying to form a broadcast.; // That's better than general shuffling and may eliminate a load to GPR and; // move from scalar to vector register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:108,Performance,load,load,108,"// TODO: Handle broadcasts of non-constant sequences.; // Make sure that all of the users of a non-constant load are from the; // BUILD_VECTOR node.; // FIXME: Is the use count needed for non-constant, non-load case?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:206,Performance,load,load,206,"// TODO: Handle broadcasts of non-constant sequences.; // Make sure that all of the users of a non-constant load are from the; // BUILD_VECTOR node.; // FIXME: Is the use count needed for non-constant, non-load case?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing for size, generate up to 5 extra bytes for a broadcast; // instruction to save 8 or more bytes of constant pool data.; // TODO: If multiple splats are generated to load the same constant,; // it may be detrimental to overall size. There needs to be a way to detect; // that condition to know if this is truly a size win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:183,Performance,load,load,183,"// When optimizing for size, generate up to 5 extra bytes for a broadcast; // instruction to save 8 or more bytes of constant pool data.; // TODO: If multiple splats are generated to load the same constant,; // it may be detrimental to overall size. There needs to be a way to detect; // that condition to know if this is truly a size win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:277,Safety,detect,detect,277,"// When optimizing for size, generate up to 5 extra bytes for a broadcast; // instruction to save 8 or more bytes of constant pool data.; // TODO: If multiple splats are generated to load the same constant,; // it may be detrimental to overall size. There needs to be a way to detect; // that condition to know if this is truly a size win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:142,Performance,load,load,142,"// Handle broadcasting a single constant scalar from the constant pool; // into a vector.; // On Sandybridge (no AVX2), it is still better to load a constant vector; // from the constant pool and not to broadcast it from a scalar.; // But override that restriction when optimizing for size.; // TODO: Check if splatting is recommended for other AVX-capable CPUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:270,Performance,optimiz,optimizing,270,"// Handle broadcasting a single constant scalar from the constant pool; // into a vector.; // On Sandybridge (no AVX2), it is still better to load a constant vector; // from the constant pool and not to broadcast it from a scalar.; // But override that restriction when optimizing for size.; // TODO: Check if splatting is recommended for other AVX-capable CPUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:74,Performance,optimiz,optimization,74,"// Splat f16, f32, i32, v4f64, v4i64 in all cases with AVX2.; // For size optimization, also splat v2f64 and v2i64, and for size opt; // with AVX2, also splat i8 and i16.; // With pattern matching, the VBROADCAST node may become a VMOVDDUP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Performance,load,load,38,// The scalar source must be a normal load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:104,Availability,mask,mask,104,// The build_vector allows the scalar element to be larger than the vector; // element type. We need to mask it to use as a condition unless we know; // the upper bits are zero.; // FIXME: Use computeKnownBits instead of checking specific opcode?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the select in the scalar domain so we can use cmov.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:1097,Energy Efficiency,reduce,reduce,1097,"/// This is a helper function of LowerToHorizontalOp().; /// This function checks that the build_vector \p N in input implements a; /// 128-bit partial horizontal operation on a 256-bit vector, but that operation; /// may not match the layout of an x86 256-bit horizontal instruction.; /// In other words, if this returns true, then some extraction/insertion will; /// be required to produce a valid horizontal instruction.; ///; /// Parameter \p Opcode defines the kind of horizontal operation to match.; /// For example, if \p Opcode is equal to ISD::ADD, then this function; /// checks if \p N implements a horizontal arithmetic add; if instead \p Opcode; /// is equal to ISD::SUB, then this function checks if this is a horizontal; /// arithmetic sub.; ///; /// This function only analyzes elements of \p N whose indices are; /// in range [BaseIdx, LastIdx).; ///; /// TODO: This function was originally used to match both real and fake partial; /// horizontal operations, but the index-matching logic is incorrect for that.; /// See the corrected implementation in isHopBuildVector(). Can we reduce this; /// code because it is only used for partial h-op matching now?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:1000,Testability,log,logic,1000,"/// This is a helper function of LowerToHorizontalOp().; /// This function checks that the build_vector \p N in input implements a; /// 128-bit partial horizontal operation on a 256-bit vector, but that operation; /// may not match the layout of an x86 256-bit horizontal instruction.; /// In other words, if this returns true, then some extraction/insertion will; /// be required to produce a valid horizontal instruction.; ///; /// Parameter \p Opcode defines the kind of horizontal operation to match.; /// For example, if \p Opcode is equal to ISD::ADD, then this function; /// checks if \p N implements a horizontal arithmetic add; if instead \p Opcode; /// is equal to ISD::SUB, then this function checks if this is a horizontal; /// arithmetic sub.; ///; /// This function only analyzes elements of \p N whose indices are; /// in range [BaseIdx, LastIdx).; ///; /// TODO: This function was originally used to match both real and fake partial; /// horizontal operations, but the index-matching logic is incorrect for that.; /// See the corrected implementation in isHopBuildVector(). Can we reduce this; /// code because it is only used for partial h-op matching now?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Deployability,Update,Update,3,// Update the expected vector extract index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Deployability,Update,Update,3,// Update InVec0 and InVec1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,Testability,test,test,64,// FADD is commutable. Try to commute the operands; // and then test again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:1412,Availability,avail,available,1412,"/// Returns true if is possible to fold MUL and an idiom that has already been; /// recognized as ADDSUB/SUBADD(\p Opnd0, \p Opnd1) into; /// FMADDSUB/FMSUBADD(x, y, \p Opnd1). If (and only if) true is returned, the; /// operands of FMADDSUB/FMSUBADD are written to parameters \p Opnd0, \p Opnd1, \p Opnd2.; ///; /// Prior to calling this function it should be known that there is some; /// SDNode that potentially can be replaced with an X86ISD::ADDSUB operation; /// using \p Opnd0 and \p Opnd1 as operands. Also, this method is called; /// before replacement of such SDNode with ADDSUB operation. Thus the number; /// of \p Opnd0 uses is expected to be equal to 2.; /// For example, this function may be called for the following IR:; /// %AB = fmul fast <2 x double> %A, %B; /// %Sub = fsub fast <2 x double> %AB, %C; /// %Add = fadd fast <2 x double> %AB, %C; /// %Addsub = shufflevector <2 x double> %Sub, <2 x double> %Add,; /// <2 x i32> <i32 0, i32 3>; /// There is a def for %Addsub here, which potentially can be replaced by; /// X86ISD::ADDSUB operation:; /// %Addsub = X86ISD::ADDSUB %AB, %C; /// and such ADDSUB can further be replaced with FMADDSUB:; /// %Addsub = FMADDSUB %A, %B, %C.; ///; /// The main reason why this method is called before the replacement of the; /// recognized ADDSUB idiom with ADDSUB operation is that such replacement; /// is illegal sometimes. E.g. 512-bit ADDSUB is not available, while 512-bit; /// FMADDSUB is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Performance,perform,performs,36,/// Try to fold a build_vector that performs an 'addsub' or 'fmaddsub' or; /// 'fsubadd' operation accordingly to X86ISD::ADDSUB or X86ISD::FMADDSUB or; /// X86ISD::FMSUBADD node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:204,Testability,log,logic,204,"// x86 256-bit horizontal ops are defined in a non-obvious way. Each 128-bit; // half of the result is calculated independently from the 128-bit halves of; // the inputs, so that makes the index-checking logic below more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,Performance,perform,perform,40,"// If we don't need the upper xmm, then perform as a xmm hop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:89,Usability,simpl,simply,89,// Don't try to expand this build_vector into a pair of horizontal add/sub; // if we can simply emit a pair of scalar add/sub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,Performance,load,load,39,"/// Create a vector constant without a load. SSE/AVX provide the bare minimum; /// functionality to do this, so it's all zeros, all ones, or some derivation; /// that is cheap to calculate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,Modifiability,variab,variable,63,/// Look for opportunities to create a VPERMV/VPERMILPV/PSHUFB variable permute; /// from a vector of source values and a vector of extraction indices.; /// The vectors might be manipulated to match the type of the permute op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,Modifiability,extend,extend,8,// Zero-extend the index elements within the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Performance,perform,perform,22,// Scale to v32i8 and perform as v32i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:353,Availability,mask,mask,353,"// Tries to lower a BUILD_VECTOR composed of extract-extract chains that can be; // reasoned to be a permutation of a vector by indices in a non-constant vector.; // (build_vector (extract_elt V, (extract_elt I, 0)),; // (extract_elt V, (extract_elt I, 1)),; // ...; // ->; // (vpermv I, V); //; // TODO: Handle undefs; // TODO: Utilize pshufb and zero mask blending to support more efficient; // construction of vectors with constant-0 elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:383,Energy Efficiency,efficient,efficient,383,"// Tries to lower a BUILD_VECTOR composed of extract-extract chains that can be; // reasoned to be a permutation of a vector by indices in a non-constant vector.; // (build_vector (extract_elt V, (extract_elt I, 0)),; // (extract_elt V, (extract_elt I, 1)),; // ...; // ->; // (vpermv I, V); //; // TODO: Handle undefs; // TODO: Utilize pshufb and zero mask blending to support more efficient; // construction of vectors with constant-0 elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Modifiability,extend,extends,16,// Peek through extends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,Modifiability,variab,variable,27,"// If we are inserting one variable into a vector of non-zero constants, try; // to avoid loading each constant element as a scalar. Load the constants as a; // vector and then insert the variable scalar element. If insertion is not; // supported, fall back to a shuffle to get the scalar blended with the; // constants. Insertion into a zero vector is handled as a special-case; // somewhere below here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:188,Modifiability,variab,variable,188,"// If we are inserting one variable into a vector of non-zero constants, try; // to avoid loading each constant element as a scalar. Load the constants as a; // vector and then insert the variable scalar element. If insertion is not; // supported, fall back to a shuffle to get the scalar blended with the; // constants. Insertion into a zero vector is handled as a special-case; // somewhere below here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:90,Performance,load,loading,90,"// If we are inserting one variable into a vector of non-zero constants, try; // to avoid loading each constant element as a scalar. Load the constants as a; // vector and then insert the variable scalar element. If insertion is not; // supported, fall back to a shuffle to get the scalar blended with the; // constants. Insertion into a zero vector is handled as a special-case; // somewhere below here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:133,Performance,Load,Load,133,"// If we are inserting one variable into a vector of non-zero constants, try; // to avoid loading each constant element as a scalar. Load the constants as a; // vector and then insert the variable scalar element. If insertion is not; // supported, fall back to a shuffle to get the scalar blended with the; // constants. Insertion into a zero vector is handled as a special-case; // somewhere below here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,Safety,avoid,avoid,84,"// If we are inserting one variable into a vector of non-zero constants, try; // to avoid loading each constant element as a scalar. Load the constants as a; // vector and then insert the variable scalar element. If insertion is not; // supported, fall back to a shuffle to get the scalar blended with the; // constants. Insertion into a zero vector is handled as a special-case; // somewhere below here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Modifiability,variab,variable,38,// Create an all-constant vector. The variable element in the old; // build vector is replaced by undef in the constant vector. Save the; // variable scalar element and its index for use in the insertelement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:141,Modifiability,variab,variable,141,// Create an all-constant vector. The variable element in the old; // build vector is replaced by undef in the constant vector. Save the; // variable scalar element and its index for use in the insertelement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:175,Performance,load,loading,175,"// The constants we just created may not be legal (eg, floating point). We; // must lower the vector right here because we can not guarantee that we'll; // legalize it before loading it. This is also why we could not just create; // a new build vector here. If the build vector contains illegal constants,; // it could get split back up into a series of insert elements.; // TODO: Improve this by using shorter loads with broadcast/VZEXT_LOAD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:411,Performance,load,loads,411,"// The constants we just created may not be legal (eg, floating point). We; // must lower the vector right here because we can not guarantee that we'll; // legalize it before loading it. This is also why we could not just create; // a new build vector here. If the build vector contains illegal constants,; // it could get split back up into a series of insert elements.; // TODO: Improve this by using shorter loads with broadcast/VZEXT_LOAD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:101,Safety,avoid,avoid,101,"// There's no good way to insert into the high elements of a >128-bit; // vector, so use shuffles to avoid an extract/insert sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:229,Integrability,depend,depending,229,"// If we have a constant or non-constant insertion into the low element of; // a vector, we can do this with SCALAR_TO_VECTOR + shuffle of zero into; // the rest of the elements. This will be matched as movd/movq/movss/movsd; // depending on what the source datatype is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,Modifiability,extend,extend,64,"// We can't directly insert an i8 or i16 into a vector, so zero extend; // it to i32 first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,Testability,log,logical,18,// Is it a vector logical left shift?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:44,Performance,load,load,44,"// Otherwise, it's better to do a constpool load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:186,Performance,load,load,186,"// Otherwise, if this is a vector with i32 or f32 elements, and the element; // is a non-constant being inserted into an element other than the low one,; // we can't use a constant pool load. Instead, use SCALAR_TO_VECTOR (aka; // movd/movss) to move this into the low element, then shuffle it into; // place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:66,Performance,load,load,66,"// Instead of a shuffle like this:; // shuffle (scalar_to_vector (load (ptr + 4))), undef, <0, 0, 0, 0>; // Check if it's possible to issue this instead.; // shuffle (vload ptr)), undef, <1, 1, 1, 1>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,Performance,load,load,128,"// A vector full of immediates; various special cases are already; // handled, so this is best done with a single constant-pool load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,Performance,load,load,30,// See if we can use a vector load to get all of the elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,Modifiability,extend,extending,56,"// Otherwise, expand into a number of unpckl*, start by extending each of; // our (non-undef) elements to the full vector width with the element in the; // bottom slot of the vector (which generates no code for SSE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Availability,mask,mask,34,// Generate scaled UNPCKL shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:120,Safety,Detect,Detect,120,// 256-bit AVX can use the vinsertf128 instruction; // to create 256-bit vectors from two other 128-bit ones.; // TODO: Detect subvector broadcast here instead of DAG combine?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,Usability,simpl,simply,62,// If there are zero or one non-zeros we can handle this very simply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:641,Availability,mask,mask,641,"//===----------------------------------------------------------------------===//; // Vector shuffle lowering; //; // This is an experimental code path for lowering vector shuffles on x86. It is; // designed to handle arbitrary vector shuffles and blends, gracefully; // degrading performance as necessary. It works hard to recognize idiomatic; // shuffles and lower them to optimal instruction patterns without leaving; // a framework that allows reasonably efficient handling of all vector shuffle; // patterns.; //===----------------------------------------------------------------------===//; /// Tiny helper function to identify a no-op mask.; ///; /// This is a somewhat boring predicate function. It checks whether the mask; /// array input, which is assumed to be a single-input shuffle mask of the kind; /// used by the X86 shuffle instructions (not a fully general; /// ShuffleVectorSDNode mask) requires any shuffles to occur. Both undef and an; /// in-place shuffle are 'no-op's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:725,Availability,mask,mask,725,"//===----------------------------------------------------------------------===//; // Vector shuffle lowering; //; // This is an experimental code path for lowering vector shuffles on x86. It is; // designed to handle arbitrary vector shuffles and blends, gracefully; // degrading performance as necessary. It works hard to recognize idiomatic; // shuffles and lower them to optimal instruction patterns without leaving; // a framework that allows reasonably efficient handling of all vector shuffle; // patterns.; //===----------------------------------------------------------------------===//; /// Tiny helper function to identify a no-op mask.; ///; /// This is a somewhat boring predicate function. It checks whether the mask; /// array input, which is assumed to be a single-input shuffle mask of the kind; /// used by the X86 shuffle instructions (not a fully general; /// ShuffleVectorSDNode mask) requires any shuffles to occur. Both undef and an; /// in-place shuffle are 'no-op's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:794,Availability,mask,mask,794,"//===----------------------------------------------------------------------===//; // Vector shuffle lowering; //; // This is an experimental code path for lowering vector shuffles on x86. It is; // designed to handle arbitrary vector shuffles and blends, gracefully; // degrading performance as necessary. It works hard to recognize idiomatic; // shuffles and lower them to optimal instruction patterns without leaving; // a framework that allows reasonably efficient handling of all vector shuffle; // patterns.; //===----------------------------------------------------------------------===//; /// Tiny helper function to identify a no-op mask.; ///; /// This is a somewhat boring predicate function. It checks whether the mask; /// array input, which is assumed to be a single-input shuffle mask of the kind; /// used by the X86 shuffle instructions (not a fully general; /// ShuffleVectorSDNode mask) requires any shuffles to occur. Both undef and an; /// in-place shuffle are 'no-op's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:899,Availability,mask,mask,899,"//===----------------------------------------------------------------------===//; // Vector shuffle lowering; //; // This is an experimental code path for lowering vector shuffles on x86. It is; // designed to handle arbitrary vector shuffles and blends, gracefully; // degrading performance as necessary. It works hard to recognize idiomatic; // shuffles and lower them to optimal instruction patterns without leaving; // a framework that allows reasonably efficient handling of all vector shuffle; // patterns.; //===----------------------------------------------------------------------===//; /// Tiny helper function to identify a no-op mask.; ///; /// This is a somewhat boring predicate function. It checks whether the mask; /// array input, which is assumed to be a single-input shuffle mask of the kind; /// used by the X86 shuffle instructions (not a fully general; /// ShuffleVectorSDNode mask) requires any shuffles to occur. Both undef and an; /// in-place shuffle are 'no-op's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:458,Energy Efficiency,efficient,efficient,458,"//===----------------------------------------------------------------------===//; // Vector shuffle lowering; //; // This is an experimental code path for lowering vector shuffles on x86. It is; // designed to handle arbitrary vector shuffles and blends, gracefully; // degrading performance as necessary. It works hard to recognize idiomatic; // shuffles and lower them to optimal instruction patterns without leaving; // a framework that allows reasonably efficient handling of all vector shuffle; // patterns.; //===----------------------------------------------------------------------===//; /// Tiny helper function to identify a no-op mask.; ///; /// This is a somewhat boring predicate function. It checks whether the mask; /// array input, which is assumed to be a single-input shuffle mask of the kind; /// used by the X86 shuffle instructions (not a fully general; /// ShuffleVectorSDNode mask) requires any shuffles to occur. Both undef and an; /// in-place shuffle are 'no-op's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:280,Performance,perform,performance,280,"//===----------------------------------------------------------------------===//; // Vector shuffle lowering; //; // This is an experimental code path for lowering vector shuffles on x86. It is; // designed to handle arbitrary vector shuffles and blends, gracefully; // degrading performance as necessary. It works hard to recognize idiomatic; // shuffles and lower them to optimal instruction patterns without leaving; // a framework that allows reasonably efficient handling of all vector shuffle; // patterns.; //===----------------------------------------------------------------------===//; /// Tiny helper function to identify a no-op mask.; ///; /// This is a somewhat boring predicate function. It checks whether the mask; /// array input, which is assumed to be a single-input shuffle mask of the kind; /// used by the X86 shuffle instructions (not a fully general; /// ShuffleVectorSDNode mask) requires any shuffles to occur. Both undef and an; /// in-place shuffle are 'no-op's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,Availability,mask,mask,87,/// Test whether there are elements crossing LaneSizeInBits lanes in this; /// shuffle mask.; ///; /// X86 divides up its shuffles into in-lane and cross-lane shuffle operations; /// and we routinely test for these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:190,Integrability,rout,routinely,190,/// Test whether there are elements crossing LaneSizeInBits lanes in this; /// shuffle mask.; ///; /// X86 divides up its shuffles into in-lane and cross-lane shuffle operations; /// and we routinely test for these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether there are elements crossing LaneSizeInBits lanes in this; /// shuffle mask.; ///; /// X86 divides up its shuffles into in-lane and cross-lane shuffle operations; /// and we routinely test for these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:200,Testability,test,test,200,/// Test whether there are elements crossing LaneSizeInBits lanes in this; /// shuffle mask.; ///; /// X86 divides up its shuffles into in-lane and cross-lane shuffle operations; /// and we routinely test for these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:80,Availability,mask,mask,80,/// Test whether there are elements crossing 128-bit lanes in this; /// shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether there are elements crossing 128-bit lanes in this; /// shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:70,Availability,mask,mask,70,/// Test whether elements in each LaneSizeInBits lane in this shuffle mask come; /// from multiple lanes - this is different to isLaneCrossingShuffleMask to; /// better support 'repeated mask + lane permute' style shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:187,Availability,mask,mask,187,/// Test whether elements in each LaneSizeInBits lane in this shuffle mask come; /// from multiple lanes - this is different to isLaneCrossingShuffleMask to; /// better support 'repeated mask + lane permute' style shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether elements in each LaneSizeInBits lane in this shuffle mask come; /// from multiple lanes - this is different to isLaneCrossingShuffleMask to; /// better support 'repeated mask + lane permute' style shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,Availability,mask,mask,27,"/// Test whether a shuffle mask is equivalent within each sub-lane.; ///; /// This checks a shuffle mask to see if it is performing the same; /// lane-relative shuffle in each sub-lane. This trivially implies; /// that it is also not lane-crossing. It may however involve a blend from the; /// same lane of a second vector.; ///; /// The specific repeated shuffle mask is populated in \p RepeatedMask, as it is; /// non-trivial to compute in the face of undef lanes. The representation is; /// suitable for use with existing 128-bit shuffles as entries from the second; /// vector have been remapped to [LaneSize, 2*LaneSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:100,Availability,mask,mask,100,"/// Test whether a shuffle mask is equivalent within each sub-lane.; ///; /// This checks a shuffle mask to see if it is performing the same; /// lane-relative shuffle in each sub-lane. This trivially implies; /// that it is also not lane-crossing. It may however involve a blend from the; /// same lane of a second vector.; ///; /// The specific repeated shuffle mask is populated in \p RepeatedMask, as it is; /// non-trivial to compute in the face of undef lanes. The representation is; /// suitable for use with existing 128-bit shuffles as entries from the second; /// vector have been remapped to [LaneSize, 2*LaneSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:364,Availability,mask,mask,364,"/// Test whether a shuffle mask is equivalent within each sub-lane.; ///; /// This checks a shuffle mask to see if it is performing the same; /// lane-relative shuffle in each sub-lane. This trivially implies; /// that it is also not lane-crossing. It may however involve a blend from the; /// same lane of a second vector.; ///; /// The specific repeated shuffle mask is populated in \p RepeatedMask, as it is; /// non-trivial to compute in the face of undef lanes. The representation is; /// suitable for use with existing 128-bit shuffles as entries from the second; /// vector have been remapped to [LaneSize, 2*LaneSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:121,Performance,perform,performing,121,"/// Test whether a shuffle mask is equivalent within each sub-lane.; ///; /// This checks a shuffle mask to see if it is performing the same; /// lane-relative shuffle in each sub-lane. This trivially implies; /// that it is also not lane-crossing. It may however involve a blend from the; /// same lane of a second vector.; ///; /// The specific repeated shuffle mask is populated in \p RepeatedMask, as it is; /// non-trivial to compute in the face of undef lanes. The representation is; /// suitable for use with existing 128-bit shuffles as entries from the second; /// vector have been remapped to [LaneSize, 2*LaneSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,"/// Test whether a shuffle mask is equivalent within each sub-lane.; ///; /// This checks a shuffle mask to see if it is performing the same; /// lane-relative shuffle in each sub-lane. This trivially implies; /// that it is also not lane-crossing. It may however involve a blend from the; /// same lane of a second vector.; ///; /// The specific repeated shuffle mask is populated in \p RepeatedMask, as it is; /// non-trivial to compute in the face of undef lanes. The representation is; /// suitable for use with existing 128-bit shuffles as entries from the second; /// vector have been remapped to [LaneSize, 2*LaneSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Safety,detect,detecting,38,"// Ok, handle the in-lane shuffles by detecting if and when they repeat.; // Adjust second vector indices to start at LaneSize instead of Size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Availability,mask,mask,38,// Found a mismatch with the repeated mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,Availability,mask,mask,27,/// Test whether a shuffle mask is equivalent within each 128-bit lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether a shuffle mask is equivalent within each 128-bit lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,Availability,mask,mask,27,/// Test whether a shuffle mask is equivalent within each 256-bit lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether a shuffle mask is equivalent within each 256-bit lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Availability,mask,mask,34,/// Test whether a target shuffle mask is equivalent within each sub-lane.; /// Unlike isRepeatedShuffleMask we must respect SM_SentinelZero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether a target shuffle mask is equivalent within each sub-lane.; /// Unlike isRepeatedShuffleMask we must respect SM_SentinelZero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Safety,detect,detecting,34,// Handle the in-lane shuffles by detecting if and when they repeat. Adjust; // later vector indices to start at multiples of LaneSize instead of Size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Availability,mask,mask,38,// Found a mismatch with the repeated mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Availability,mask,mask,34,/// Test whether a target shuffle mask is equivalent within each sub-lane.; /// Unlike isRepeatedShuffleMask we must respect SM_SentinelZero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether a target shuffle mask is equivalent within each sub-lane.; /// Unlike isRepeatedShuffleMask we must respect SM_SentinelZero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,Availability,mask,masks,65,/// Checks whether the vector elements referenced by two shuffle masks are; /// equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:143,Availability,Mask,MaskSize,143,"// If the values are build vectors, we can look through them to find; // equivalent inputs that make the shuffles equivalent.; // TODO: Handle MaskSize != Op.getNumOperands()?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Availability,Mask,MaskSize,16,// TODO: Handle MaskSize != Op.getValueType().getVectorNumElements()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,Availability,Mask,MaskSize,87,"// HOP(X,X) can refer to the elt from the lower/upper half of a lane.; // TODO: Handle MaskSize != NumElts?; // TODO: Handle HOP(X,Y) vs HOP(Y,X) equivalence cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,Availability,mask,mask,29,"/// Checks whether a shuffle mask is equivalent to an explicit list of; /// arguments.; ///; /// This is a fast way to test a shuffle mask against a fixed pattern:; ///; /// if (isShuffleEquivalent(Mask, 3, 2, {1, 0})) { ... }; ///; /// It returns true if the mask is exactly as wide as the argument list, and; /// each element of the mask is either -1 (signifying undef) or the value given; /// in the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:134,Availability,mask,mask,134,"/// Checks whether a shuffle mask is equivalent to an explicit list of; /// arguments.; ///; /// This is a fast way to test a shuffle mask against a fixed pattern:; ///; /// if (isShuffleEquivalent(Mask, 3, 2, {1, 0})) { ... }; ///; /// It returns true if the mask is exactly as wide as the argument list, and; /// each element of the mask is either -1 (signifying undef) or the value given; /// in the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:198,Availability,Mask,Mask,198,"/// Checks whether a shuffle mask is equivalent to an explicit list of; /// arguments.; ///; /// This is a fast way to test a shuffle mask against a fixed pattern:; ///; /// if (isShuffleEquivalent(Mask, 3, 2, {1, 0})) { ... }; ///; /// It returns true if the mask is exactly as wide as the argument list, and; /// each element of the mask is either -1 (signifying undef) or the value given; /// in the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:260,Availability,mask,mask,260,"/// Checks whether a shuffle mask is equivalent to an explicit list of; /// arguments.; ///; /// This is a fast way to test a shuffle mask against a fixed pattern:; ///; /// if (isShuffleEquivalent(Mask, 3, 2, {1, 0})) { ... }; ///; /// It returns true if the mask is exactly as wide as the argument list, and; /// each element of the mask is either -1 (signifying undef) or the value given; /// in the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:335,Availability,mask,mask,335,"/// Checks whether a shuffle mask is equivalent to an explicit list of; /// arguments.; ///; /// This is a fast way to test a shuffle mask against a fixed pattern:; ///; /// if (isShuffleEquivalent(Mask, 3, 2, {1, 0})) { ... }; ///; /// It returns true if the mask is exactly as wide as the argument list, and; /// each element of the mask is either -1 (signifying undef) or the value given; /// in the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:119,Testability,test,test,119,"/// Checks whether a shuffle mask is equivalent to an explicit list of; /// arguments.; ///; /// This is a fast way to test a shuffle mask against a fixed pattern:; ///; /// if (isShuffleEquivalent(Mask, 3, 2, {1, 0})) { ... }; ///; /// It returns true if the mask is exactly as wide as the argument list, and; /// each element of the mask is either -1 (signifying undef) or the value given; /// in the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Availability,mask,mask,36,"/// Checks whether a target shuffle mask is equivalent to an explicit pattern.; ///; /// The masks must be exactly the same width.; ///; /// If an element in Mask matches SM_SentinelUndef (-1) then the corresponding; /// value in ExpectedMask is always accepted. Otherwise the indices must match.; ///; /// SM_SentinelZero is accepted as a valid negative index but must match in; /// both, or via a known bits test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:93,Availability,mask,masks,93,"/// Checks whether a target shuffle mask is equivalent to an explicit pattern.; ///; /// The masks must be exactly the same width.; ///; /// If an element in Mask matches SM_SentinelUndef (-1) then the corresponding; /// value in ExpectedMask is always accepted. Otherwise the indices must match.; ///; /// SM_SentinelZero is accepted as a valid negative index but must match in; /// both, or via a known bits test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:158,Availability,Mask,Mask,158,"/// Checks whether a target shuffle mask is equivalent to an explicit pattern.; ///; /// The masks must be exactly the same width.; ///; /// If an element in Mask matches SM_SentinelUndef (-1) then the corresponding; /// value in ExpectedMask is always accepted. Otherwise the indices must match.; ///; /// SM_SentinelZero is accepted as a valid negative index but must match in; /// both, or via a known bits test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:410,Testability,test,test,410,"/// Checks whether a target shuffle mask is equivalent to an explicit pattern.; ///; /// The masks must be exactly the same width.; ///; /// If an element in Mask matches SM_SentinelUndef (-1) then the corresponding; /// value in ExpectedMask is always accepted. Otherwise the indices must match.; ///; /// SM_SentinelZero is accepted as a valid negative index but must match in; /// both, or via a known bits test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,Availability,mask,mask,41,// Check for out-of-range target shuffle mask indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,Availability,mask,mask,63,// Don't use V1/V2 if they're not the same size as the shuffle mask type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:90,Availability,mask,mask,90,"// If we need this expected index to be a zero element, then update the; // relevant zero mask and perform the known bits at the end to minimize; // repeated computes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,Deployability,update,update,61,"// If we need this expected index to be a zero element, then update the; // relevant zero mask and perform the known bits at the end to minimize; // repeated computes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:99,Performance,perform,perform,99,"// If we need this expected index to be a zero element, then update the; // relevant zero mask and perform the known bits at the end to minimize; // repeated computes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,Availability,mask,mask,24,// Check if the shuffle mask is suitable for the AVX vpunpcklwd or vpunpckhwd; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,Availability,mask,mask,39,// Create 128-bit vector type based on mask size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,Availability,mask,mask,39,"// We can't assume a canonical shuffle mask, so try the commuted version too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,Availability,mask,mask,29,"/// Return true if a shuffle mask chooses elements identically in its top and; /// bottom halves. For example, any splat mask has the same top and bottom; /// halves. If an element is undefined in only one half of the mask, the halves; /// are not considered identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:121,Availability,mask,mask,121,"/// Return true if a shuffle mask chooses elements identically in its top and; /// bottom halves. For example, any splat mask has the same top and bottom; /// halves. If an element is undefined in only one half of the mask, the halves; /// are not considered identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:218,Availability,mask,mask,218,"/// Return true if a shuffle mask chooses elements identically in its top and; /// bottom halves. For example, any splat mask has the same top and bottom; /// halves. If an element is undefined in only one half of the mask, the halves; /// are not considered identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Availability,mask,mask,47,"/// Get a 4-lane 8-bit shuffle immediate for a mask.; ///; /// This helper function produces an 8-bit shuffle immediate corresponding to; /// the ubiquitous shuffle encoding scheme used in x86 instructions for; /// shuffling 4 lanes. It can be used with most of the PSHUF instructions for; /// example.; ///; /// NB: We rely heavily on ""undef"" masks preserving the input lane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:344,Availability,mask,masks,344,"/// Get a 4-lane 8-bit shuffle immediate for a mask.; ///; /// This helper function produces an 8-bit shuffle immediate corresponding to; /// the ubiquitous shuffle encoding scheme used in x86 instructions for; /// shuffling 4 lanes. It can be used with most of the PSHUF instructions for; /// example.; ///; /// NB: We rely heavily on ""undef"" masks preserving the input lane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask only uses one non-undef element, then fully 'splat' it to; // improve later broadcast matching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:166,Availability,Mask,Mask,166,"// The Shuffle result is as follow:; // 0*a[0]0*a[1]...0*a[n] , n >=0 where a[] elements in a ascending order.; // Each Zeroable's element correspond to a particular Mask's element.; // As described in computeZeroableShuffleElements function.; //; // The function looks for a sub-mask that the nonzero elements are in; // increasing order. If such sub-mask exist. The function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:280,Availability,mask,mask,280,"// The Shuffle result is as follow:; // 0*a[0]0*a[1]...0*a[n] , n >=0 where a[] elements in a ascending order.; // Each Zeroable's element correspond to a particular Mask's element.; // As described in computeZeroableShuffleElements function.; //; // The function looks for a sub-mask that the nonzero elements are in; // increasing order. If such sub-mask exist. The function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:352,Availability,mask,mask,352,"// The Shuffle result is as follow:; // 0*a[0]0*a[1]...0*a[n] , n >=0 where a[] elements in a ascending order.; // Each Zeroable's element correspond to a particular Mask's element.; // As described in computeZeroableShuffleElements function.; //; // The function looks for a sub-mask that the nonzero elements are in; // increasing order. If such sub-mask exist. The function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Availability,Mask,Mask,16,// Check if the Mask's nonzero elements are in increasing order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,Availability,mask,mask,17,// Checks if the mask's zeros elements are built from only zeros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,Availability,mask,mask,15,// Exit if the mask's non zero elements are not in increasing order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Availability,mask,mask,22,// Sign bit set in i8 mask means zero element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,Availability,mask,mask,31,// Attempt to match the target mask against the unpack lo/hi mask patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,Availability,mask,mask,61,// Attempt to match the target mask against the unpack lo/hi mask patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,Availability,mask,mask,17,/// Check if the mask can be mapped to a preliminary shuffle (vperm 64-bit); /// followed by unpack 256-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Availability,mask,mask,16,"// Check if the mask can be mapped to a TRUNCATE or VTRUNC, truncating the; // source into the lower elements and zeroing the upper elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform a direct ISD::TRUNCATE if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,Performance,perform,perform,40,// Don't do this if PACKSS/PACKUS could perform it cheaper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,Availability,avail,available,19,// VPMOVWB is only available with avx512bw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:258,Availability,mask,masks,258,"/// Check whether a compaction lowering can be done by dropping even/odd; /// elements and compute how many times even/odd elements must be dropped.; ///; /// This handles shuffles which take every Nth element where N is a power of; /// two. Example shuffle masks:; ///; /// (even); /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30; /// N = 2: 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12; /// N = 2: 0, 4, 8, 12, 16, 20, 24, 28, 0, 4, 8, 12, 16, 20, 24, 28; /// N = 3: 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8; /// N = 3: 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24; ///; /// (odd); /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31; ///; /// Any of these lanes can of course be undef.; ///; /// This routine only supports N <= 3.; /// FIXME: Evaluate whether either AVX or AVX-512 have any opportunities here; /// for larger N.; ///; /// \returns N above, or the number of times even/odd elements must be dropped; /// if there is such a number. Otherwise returns zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:223,Energy Efficiency,power,power,223,"/// Check whether a compaction lowering can be done by dropping even/odd; /// elements and compute how many times even/odd elements must be dropped.; ///; /// This handles shuffles which take every Nth element where N is a power of; /// two. Example shuffle masks:; ///; /// (even); /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30; /// N = 2: 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12; /// N = 2: 0, 4, 8, 12, 16, 20, 24, 28, 0, 4, 8, 12, 16, 20, 24, 28; /// N = 3: 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8; /// N = 3: 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24; ///; /// (odd); /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31; ///; /// Any of these lanes can of course be undef.; ///; /// This routine only supports N <= 3.; /// FIXME: Evaluate whether either AVX or AVX-512 have any opportunities here; /// for larger N.; ///; /// \returns N above, or the number of times even/odd elements must be dropped; /// if there is such a number. Otherwise returns zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:894,Integrability,rout,routine,894,"/// Check whether a compaction lowering can be done by dropping even/odd; /// elements and compute how many times even/odd elements must be dropped.; ///; /// This handles shuffles which take every Nth element where N is a power of; /// two. Example shuffle masks:; ///; /// (even); /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30; /// N = 2: 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12; /// N = 2: 0, 4, 8, 12, 16, 20, 24, 28, 0, 4, 8, 12, 16, 20, 24, 28; /// N = 3: 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8; /// N = 3: 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24; ///; /// (odd); /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31; ///; /// Any of these lanes can of course be undef.; ///; /// This routine only supports N <= 3.; /// FIXME: Evaluate whether either AVX or AVX-512 have any opportunities here; /// for larger N.; ///; /// \returns N above, or the number of times even/odd elements must be dropped; /// if there is such a number. Otherwise returns zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,Energy Efficiency,power,power-of-,48,"// We track whether the input is viable for all power-of-2 strides 2^1, 2^2,; // and 2^3 simultaneously. This is because we may have ambiguity with; // partially undef inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,Availability,mask,mask,15,// The shuffle mask must be equal to (i * 2^N) % M.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,Energy Efficiency,power,powers,41,// Early exit if we exhaust the possible powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,Energy Efficiency,power,power,34,// Return 0 as there is no viable power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:144,Availability,mask,masks,144,// X86 has dedicated pack instructions that can handle specific truncation; // operations: PACKSS and PACKUS.; // Checks for compaction shuffle masks if MaxStages > 1.; // TODO: Add support for matching multiple PACKSS/PACKUS stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,Availability,down,down,19,// Repeatedly pack down to the target size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Availability,mask,mask,38,// Can only let one input through the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:103,Availability,mask,mask,103,"// For 32/64-bit elements, if we only reference one input (plus any undefs),; // then ensure the blend mask part for that lane just references that input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,Availability,mask,mask,40,// Attempt to generate the binary blend mask. If an input is zero then; // we can use any lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,Availability,mask,mask,48,// If we only used V2 then splat the lane blend mask to avoid any demanded; // elts from V1 in this lane (the V1 equivalent is implicit with a zero; // blend mask bit).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:158,Availability,mask,mask,158,// If we only used V2 then splat the lane blend mask to avoid any demanded; // elts from V1 in this lane (the V1 equivalent is implicit with a zero; // blend mask bit).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,Safety,avoid,avoid,56,// If we only used V2 then splat the lane blend mask to avoid any demanded; // elts from V1 in this lane (the V1 equivalent is implicit with a zero; // blend mask bit).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:96,Availability,avail,availability,96,"/// Try to emit a blend instruction for a shuffle.; ///; /// This doesn't do any checks for the availability of instructions for blending; /// these values. It relies on the availability of the X86ISD::BLENDI pattern to; /// be matched in the backend with the type given. What it does check for is; /// that the shuffle mask is a blend, or convertible into a blend with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:174,Availability,avail,availability,174,"/// Try to emit a blend instruction for a shuffle.; ///; /// This doesn't do any checks for the availability of instructions for blending; /// these values. It relies on the availability of the X86ISD::BLENDI pattern to; /// be matched in the backend with the type given. What it does check for is; /// that the shuffle mask is a blend, or convertible into a blend with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:320,Availability,mask,mask,320,"/// Try to emit a blend instruction for a shuffle.; ///; /// This doesn't do any checks for the availability of instructions for blending; /// these values. It relies on the availability of the X86ISD::BLENDI pattern to; /// be matched in the backend with the type given. What it does check for is; /// that the shuffle mask is a blend, or convertible into a blend with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,Performance,load,load,14,"// x86 allows load folding with blendvb from the 2nd source operand. But; // we are still using LLVM select here (see comment below), so that's V1.; // If V2 can be load-folded and V1 cannot be load-folded, then commute to; // allow that load-folding possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:165,Performance,load,load-folded,165,"// x86 allows load folding with blendvb from the 2nd source operand. But; // we are still using LLVM select here (see comment below), so that's V1.; // If V2 can be load-folded and V1 cannot be load-folded, then commute to; // allow that load-folding possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:194,Performance,load,load-folded,194,"// x86 allows load folding with blendvb from the 2nd source operand. But; // we are still using LLVM select here (see comment below), so that's V1.; // If V2 can be load-folded and V1 cannot be load-folded, then commute to; // allow that load-folding possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:238,Performance,load,load-folding,238,"// x86 allows load folding with blendvb from the 2nd source operand. But; // we are still using LLVM select here (see comment below), so that's V1.; // If V2 can be load-folded and V1 cannot be load-folded, then commute to; // allow that load-folding possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,Availability,mask,mask,23,"// Compute the VSELECT mask. Note that VSELECT is really confusing in the; // mix of LLVM's code generator and the x86 backend. We tell the code; // generator that boolean values in the elements of an x86 vector register; // are -1 for true and 0 for false. We then use the LLVM semantics of 'true'; // mapping a select to operand #1, and 'false' mapping to operand #2. The; // reality in x86 is that vector masks (pre-AVX-512) use only the high bit; // of the element (the remaining are ignored) and 0 in that high bit would; // mean operand #1 while 1 in the high bit would mean operand #2. So while; // the LLVM model for boolean values in vector elements gets the relevant; // bit set, it is set backwards and over constrained relative to x86's; // actual model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:408,Availability,mask,masks,408,"// Compute the VSELECT mask. Note that VSELECT is really confusing in the; // mix of LLVM's code generator and the x86 backend. We tell the code; // generator that boolean values in the elements of an x86 vector register; // are -1 for true and 0 for false. We then use the LLVM semantics of 'true'; // mapping a select to operand #1, and 'false' mapping to operand #2. The; // reality in x86 is that vector masks (pre-AVX-512) use only the high bit; // of the element (the remaining are ignored) and 0 in that high bit would; // mean operand #1 while 1 in the high bit would mean operand #2. So while; // the LLVM model for boolean values in vector elements gets the relevant; // bit set, it is set backwards and over constrained relative to x86's; // actual model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,Performance,optimiz,optimizing,56,// Attempt to lower to a bitmask if we can. Only if not optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:77,Availability,mask,masked,77,"// Otherwise load an immediate into a GPR, cast to k-register, and use a; // masked move.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,Performance,load,load,13,"// Otherwise load an immediate into a GPR, cast to k-register, and use a; // masked move.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:194,Energy Efficiency,reduce,reduce,194,/// Try to lower as a blend of elements from two inputs followed by; /// a single-input permutation.; ///; /// This matches the pattern where we can blend elements from two inputs and; /// then reduce the shuffle to a single-input permutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Availability,mask,mask,25,// We build up the blend mask while checking whether a blend is a viable way; // to reduce the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,Energy Efficiency,reduce,reduce,84,// We build up the blend mask while checking whether a blend is a viable way; // to reduce the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,Availability,mask,mask,52,"// If only immediate blends, then bail if the blend mask can't be widened to; // i16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:197,Energy Efficiency,reduce,reduce,197,/// Try to lower as an unpack of elements from two inputs followed by; /// a single-input permutation.; ///; /// This matches the pattern where we can unpack elements from two inputs and; /// then reduce the shuffle to a single-input (wider) permutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,Availability,mask,mask,17,// Normalize the mask value depending on whether it's V1 or V2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,Integrability,depend,depending,28,// Normalize the mask value depending on whether it's V1 or V2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,Availability,mask,mask,67,// Element indices have changed after unpacking. Calculate permute mask; // so that they will be put back to the position as dictated by the; // original shuffle mask indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:162,Availability,mask,mask,162,// Element indices have changed after unpacking. Calculate permute mask; // so that they will be put back to the position as dictated by the; // original shuffle mask indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:295,Integrability,rout,routine,295,"/// Try to lower a shuffle as a permute of the inputs followed by an; /// UNPCK instruction.; ///; /// This specifically targets cases where we end up with alternating between; /// the two inputs, and so can permute them into something that feeds a single; /// UNPCK instruction. Note that this routine only targets integer vectors; /// because for floating point vectors we have a generalized SHUFPS lowering; /// strategy that handles everything that doesn't *exactly* match an unpack,; /// making this clever lowering unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,Integrability,rout,routine,8,// This routine only supports 128-bit integer dual input vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,Availability,mask,mask,64,// Each element of the unpack contains Scale elements from this mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,Availability,mask,mask,13,// Setup the mask for this input. The indexing is tricky as we have to; // handle the unpack stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:94,Availability,mask,mask,94,// We try each unpack from the largest to the smallest to try and find one; // that fits this mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Availability,mask,mask,22,// Determine range of mask elts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,Security,access,access,30,"// Rotate the 2 ops so we can access both ranges, then permute the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,Availability,Mask,Mask,17,/// Check if the Mask consists of the same element repeated multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,Integrability,rout,routine,12,/// Generic routine to decompose a shuffle and blend into independent; /// blends and permutes.; ///; /// This matches the extremely common pattern for handling combined; /// shuffle+blend operations on newer X86 ISAs where we have very fast blend; /// operations. It will try to pick the best arrangement of shuffles and; /// blends. For vXi8/vXi16 shuffles we may use unpack instead of blend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:177,Availability,mask,mask,177,"// If we effectively only demand the 0'th element of \p Input, and not only; // as 0'th element, then broadcast said input,; // and change \p InputMask to be a no-op (identity) mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:175,Usability,simpl,simplify,175,"// Currently, we may need to produce one shuffle per input, and blend results.; // It is possible that the shuffle for one of the inputs is already a no-op.; // See if we can simplify non-no-op shuffles into broadcasts,; // which we consider to be strictly better than an arbitrary shuffle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:201,Performance,load,load,201,"// Try to lower with the simpler initial blend/unpack/rotate strategies unless; // one of the input shuffles would be a no-op. We prefer to shuffle inputs as; // the shuffle may be able to fold with a load or other benefit. However, when; // we'll have to do 2x as many shuffles in order to achieve this, a 2-input; // pre-shuffle first is a better strategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Usability,simpl,simpler,25,"// Try to lower with the simpler initial blend/unpack/rotate strategies unless; // one of the input shuffles would be a no-op. We prefer to shuffle inputs as; // the shuffle may be able to fold with a load or other benefit. However, when; // we'll have to do 2x as many shuffles in order to achieve this, a 2-input; // pre-shuffle first is a better strategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,Modifiability,variab,variable,41,// Unpack/rotate failed - try again with variable blends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Availability,mask,mask,16,"// If the final mask is an alternating blend of vXi8/vXi16, convert to an; // UNPCKL(SHUFFLE, SHUFFLE) pattern.; // TODO: It doesn't have to be alternating - but each lane mustn't have more; // than half the elements coming from each source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:114,Energy Efficiency,efficient,efficient,114,"// For pre-SSSE3 targets, if we are shuffling vXi8 elts then ISD::ROTL,; // expanded to OR(SRL,SHL), will be more efficient, but if they can; // widen to vXi16 or more then existing lowering should will be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,Safety,detect,detect,14,"// We need to detect various ways of spelling a rotation:; // [11, 12, 13, 14, 15, 0, 1, 2]; // [-1, 12, 13, 14, -1, -1, 1, -1]; // [-1, -1, -1, -1, -1, -1, 1, 2]; // [ 3, 4, 5, 6, 7, 8, 9, 10]; // [-1, 4, 5, 6, -1, -1, 9, -1]; // [-1, 4, 5, 6, -1, -1, -1, -1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:53,Availability,mask,mask,53,"// The rotations don't match, so we can't match this mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,Availability,mask,mask,28,// Compute which value this mask is pointing at.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,Availability,mask,mask,43,"// Check that we successfully analyzed the mask, and normalize the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:478,Availability,mask,mask,478,"/// Try to lower a vector shuffle as a byte rotation.; ///; /// SSSE3 has a generic PALIGNR instruction in x86 that will do an arbitrary; /// byte-rotation of the concatenation of two vectors; pre-SSSE3 can use; /// a PSRLDQ/PSLLDQ/POR pattern to get a similar effect. This routine will; /// try to generically lower a vector shuffle through such an pattern. It; /// does not check for the profitability of lowering either as PALIGNR or; /// PSRLDQ/PSLLDQ/POR, only whether the mask is valid to lower in that form.; /// This matches shuffle vectors that look like:; ///; /// v8i16 [11, 12, 13, 14, 15, 0, 1, 2]; ///; /// Essentially it concatenates V1 and V2, shifts right by some number of; /// elements, and takes the low elements as the result. Note that while this is; /// specified as a *right shift* because x86 is little-endian, it is a *left; /// rotate* of the vector lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:274,Integrability,rout,routine,274,"/// Try to lower a vector shuffle as a byte rotation.; ///; /// SSSE3 has a generic PALIGNR instruction in x86 that will do an arbitrary; /// byte-rotation of the concatenation of two vectors; pre-SSSE3 can use; /// a PSRLDQ/PSLLDQ/POR pattern to get a similar effect. This routine will; /// try to generically lower a vector shuffle through such an pattern. It; /// does not check for the profitability of lowering either as PALIGNR or; /// PSRLDQ/PSLLDQ/POR, only whether the mask is valid to lower in that form.; /// This matches shuffle vectors that look like:; ///; /// v8i16 [11, 12, 13, 14, 15, 0, 1, 2]; ///; /// Essentially it concatenates V1 and V2, shifts right by some number of; /// elements, and takes the low elements as the result. Note that while this is; /// specified as a *right shift* because x86 is little-endian, it is a *left; /// rotate* of the vector lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:195,Integrability,rout,routine,195,"/// Try to lower a vector shuffle as a dword/qword rotation.; ///; /// AVX512 has a VALIGND/VALIGNQ instructions that will do an arbitrary; /// rotation of the concatenation of two vectors; This routine will; /// try to generically lower a vector shuffle through such an pattern.; ///; /// Essentially it concatenates V1 and V2, shifts right by some number of; /// elements, and takes the low elements as the result. Note that while this is; /// specified as a *right shift* because x86 is little-endian, it is a *left; /// rotate* of the vector lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,Availability,mask,mask,67,// If we don't have PSHUFB then its worth avoiding an AND constant mask; // by performing 3 byte shifts. Shuffle combining can kick in above that.; // TODO: There may be some cases where VSH{LR}DQ+PAND is still better.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:79,Performance,perform,performing,79,// If we don't have PSHUFB then its worth avoiding an AND constant mask; // by performing 3 byte shifts. Shuffle combining can kick in above that.; // TODO: There may be some cases where VSH{LR}DQ+PAND is still better.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,Safety,avoid,avoiding,42,// If we don't have PSHUFB then its worth avoiding an AND constant mask; // by performing 3 byte shifts. Shuffle combining can kick in above that.; // TODO: There may be some cases where VSH{LR}DQ+PAND is still better.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:106,Availability,mask,mask,106,"/// Try to lower a vector shuffle as a bit shift (shifts in zeros).; ///; /// Attempts to match a shuffle mask against the PSLL(W/D/Q/DQ) and; /// PSRL(W/D/Q/DQ) SSE2 and AVX2 logical bit-shift instructions. The function; /// matches elements from one of the input vectors shuffled to the left or; /// right with zeroable elements 'shifted in'. It handles both the strictly; /// bit-wise element shifts and the byte shift across an entire 128-bit double; /// quad word lane.; ///; /// PSHL : (little-endian) left bit shift.; /// [ zz, 0, zz, 2 ]; /// [ -1, 4, zz, -1 ]; /// PSRL : (little-endian) right bit shift.; /// [ 1, zz, 3, zz]; /// [ -1, -1, 7, zz]; /// PSLLDQ : (little-endian) left byte shift; /// [ zz, 0, 1, 2, 3, 4, 5, 6]; /// [ zz, zz, -1, -1, 2, 3, 4, -1]; /// [ zz, zz, zz, zz, zz, zz, -1, 1]; /// PSRLDQ : (little-endian) right byte shift; /// [ 5, 6, 7, zz, zz, zz, zz, zz]; /// [ -1, 5, 6, 7, zz, zz, zz, zz]; /// [ 1, 2, -1, -1, -1, -1, zz, zz]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:176,Testability,log,logical,176,"/// Try to lower a vector shuffle as a bit shift (shifts in zeros).; ///; /// Attempts to match a shuffle mask against the PSLL(W/D/Q/DQ) and; /// PSRL(W/D/Q/DQ) SSE2 and AVX2 logical bit-shift instructions. The function; /// matches elements from one of the input vectors shuffled to the left or; /// right with zeroable elements 'shifted in'. It handles both the strictly; /// bit-wise element shifts and the byte shift across an entire 128-bit double; /// quad word lane.; ///; /// PSHL : (little-endian) left bit shift.; /// [ zz, 0, zz, 2 ]; /// [ -1, 4, zz, -1 ]; /// PSRL : (little-endian) right bit shift.; /// [ 1, zz, 3, zz]; /// [ -1, -1, 7, zz]; /// PSLLDQ : (little-endian) left byte shift; /// [ zz, 0, 1, 2, 3, 4, 5, 6]; /// [ zz, zz, -1, -1, 2, 3, 4, -1]; /// [ zz, zz, zz, zz, zz, zz, -1, 1]; /// PSRLDQ : (little-endian) right byte shift; /// [ 5, 6, 7, zz, zz, zz, zz, zz]; /// [ -1, 5, 6, 7, zz, zz, zz, zz]; /// [ 1, 2, -1, -1, -1, -1, zz, zz]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,Testability,log,logical,20,// SSE/AVX supports logical shifts up to 64-bit integers - so we can just; // keep doubling the size of the integer elements up to that. We can; // then shift the elements of the integer vector by whole multiples of; // their width within the elements of the larger integer vector. Test each; // multiple to see if we can find a match with the moved element indices; // and that the shifted in elements are all zeroable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:282,Testability,Test,Test,282,// SSE/AVX supports logical shifts up to 64-bit integers - so we can just; // keep doubling the size of the integer elements up to that. We can; // then shift the elements of the integer vector by whole multiples of; // their width within the elements of the larger integer vector. Test each; // multiple to see if we can find a match with the moved element indices; // and that the shifted in elements are all zeroable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,Availability,mask,mask,62,// The extracted elements must start at a valid index and all mask; // elements must be in the lower half.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,Availability,mask,mask,38,// Attempt to match first source from mask before insertion point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend the extraction length looking to match both the insertion of; // the second source and the remaining elements of the first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:200,Availability,avail,available,200,"/// Lower a vector shuffle as a zero or any extension.; ///; /// Given a specific number of elements, element bit width, and extension; /// stride, produce either a zero or any extension based on the available; /// features of the subtarget. The extended elements are consecutive and; /// begin and can start from an offsetted element index in the input; to; /// avoid excess shuffling the offset must either being in the bottom lane; /// or at the start of a higher lane. All extended elements must be from; /// the same lane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:246,Modifiability,extend,extended,246,"/// Lower a vector shuffle as a zero or any extension.; ///; /// Given a specific number of elements, element bit width, and extension; /// stride, produce either a zero or any extension based on the available; /// features of the subtarget. The extended elements are consecutive and; /// begin and can start from an offsetted element index in the input; to; /// avoid excess shuffling the offset must either being in the bottom lane; /// or at the start of a higher lane. All extended elements must be from; /// the same lane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:477,Modifiability,extend,extended,477,"/// Lower a vector shuffle as a zero or any extension.; ///; /// Given a specific number of elements, element bit width, and extension; /// stride, produce either a zero or any extension based on the available; /// features of the subtarget. The extended elements are consecutive and; /// begin and can start from an offsetted element index in the input; to; /// avoid excess shuffling the offset must either being in the bottom lane; /// or at the start of a higher lane. All extended elements must be from; /// the same lane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:363,Safety,avoid,avoid,363,"/// Lower a vector shuffle as a zero or any extension.; ///; /// Given a specific number of elements, element bit width, and extension; /// stride, produce either a zero or any extension based on the available; /// features of the subtarget. The extended elements are consecutive and; /// begin and can start from an offsetted element index in the input; to; /// avoid excess shuffling the offset must either being in the bottom lane; /// or at the start of a higher lane. All extended elements must be from; /// the same lane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,Availability,mask,mask,24,// Found a valid a/zext mask! Try various lowering strategies based on the; // input type and available ISA extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:94,Availability,avail,available,94,// Found a valid a/zext mask! Try various lowering strategies based on the; // input type and available ISA extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,Modifiability,extend,extends,11,// For any extends we can cheat for larger element sizes and use shuffle; // instructions that can fold with a load and/or copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:111,Performance,load,load,111,// For any extends we can cheat for larger element sizes and use shuffle; // instructions that can fold with a load and/or copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,Energy Efficiency,efficient,efficiently,35,// The SSE4A EXTRQ instruction can efficiently extend the first 2 lanes; // to 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Modifiability,extend,extend,47,// The SSE4A EXTRQ instruction can efficiently extend the first 2 lanes; // to 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:88,Availability,avail,available,88,"// If this would require more than 2 unpack instructions to expand, use; // pshufb when available. We can only use more than 2 unpack instructions; // when zero extending i8 elements which also makes it easier to use pshufb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:161,Modifiability,extend,extending,161,"// If this would require more than 2 unpack instructions to expand, use; // pshufb when available. We can only use more than 2 unpack instructions; // when zero extending i8 elements which also makes it easier to use pshufb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,Modifiability,extend,extending,13,"// If we are extending from an offset, ensure we start on a boundary that; // we can unpack from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:546,Availability,mask,masking,546,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,Energy Efficiency,power,power,128,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:406,Energy Efficiency,efficient,efficient,406,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,Integrability,rout,routine,87,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:212,Modifiability,extend,extend,212,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:494,Modifiability,extend,extend,494,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:699,Performance,perform,performance,699,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,Modifiability,extend,extended,15,// Each of the extended elements need to be zeroable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,Modifiability,extend,extend,31,"// If we are offsetting, don't extend if we only match a single input, we; // can always do better by using a basic PSHUF or PUNPCK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,Modifiability,extend,extending,33,// The widest scale possible for extending is to a 64-bit integer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,Modifiability,extend,extending,23,"// Each iteration, try extending the elements half as much, but into twice as; // many elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,Modifiability,extend,extends,11,"// General extends failed, but 128-bit vectors may be able to use MOVQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,Energy Efficiency,reduce,reduced,60,"// Returns one of the source operands if the shuffle can be reduced to a; // MOVQ, copying the lower 64-bits and zero-extending to the upper 64-bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:118,Modifiability,extend,extending,118,"// Returns one of the source operands if the shuffle can be reduced to a; // MOVQ, copying the lower 64-bits and zero-extending to the upper 64-bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Performance,load,load,25,/// Helper to test for a load that can be folded with x86 shuffles.; ///; /// This is particularly important because the set of instructions varies; /// significantly based on whether the operand is a load or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:201,Performance,load,load,201,/// Helper to test for a load that can be folded with x86 shuffles.; ///; /// This is particularly important because the set of instructions varies; /// significantly based on whether the operand is a load or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,Testability,test,test,14,/// Helper to test for a load that can be folded with x86 shuffles.; ///; /// This is particularly important because the set of instructions varies; /// significantly based on whether the operand is a load or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,Energy Efficiency,efficient,efficient,126,/// Try to lower insertion of a single element into a zero vector.; ///; /// This is a common pattern that we have especially efficient patterns to lower; /// across all subtarget feature sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:171,Integrability,rout,routine,171,"// Check for a single input from a SCALAR_TO_VECTOR node.; // FIXME: All of this should be canonicalized into INSERT_VECTOR_ELT and; // all the smarts here sunk into that routine. However, the current; // lowering of BUILD_VECTOR makes that nearly impossible until the old; // vector shuffle lowering is dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:98,Availability,mask,masked,98,// Using zext to expand a narrow element won't work for non-zero; // insertions. But we can use a masked constant vector if we're; // inserting V2 into the bottom of V1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,Modifiability,extend,extend,8,// Zero-extend directly to i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,Availability,mask,mask,39,"// If we're inserting into a constant, mask off the inserted index; // and OR with the zero-extended scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,Modifiability,extend,extended,92,"// If we're inserting into a constant, mask off the inserted index; // and OR with the zero-extended scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:122,Usability,clear,clear,122,// Either not inserting from the low element of the input or the input; // element size is too small to use VZEXT_MOVL to clear the high bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:118,Energy Efficiency,efficient,efficient,118,// If we have 4 or fewer lanes we can cheaply shuffle the element into; // the desired position. Otherwise it is more efficient to do a vector; // shift left. We know that we can do a vector shift left because all; // the inputs are zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:123,Performance,load,load,123,"// If we're extracting non-least-significant bits, shift so we can truncate.; // Hopefully, we can fold away the trunc/srl/load into the broadcast.; // Even if we can't (and !isShuffleFoldableLoad(Scalar)), prefer; // vpbroadcast+vmovd+shr to vpshufb(m)+vmovd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:180,Energy Efficiency,efficient,efficient,180,/// Test whether this can be lowered with a single SHUFPS instruction.; ///; /// This is used to disable more specialized lowerings when the shufps lowering; /// will happen to be efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether this can be lowered with a single SHUFPS instruction.; ///; /// This is used to disable more specialized lowerings when the shufps lowering; /// will happen to be efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,Integrability,rout,routine,8,// This routine only handles 128-bit shufps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,Availability,mask,mask,84,/// Test whether the specified input (0 or 1) is in-place blended by the; /// given mask.; ///; /// This returns true if the elements from a particular input are already in the; /// slot required by the given mask and require no permutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:209,Availability,mask,mask,209,/// Test whether the specified input (0 or 1) is in-place blended by the; /// given mask.; ///; /// This returns true if the elements from a particular input are already in the; /// slot required by the given mask and require no permutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Testability,Test,Test,4,/// Test whether the specified input (0 or 1) is in-place blended by the; /// given mask.; ///; /// This returns true if the elements from a particular input are already in the; /// slot required by the given mask and require no permutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:138,Safety,avoid,avoid,138,"/// If we are extracting two 128-bit halves of a vector and shuffling the; /// result, match that to a 256-bit AVX2 vperm* instruction to avoid a; /// multi-shuffle lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,Availability,mask,mask,25,"// Final bailout: if the mask is simple, we are better off using an extract; // and a simple narrow shuffle. Prefer extract+unpack(h/l)ps to vpermps; // because that avoids a constant load from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:184,Performance,load,load,184,"// Final bailout: if the mask is simple, we are better off using an extract; // and a simple narrow shuffle. Prefer extract+unpack(h/l)ps to vpermps; // because that avoids a constant load from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:166,Safety,avoid,avoids,166,"// Final bailout: if the mask is simple, we are better off using an extract; // and a simple narrow shuffle. Prefer extract+unpack(h/l)ps to vpermps; // because that avoids a constant load from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,Usability,simpl,simple,33,"// Final bailout: if the mask is simple, we are better off using an extract; // and a simple narrow shuffle. Prefer extract+unpack(h/l)ps to vpermps; // because that avoids a constant load from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:86,Usability,simpl,simple,86,"// Final bailout: if the mask is simple, we are better off using an extract; // and a simple narrow shuffle. Prefer extract+unpack(h/l)ps to vpermps; // because that avoids a constant load from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,Availability,mask,mask,22,// Extend the shuffle mask with undef elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend the shuffle mask with undef elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,Performance,load,load,62,"// With MOVDDUP (v2f64) we can broadcast from a register or a load, otherwise; // we can only broadcast from a register with AVX2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,Availability,mask,mask,18,// Check that the mask is a broadcast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,Performance,load,load,55,// Go up the chain of (vector) values to find a scalar load that we can; // combine with the broadcast.; // TODO: Combine this logic with findEltLoadSrc() used by; // EltsFromConsecutiveLoads().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:127,Testability,log,logic,127,// Go up the chain of (vector) values to find a scalar load that we can; // combine with the broadcast.; // TODO: Combine this logic with findEltLoadSrc() used by; // EltsFromConsecutiveLoads().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,Performance,load,loads,128,"// Check if this is a broadcast of a scalar. We special case lowering; // for scalars so that we can more effectively fold with loads.; // If the original value has a larger element type than the shuffle, the; // broadcast element is in essence truncated. Make that explicit to ease; // folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,Usability,simpl,simpler,18,"// Also check the simpler case, where we can directly reuse the scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:68,Performance,load,load,68,"// If we can't broadcast from a register, check that the input is a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:215,Energy Efficiency,Reduce,Reduce,215,"// We do not check for one-use of the vector load because a broadcast load; // is expected to be a win for code size, register pressure, and possibly; // uops even if the original vector load is not eliminated.; // Reduce the vector load and shuffle to a broadcasted scalar load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
